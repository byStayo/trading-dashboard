This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-18T15:48:17.718Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  ai-researcher/
    page.tsx
  api/
    chat/
      route.ts
    company/
      route.ts
    generate/
      route.ts
    generate-insights/
      route.ts
    generate-news/
      route.ts
    generate-trades/
      route.ts
    generate-visualization/
      route.ts
    health/
      route.ts
    market-chat/
      route.ts
    market-data/
      route.ts
    market-updates/
      route.ts
    news/
      route.ts
    polygon/
      aggregates/
        route.ts
    polygon-news/
      route.ts
    polygon-stocks/
      batch/
        route.ts
      market/
        sectors/
          route.ts
        route.ts
      test/
        route.ts
      websocket/
        route.ts
      route.ts
    search/
      route.ts
    stock/
      prev/
        [symbol]/
          route.ts
      quote/
        [symbol]/
          route.ts
      tickers/
        [preset]/
          route.ts
        trending/
          route.ts
    technical/
      route.ts
  asset-screener/
    page.tsx
  asset-search/
    page.tsx
  backtesting/
    page.tsx
  business-major/
    courses/
      page.tsx
    dashboard/
      page.tsx
    page.tsx
  certifications/
    page.tsx
  chat/
    page.tsx
  dashboard/
    layout.tsx
    page.tsx
  due-diligence/
    page.tsx
  economic-calendar/
    page.tsx
  economic-event-tracker/
    page.tsx
  financial-advisor/
    clients/
      page.tsx
    dashboard/
      page.tsx
    pitch-builder/
      page.tsx
    page.tsx
  financial-heatmap/
    page.tsx
  help/
    page.tsx
  investment-banking/
    page.tsx
  market-overview/
    page.tsx
  portfolio/
    page.tsx
  portfolio-analytics/
    page.tsx
  portfolio-optimizer/
    page.tsx
  settings/
    page.tsx
  stock-analysis/
    page.tsx
  technical-analysis/
    page.tsx
  trading/
    page.tsx
  trading-journal/
    page.tsx
  valuation/
    page.tsx
  watchlist/
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  ai-researcher/
    dashboard.tsx
    macro-indicator.tsx
    research-report.tsx
    risk-assessment.tsx
    trend-analysis.tsx
  asset-search/
    asset-card.tsx
    asset-chart.tsx
    asset-details.tsx
    news-panel.tsx
    related-assets.tsx
  auth/
    auth-provider.tsx
    login-form.tsx
  backtesting/
    asset-selector.tsx
    backtest-results.tsx
    backtesting-dashboard.tsx
    strategy-optimizer.tsx
  company/
    CompanyInfoCard.tsx
  due-diligence/
    ai-generated-report.tsx
    due-diligence-dashboard.tsx
    earnings-call-analysis.tsx
    earnings-manipulation-detection.tsx
    financial-statement-analysis.tsx
    insider-transactions.tsx
    sec-filings-analysis.tsx
    valuation-models.tsx
  economic-event-tracker/
    ai-recommendations.tsx
    economic-event-tracker.tsx
    event-calendar.tsx
    event-impact-analysis.tsx
    trend-opportunities.tsx
  financial-heatmap/
    heatmap-legend.tsx
    heatmap.tsx
  generative-ui/
    chat-interface.tsx
    data-visualization.tsx
    market-insights.tsx
    trade-suggestions.tsx
  market/
    MarketDataCard.tsx
    MarketDataGrid.tsx
  market-status-header/
    charts-and-news.tsx
    index.tsx
    live-ticker-wrapper.tsx
    market-overview.tsx
    news-panel.tsx
    right-sidebar.tsx
    ticker-config-dialog.tsx
    top-bar.tsx
  news/
    NewsCard.tsx
  portfolio-analytics/
    ai-recommendations.tsx
    benchmark-comparison.tsx
    benchmarking.tsx
    esg-scorecard.tsx
    performance-analysis.tsx
    performance-monitor.tsx
    portfolio-analytics-dashboard.tsx
    portfolio-overview.tsx
    risk-analysis.tsx
    tax-optimization.tsx
  portfolio-optimizer/
    correlation-matrix.tsx
    performance-metrics.tsx
    portfolio-allocation.tsx
    portfolio-optimizer-dashboard.tsx
    trade-suggestions.tsx
  search/
    SearchBar.tsx
  technical/
    TechnicalChart.tsx
  technical-analysis/
    brokerage-integration.tsx
    chart-patterns.tsx
    fibonacci-retracement.tsx
    market-sentiment-overlay.tsx
    trade-signal-generator.tsx
    trendline-overlay.tsx
  trading-journal/
    behavior-analysis.tsx
    performance-review.tsx
    realtime-feedback.tsx
    trade-log.tsx
    trading-journal-dashboard.tsx
  ui/
    accordion.tsx
    alert-dialog.tsx
    alert.tsx
    aspect-ratio.tsx
    avatar.tsx
    badge.tsx
    breadcrumb.tsx
    button.tsx
    calendar.tsx
    card.tsx
    carousel.tsx
    chart.tsx
    checkbox.tsx
    collapsible.tsx
    command.tsx
    context-menu.tsx
    date-picker-with-range.tsx
    date-range-picker.tsx
    dialog.tsx
    drawer.tsx
    dropdown-menu.tsx
    form.tsx
    hover-card.tsx
    input-otp.tsx
    input.tsx
    label.tsx
    logo.tsx
    menubar.tsx
    navigation-menu.tsx
    pagination.tsx
    popover.tsx
    progress.tsx
    radio-group.tsx
    resizable.tsx
    scroll-area.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    switch.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    toast.tsx
    toaster.tsx
    toggle-group.tsx
    toggle.tsx
    tooltip.tsx
    use-mobile.tsx
    use-toast.ts
    widget-skeleton.tsx
  valuation/
    analyst-estimates.tsx
    company-health-metrics.tsx
    dcf-analysis.tsx
    monte-carlo.tsx
    relative-valuation.tsx
    sensitivity-analysis.tsx
    stock-selector.tsx
  advanced-charts.tsx
  ai-insights.tsx
  bond-screener.tsx
  c-suite-overview.tsx
  context-aware-chart.tsx
  crypto-heatmap.tsx
  crypto-screener.tsx
  dashboard-layout.tsx
  Dashboard.tsx
  draggable-grid.tsx
  economic-calendar.tsx
  economics-earnings-calendar.tsx
  error-boundary.tsx
  error-message.tsx
  esg-scorecard.tsx
  etf-heatmap.tsx
  etf-screener.tsx
  generative-chat.tsx
  generative-market-updates.tsx
  generative-news-panel.tsx
  generative-news-updates.tsx
  generative-trading-ideas.tsx
  guided-tour.tsx
  intrinsic-value-card.tsx
  intrinsic-value-dashboard.tsx
  live-market-data.tsx
  live-ticker-bar.tsx
  LiveStockNews.tsx
  market-breadth.tsx
  market-overview-chart.tsx
  market-overview.tsx
  market-status-header.tsx
  news-room.tsx
  option-chain.tsx
  order-book-visualization.tsx
  order-book.tsx
  ownership-structure.tsx
  peter-lynch-valuation.tsx
  polygon-ticker-wall.tsx
  porters-five-forces.tsx
  portfolio-allocation.tsx
  portfolio-overview.tsx
  portfolio-performance.tsx
  portfolio-transactions.tsx
  quick-summary.tsx
  responsive-layout.tsx
  sankey-diagram.tsx
  sector-performance.tsx
  settings-panel.tsx
  sidebar.tsx
  smart-money-flow.tsx
  stock-heatmap.tsx
  stock-screener.tsx
  StockNewsItem.tsx
  support-resistance-levels.tsx
  technical-analysis.tsx
  theme-provider.tsx
  trading-history.tsx
  trading-interface.tsx
  trading-volume.tsx
  trending-topics.tsx
  universal-clock.tsx
  watchlist-alerts.tsx
  watchlist-table.tsx
  weather-display.tsx
hooks/
  use-media-query.ts
  use-mobile.tsx
  use-toast.ts
lib/
  api/
    ai-researcher.ts
    api-client.ts
    asset-screener.ts
    asset-search.ts
    backtesting.ts
    brokerage.ts
    due-diligence.ts
    economic-calendar.ts
    economic-events.ts
    financial-heatmap.ts
    mock-data.ts
    polygon-client.ts
    polygon-service.ts
    polygon-websocket.ts
    portfolio-analytics.ts
    portfolio-optimizer.ts
    stock-data.ts
    technical-analysis.ts
    trading-journal.ts
  contexts/
    market-context.tsx
  hooks/
    use-batch-stock-data.ts
    use-company-info.ts
    use-debounce.ts
    use-market-data.ts
    use-market-hours.ts
    use-market-indices.ts
    use-news.ts
    use-search.ts
    use-stock-aggregates.ts
    use-stock-data.ts
    use-stock-websocket.ts
    use-swr-market-data.ts
    use-technical-indicators.ts
    use-user-preferences.ts
  middleware/
    auth-middleware.ts
    auth.ts
    error-handler.ts
    rate-limit.ts
  services/
    analytics-service.ts
    auth-service.ts
    dashboard-service.ts
    data-transform-service.ts
    data-validation-service.ts
    market-data-service.ts
    rate-limiter.ts
    rbac-service.ts
    visualization-service.ts
    websocket-service.ts
  tools/
    stock-news.ts
    weather.ts
  types/
    grid-layout.d.ts
    market-data.ts
  utils/
    cache-manager.ts
    data-validator.ts
    jwt.ts
    logger.ts
    metrics.ts
    rate-limiter.ts
    request-validator.ts
    response-formatter.ts
    technical-analysis.ts
  app-state-context.tsx
  db.ts
  fetcher.ts
  utils.ts
  websocket-client.ts
  websocket.ts
local-docs/
prisma/
  schema.prisma
public/
  placeholder-logo.svg
  placeholder.svg
screenshots/
  Users/
    stelios/
      trading-dashboard-2/
        screenshots/
styles/
  globals.css
  ticker.css
tests/
  components/
    Dashboard.test.tsx
  services/
    analytics-service.test.ts
    dashboard-service.test.ts
    visualization-service.test.ts
  jest.setup.ts
  setup.ts
types/
  ai-researcher.ts
  asset-screener.ts
  asset.ts
  backtesting.ts
  due-diligence.ts
  economic-events.ts
  market.ts
  polygon.ts
  portfolio-analytics.ts
  portfolio-optimizer.ts
  stock.ts
  technical-analysis.ts
  trading-journal.ts
.cursorrules
.gitignore
AI_AGENT_PROMPT.md
API_Architecture.md
CODEBASE_GUIDE.md
components.json
docker-compose.yml
Dockerfile
Integration_Guide.md
jest.config.ts
LICENSE
MODIFICATION_PATTERNS.md
next.config.js
next.config.mjs
package.json
POLYGON_INTEGRATION.md
polygonStock.md
polygonStock2.md
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
tsconfig.test.json
vercel.json
vercel.prod.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/ai-researcher/page.tsx">
import { AIResearcherDashboard } from "@/components/ai-researcher/dashboard"
export default function AIResearcherPage() {
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">AI Market Researcher</h1>
      <AIResearcherDashboard />
    </div>
  )
}
</file>

<file path="app/api/chat/route.ts">
import { Configuration, OpenAIApi } from "openai-edge"
import { tools } from "@/lib/tools/weather"
const config = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
})
const openai = new OpenAIApi(config)
export async function POST(req: Request) {
  const { messages } = await req.json()
  const response = await openai.createChatCompletion({
    model: "gpt-3.5-turbo",
    stream: true,
    messages: [
      {
        role: "system",
        content:
          "You are a helpful assistant that can provide weather information. Use the getWeather tool when users ask about weather.",
      },
      ...messages,
    ],
    functions: [{
      name: "getWeather",
      description: "Get the weather for a specific location",
      parameters: {
        type: "object",
        properties: {
          location: {
            type: "string",
            description: "The location to get weather for"
          }
        },
        required: ["location"]
      }
    }],
    function_call: "auto",
  })
  return new Response(response.body, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  })
}
</file>

<file path="app/api/company/route.ts">
import { NextRequest } from 'next/server';
import { polygonService } from '@/lib/api/polygon-service';
import { authMiddleware } from '@/lib/middleware/auth';
import { rateLimitMiddleware } from '@/lib/middleware/rate-limit';
import { errorHandler } from '@/lib/middleware/error-handler';
import { validateQueryParams } from '@/lib/utils/request-validator';
import { SymbolParamSchema } from '@/lib/utils/request-validator';
import { formatResponse } from '@/lib/utils/response-formatter';
export async function GET(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate query parameters
    const query = validateQueryParams(req.nextUrl.searchParams, SymbolParamSchema);
    // Get company details from service
    const companyData = await polygonService.getTickerDetails(query.symbol);
    // Format response
    return formatResponse(companyData, {
      source: 'polygon',
      cached: true,
    });
  } catch (error) {
    return errorHandler(error, req);
  }
}
// Batch endpoint for multiple companies
export async function POST(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate request body
    const body = await req.json();
    const { symbols } = body as { symbols: string[] };
    if (!Array.isArray(symbols) || symbols.length === 0) {
      throw new Error('Invalid symbols array');
    }
    // Get company details for all symbols
    const companyDataPromises = symbols.map(symbol =>
      polygonService.getTickerDetails(symbol)
    );
    const companyData = await Promise.all(companyDataPromises);
    // Format response
    return formatResponse(
      companyData.reduce((acc, data, index) => {
        acc[symbols[index]] = data;
        return acc;
      }, {} as Record<string, unknown>),
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
</file>

<file path="app/api/generate/route.ts">
import { Configuration, OpenAIApi } from 'openai-edge'
// Create an OpenAI API client (that's edge friendly!)
const config = new Configuration({
  apiKey: process.env.OPENAI_API_KEY
})
const openai = new OpenAIApi(config)
// Set the runtime to edge for best performance
export const runtime = 'edge'
export async function POST(req: Request) {
  const { prompt } = await req.json()
  // Ask OpenAI for a completion given the prompt
  const response = await openai.createChatCompletion({
    model: 'gpt-3.5-turbo',
    messages: [
      {
        role: 'system',
        content: `You are a helpful assistant that generates chart data. Always respond with valid JSON in the following format:
        {
          "title": "Chart Title",
          "description": "Chart Description",
          "data": [
            {
              "date": "2024-01-01",
              "value1": number,
              "value2": number,
              ...
            }
          ]
        }`
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.7,
    max_tokens: 800
  })
  // Get the response data
  const data = await response.json()
  // Return the completion
  return new Response(JSON.stringify(data.choices[0].message.content), {
    headers: { 'Content-Type': 'application/json' }
  })
}
</file>

<file path="app/api/generate-insights/route.ts">
import OpenAI from "openai"
import { NextResponse } from "next/server"
export const runtime = "edge"
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
export async function POST(req: Request) {
  try {
    const { prompt } = await req.json()
    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      stream: true,
      messages: [
        {
          role: "system",
          content:
            "You are a financial market expert providing AI-generated insights based on market data and trends. Focus on actionable insights and clear explanations.",
        },
        {
          role: "user",
          content: prompt,
        },
      ],
    })
    // Convert the response into a friendly text-stream
    const stream = new ReadableStream({
      async start(controller) {
        for await (const chunk of response) {
          const text = chunk.choices[0]?.delta?.content || ""
          if (text) {
            const queue = new TextEncoder().encode(text)
            controller.enqueue(queue)
          }
        }
        controller.close()
      },
    })
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    })
  } catch (error) {
    console.error("Insight generation error:", error)
    return NextResponse.json({ error: "Failed to generate insights" }, { status: 500 })
  }
}
</file>

<file path="app/api/generate-news/route.ts">
import OpenAI from "openai"
export const runtime = "edge"
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
export async function POST(req: Request) {
  const { prompt } = await req.json()
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    stream: true,
    messages: [
      {
        role: "system",
        content:
          "You are a financial news analyst providing brief, real-time market updates. Keep your responses concise and focused on current market events.",
      },
      {
        role: "user",
        content: prompt,
      },
    ],
  })
  // Convert the response into a friendly text-stream
  const stream = new ReadableStream({
    async start(controller) {
      for await (const chunk of response) {
        const text = chunk.choices[0]?.delta?.content || ""
        if (text) {
          const queue = new TextEncoder().encode(text)
          controller.enqueue(queue)
        }
      }
      controller.close()
    },
  })
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  })
}
</file>

<file path="app/api/generate-trades/route.ts">
import OpenAI from "openai"
export const runtime = "edge"
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
export async function POST(req: Request) {
  const { prompt } = await req.json()
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    stream: true,
    messages: [
      {
        role: "system",
        content: "You are an AI trading assistant that generates trade suggestions based on market analysis.",
      },
      {
        role: "user",
        content: prompt,
      },
    ],
    max_tokens: 500,
    temperature: 0.7,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
  })
  // Convert the response into a friendly text-stream
  const stream = new ReadableStream({
    async start(controller) {
      for await (const chunk of response) {
        const text = chunk.choices[0]?.delta?.content || ""
        if (text) {
          const queue = new TextEncoder().encode(text)
          controller.enqueue(queue)
        }
      }
      controller.close()
    },
  })
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  })
}
</file>

<file path="app/api/generate-visualization/route.ts">
import OpenAI from "openai"
import { NextResponse } from "next/server"
export const runtime = "edge"
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
export async function POST(req: Request) {
  try {
    const { prompt } = await req.json()
    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      stream: true,
      messages: [
        {
          role: "system",
          content:
            "You are a data visualization expert that generates chart configurations based on user requests. Focus on creating clear, insightful visualizations that effectively communicate data patterns.",
        },
        {
          role: "user",
          content: prompt,
        },
      ],
    })
    // Convert the response into a friendly text-stream
    const stream = new ReadableStream({
      async start(controller) {
        for await (const chunk of response) {
          const text = chunk.choices[0]?.delta?.content || ""
          if (text) {
            const queue = new TextEncoder().encode(text)
            controller.enqueue(queue)
          }
        }
        controller.close()
      },
    })
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    })
  } catch (error) {
    console.error("Visualization generation error:", error)
    return NextResponse.json({ error: "Failed to generate visualization" }, { status: 500 })
  }
}
</file>

<file path="app/api/health/route.ts">
import { NextResponse } from 'next/server';
import { cacheManager } from '@/lib/utils/cache-manager';
import { metrics } from '@/lib/utils/metrics';
import { logger } from '@/lib/utils/logger';
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: number;
  version: string;
  services: {
    redis: {
      status: 'healthy' | 'degraded' | 'unhealthy';
      latency: number;
    };
    api: {
      status: 'healthy' | 'degraded' | 'unhealthy';
      uptime: number;
    };
  };
  metrics: {
    requests: number;
    errors: number;
    latency: number;
  };
}
export async function GET() {
  const startTime = Date.now();
  const status: HealthStatus = {
    status: 'healthy',
    timestamp: Date.now(),
    version: process.env.npm_package_version || '1.0.0',
    services: {
      redis: {
        status: 'healthy',
        latency: 0,
      },
      api: {
        status: 'healthy',
        uptime: process.uptime(),
      },
    },
    metrics: {
      requests: 0,
      errors: 0,
      latency: 0,
    },
  };
  try {
    // Check Redis connection
    const redisStart = Date.now();
    const redisHealth = await cacheManager.healthCheck();
    status.services.redis.latency = Date.now() - redisStart;
    if (!redisHealth) {
      status.services.redis.status = 'unhealthy';
      status.status = 'degraded';
    }
    // Get metrics
    const metricsData = await metrics.getAll();
    status.metrics = {
      requests: Object.values(metricsData).reduce((sum, metric) => {
        if (metric.type === 'counter' && metric.name.includes('request')) {
          return sum + metric.value;
        }
        return sum;
      }, 0),
      errors: Object.values(metricsData).reduce((sum, metric) => {
        if (metric.type === 'counter' && metric.name.includes('error')) {
          return sum + metric.value;
        }
        return sum;
      }, 0),
      latency: Object.values(metricsData).reduce((sum, metric) => {
        if (metric.type === 'histogram' && metric.name.includes('duration')) {
          return sum + metric.value;
        }
        return sum;
      }, 0),
    };
    // Calculate overall status
    if (status.services.redis.status === 'unhealthy') {
      status.status = 'unhealthy';
    } else if (status.services.redis.status === 'degraded') {
      status.status = 'degraded';
    }
    // Log health check
    logger.info('Health check completed', {
      status: status.status,
      duration: Date.now() - startTime,
    });
    // Return appropriate status code
    const statusCode = status.status === 'healthy' ? 200 : 
                      status.status === 'degraded' ? 200 : 503;
    return NextResponse.json(status, { status: statusCode });
  } catch (error) {
    logger.error('Health check failed:', error);
    status.status = 'unhealthy';
    status.services.api.status = 'unhealthy';
    return NextResponse.json(status, { status: 503 });
  }
}
</file>

<file path="app/api/market-chat/route.ts">
import { NextResponse } from "next/server"
import OpenAI from "openai"
export const runtime = "edge"
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
// Centralized market news generation
export async function POST(req: Request) {
  try {
    const { messages } = await req.json()
    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      stream: true,
      messages: [
        {
          role: "system",
          content:
            "You are a financial market expert providing real-time market analysis and insights. Focus on providing actionable insights and clear market explanations.",
        },
        ...messages,
      ],
    })
    // Convert the response into a friendly text-stream
    const stream = new ReadableStream({
      async start(controller) {
        for await (const chunk of response) {
          const text = chunk.choices[0]?.delta?.content || ""
          if (text) {
            const queue = new TextEncoder().encode(text)
            controller.enqueue(queue)
          }
        }
        controller.close()
      },
    })
    return new Response(stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    })
  } catch (error) {
    console.error("Market chat error:", error)
    return NextResponse.json({ error: "Failed to generate market updates" }, { status: 500 })
  }
}
</file>

<file path="app/api/market-data/route.ts">
import { NextRequest } from 'next/server';
import { polygonService } from '@/lib/api/polygon-service';
import { authMiddleware } from '@/lib/middleware/auth';
import { rateLimitMiddleware } from '@/lib/middleware/rate-limit';
import { errorHandler } from '@/lib/middleware/error-handler';
import { validateQueryParams } from '@/lib/utils/request-validator';
import { MarketDataRequestSchema } from '@/lib/utils/request-validator';
import { formatPaginatedResponse } from '@/lib/utils/response-formatter';
export async function GET(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate query parameters
    const query = validateQueryParams(req.nextUrl.searchParams, MarketDataRequestSchema);
    // Get market data from service
    const marketData = await polygonService.getSnapshots(query.symbols);
    // Calculate pagination
    const total = marketData.tickers.length;
    const page = query.page || 1;
    const limit = query.limit || 10;
    const start = (page - 1) * limit;
    const end = start + limit;
    // Paginate results
    const paginatedData = marketData.tickers.slice(start, end);
    // Format response
    return formatPaginatedResponse(
      paginatedData,
      {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
export async function POST(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate request body
    const body = await req.json();
    const validatedData = MarketDataRequestSchema.parse(body);
    // Get market data from service
    const marketData = await polygonService.getSnapshots(validatedData.symbols);
    // Calculate pagination if requested
    if (validatedData.page && validatedData.limit) {
      const total = marketData.tickers.length;
      const start = (validatedData.page - 1) * validatedData.limit;
      const end = start + validatedData.limit;
      // Paginate results
      const paginatedData = marketData.tickers.slice(start, end);
      return formatPaginatedResponse(
        paginatedData,
        {
          page: validatedData.page,
          limit: validatedData.limit,
          total,
          totalPages: Math.ceil(total / validatedData.limit),
        },
        {
          source: 'polygon',
          cached: true,
        }
      );
    }
    // Return all results if no pagination requested
    return formatPaginatedResponse(
      marketData.tickers,
      {
        page: 1,
        limit: marketData.tickers.length,
        total: marketData.tickers.length,
        totalPages: 1,
      },
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
</file>

<file path="app/api/market-updates/route.ts">
import { Configuration, OpenAIApi } from "openai-edge"
import { NextResponse } from "next/server"
const config = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
})
const openai = new OpenAIApi(config)
export async function POST(req: Request) {
  try {
    const { messages } = await req.json()
    const response = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      stream: true,
      messages: [
        {
          role: "system",
          content:
            "You are a market analysis assistant that provides insights about market movements and trends.",
        },
        ...messages,
      ],
    })
    return new Response(response.body, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    })
  } catch (error) {
    console.error("Market updates error:", error)
    return NextResponse.json({ error: "Failed to generate market updates" }, { status: 500 })
  }
}
</file>

<file path="app/api/news/route.ts">
import { NextRequest } from 'next/server';
import { polygonService } from '@/lib/api/polygon-service';
import { authMiddleware } from '@/lib/middleware/auth';
import { rateLimitMiddleware } from '@/lib/middleware/rate-limit';
import { errorHandler } from '@/lib/middleware/error-handler';
import { validateQueryParams } from '@/lib/utils/request-validator';
import { NewsRequestSchema } from '@/lib/utils/request-validator';
import { formatPaginatedResponse } from '@/lib/utils/response-formatter';
export async function GET(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate query parameters
    const query = validateQueryParams(req.nextUrl.searchParams, NewsRequestSchema);
    // Get news from service
    const newsData = await polygonService.getMarketNews(
      query.symbols?.join(','),
      query.limit
    );
    // Format response with pagination
    return formatPaginatedResponse(
      newsData,
      {
        page: query.page || 1,
        limit: query.limit || 10,
        total: newsData.length,
        totalPages: Math.ceil(newsData.length / (query.limit || 10)),
      },
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
// Streaming endpoint for real-time news updates
export async function POST(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate request body
    const body = await req.json();
    const validatedData = NewsRequestSchema.parse(body);
    // Create a readable stream for news updates
    const stream = new ReadableStream({
      async start(controller) {
        try {
          // Initial news fetch
          const initialNews = await polygonService.getMarketNews(
            validatedData.symbols?.join(','),
            validatedData.limit
          );
          // Send initial batch
          controller.enqueue(
            `data: ${JSON.stringify({
              type: 'initial',
              data: initialNews,
            })}\n\n`
          );
          // Set up polling for updates
          const pollInterval = setInterval(async () => {
            try {
              const latestNews = await polygonService.getMarketNews(
                validatedData.symbols?.join(','),
                validatedData.limit
              );
              // Filter out news we've already sent
              const newItems = latestNews.filter(
                item => !initialNews.some(existing => existing.id === item.id)
              );
              if (newItems.length > 0) {
                controller.enqueue(
                  `data: ${JSON.stringify({
                    type: 'update',
                    data: newItems,
                  })}\n\n`
                );
              }
            } catch (error) {
              console.error('News polling error:', error);
              controller.error(error);
            }
          }, 60000); // Poll every minute
          // Clean up on close
          return () => {
            clearInterval(pollInterval);
          };
        } catch (error) {
          controller.error(error);
        }
      },
    });
    // Return streaming response
    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    return errorHandler(error, req);
  }
}
</file>

<file path="app/api/polygon/aggregates/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { PolygonService } from '@/lib/api/polygon-service'
import { z } from 'zod'
// Request validation schema
const RequestSchema = z.object({
  ticker: z.string().min(1).max(10),
  multiplier: z.coerce.number().int().positive(),
  timespan: z.enum(['minute', 'hour', 'day', 'week', 'month', 'quarter', 'year']),
  from: z.coerce.date(),
  to: z.coerce.date(),
  adjusted: z.coerce.boolean().optional(),
})
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const params = {
      ticker: searchParams.get('ticker'),
      multiplier: searchParams.get('multiplier'),
      timespan: searchParams.get('timespan'),
      from: searchParams.get('from'),
      to: searchParams.get('to'),
      adjusted: searchParams.get('adjusted'),
    }
    // Validate and parse request parameters
    const validatedParams = RequestSchema.parse({
      ...params,
      adjusted: params.adjusted === 'true',
    })
    const polygonService = new PolygonService()
    const range = PolygonService.formatDateRange(validatedParams.from, validatedParams.to)
    const data = await polygonService.getAggregates(
      validatedParams.ticker,
      validatedParams.multiplier,
      validatedParams.timespan,
      range.from.toISOString().split('T')[0],
      range.to.toISOString().split('T')[0],
      validatedParams.adjusted
    )
    return NextResponse.json(data)
  } catch (error) {
    console.error('Error fetching aggregates:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request parameters', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Failed to fetch aggregates data' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/polygon-news/route.ts">
import { NextResponse } from "next/server"
export async function GET() {
  const apiKey = process.env.POLYGON_API_KEY
  if (!apiKey) {
    return NextResponse.json({ error: "Polygon API key not set" }, { status: 500 })
  }
  const url = `https://api.polygon.io/v2/reference/news?limit=1&apiKey=${apiKey}`
  try {
    const response = await fetch(url)
    if (!response.ok) {
      return NextResponse.json({ error: "Error fetching news" }, { status: response.status })
    }
    const data = await response.json()
    const newsArticle = data.results?.[0] || null
    if (!newsArticle) {
      return NextResponse.json({ error: "No news found" }, { status: 404 })
    }
    return NextResponse.json({
      id: newsArticle.id || newsArticle.published_utc,
      headline: newsArticle.title,
      summary: newsArticle.article_url ? newsArticle.article_url : newsArticle.description,
      source: newsArticle.source,
      publishedUtc: newsArticle.published_utc,
    })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
</file>

<file path="app/api/polygon-stocks/batch/route.ts">
import { NextResponse } from 'next/server'
import { polygonService } from '@/lib/api/polygon-service'
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const symbols = searchParams.get('symbols')
    if (!symbols) {
      return NextResponse.json({ error: 'No symbols provided' }, { status: 400 })
    }
    const tickers = symbols.split(',').map(s => s.trim()).filter(Boolean)
    if (tickers.length === 0) {
      return NextResponse.json({ error: 'Invalid symbols format' }, { status: 400 })
    }
    if (tickers.length > 50) {
      return NextResponse.json({ error: 'Too many symbols. Maximum is 50.' }, { status: 400 })
    }
    const response = await polygonService.getSnapshots(tickers)
    if (response.status === 'error' || !response.tickers) {
      throw new Error('Failed to fetch stock data from Polygon')
    }
    // Transform the response into a more convenient format
    const transformedData = response.tickers.reduce((acc, ticker) => {
      if (ticker.lastTrade && ticker.day) {
        acc[ticker.ticker] = {
          symbol: ticker.ticker,
          price: ticker.lastTrade.p,
          change: ticker.todaysChange || 0,
          changePercent: ticker.todaysChangePerc || 0,
          volume: ticker.day.v,
          lastUpdated: ticker.updated
        }
      }
      return acc
    }, {} as Record<string, any>)
    return NextResponse.json(transformedData)
  } catch (error) {
    console.error('Error in polygon-stocks/batch:', error)
    return NextResponse.json(
      { error: 'Failed to fetch stock data' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/polygon-stocks/market/sectors/route.ts">
import { NextRequest, NextResponse } from "next/server"
// Sector ETFs mapping
const SECTOR_ETFS = {
  "XLK": "Technology",
  "XLF": "Financials",
  "XLV": "Healthcare",
  "XLE": "Energy",
  "XLI": "Industrials",
  "XLP": "Consumer Staples",
  "XLY": "Consumer Discretionary",
  "XLB": "Materials",
  "XLU": "Utilities",
  "XLRE": "Real Estate",
  "XLC": "Communication Services"
}
// Rate limiting setup
const RATE_LIMIT_DURATION = 60000 // 1 minute
const MAX_REQUESTS = 3
const requestLog = new Map<string, { count: number; timestamp: number }>()
function isRateLimited(ip: string): boolean {
  const now = Date.now()
  const userRequests = requestLog.get(ip)
  if (!userRequests) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (now - userRequests.timestamp > RATE_LIMIT_DURATION) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (userRequests.count >= MAX_REQUESTS) {
    return true
  }
  userRequests.count++
  return false
}
export async function GET(request: NextRequest) {
  try {
    const apiKey = process.env.POLYGON_API_KEY
    if (!apiKey) {
      throw new Error("Polygon API key not set")
    }
    // Rate limiting
    const ip = request.headers.get("x-forwarded-for") || "unknown"
    if (isRateLimited(ip)) {
      return NextResponse.json(
        { error: "Rate limit exceeded. Please try again later." },
        { status: 429 }
      )
    }
    // Get all sector ETFs data in parallel
    const sectorTickers = Object.keys(SECTOR_ETFS)
    const snapshotUrl = `https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/tickers?tickers=${sectorTickers.join(",")}&apiKey=${apiKey}`
    const response = await fetch(snapshotUrl)
    if (!response.ok) {
      throw new Error(`Failed to fetch sector data: ${response.statusText}`)
    }
    const data = await response.json()
    // Transform the data into sector performance metrics
    const sectorPerformance = data.tickers?.map((ticker: any) => {
      const symbol = ticker.ticker
      const sectorName = SECTOR_ETFS[symbol as keyof typeof SECTOR_ETFS]
      return {
        sector: sectorName,
        symbol: symbol,
        price: ticker.lastTrade?.p || null,
        change: ticker.todaysChange || null,
        changePercent: ticker.todaysChangePerc || null,
        volume: ticker.day?.v || null,
        previousClose: ticker.prevDay?.c || null,
        updated: ticker.updated,
        marketCap: ticker.day?.vw ? (ticker.day.vw * (ticker.day.v || 0)) : null
      }
    }).sort((a: any, b: any) => (b.changePercent || 0) - (a.changePercent || 0)) // Sort by performance
    // Add market breadth metrics
    const gainers = sectorPerformance.filter((sector: any) => sector.changePercent > 0)
    const losers = sectorPerformance.filter((sector: any) => sector.changePercent < 0)
    const marketBreadth = {
      advancing: gainers.length,
      declining: losers.length,
      unchanged: sectorPerformance.length - gainers.length - losers.length,
      totalSectors: sectorPerformance.length,
      averagePerformance: sectorPerformance.reduce((acc: number, sector: any) => 
        acc + (sector.changePercent || 0), 0) / sectorPerformance.length
    }
    return NextResponse.json({
      sectors: sectorPerformance,
      marketBreadth,
      timestamp: new Date().toISOString(),
      status: "success"
    })
  } catch (error: any) {
    console.error(`Error fetching sector data: ${error.message}`)
    return NextResponse.json(
      {
        error: error.message || "Failed to fetch sector data",
        status: "error",
        timestamp: new Date().toISOString()
      },
      { status: error.status || 500 }
    )
  }
}
</file>

<file path="app/api/polygon-stocks/market/route.ts">
import { NextRequest, NextResponse } from "next/server"
// Constants
const RATE_LIMIT_DURATION = 60000 // 1 minute
const MAX_REQUESTS = 5
const requestLog = new Map<string, { count: number; timestamp: number }>()
// Major indices to track
const INDICES = ["SPY", "QQQ", "DIA", "IWM"]
// Sector ETFs mapping
const SECTOR_ETFS = {
  "XLK": "Technology",
  "XLF": "Financials",
  "XLV": "Healthcare",
  "XLE": "Energy",
  "XLI": "Industrials",
  "XLP": "Consumer Staples",
  "XLY": "Consumer Discretionary",
  "XLB": "Materials",
  "XLU": "Utilities",
  "XLRE": "Real Estate",
  "XLC": "Communication Services"
}
// Types
interface MarketIndex {
  symbol: string
  name: string
  price: number | null
  change: number | null
  changePercent: number | null
  volume: number | null
}
interface SectorPerformance {
  sector: string
  symbol: string
  price: number | null
  change: number | null
  changePercent: number | null
  volume: number | null
  previousClose: number | null
  updated: number | null
  marketCap: number | null
}
interface StockResult {
  symbol: string
  price: number | null
  change: number | null
  changePercent: number | null
  volume: number | null
}
interface MarketBreadth {
  advancing: number
  declining: number
  unchanged: number
  totalSectors: number
  averagePerformance: number
}
interface MarketData {
  indices: MarketIndex[]
  topGainers: StockResult[]
  topLosers: StockResult[]
  mostActive: StockResult[]
  sectors: SectorPerformance[]
  marketBreadth: MarketBreadth
  timestamp: string
}
interface AggregateResult {
  T: string // Ticker
  c: number // Close price
  h: number // High price
  l: number // Low price
  n: number // Number of transactions
  o: number // Open price
  t: number // Timestamp
  v: number // Volume
  vw: number // Volume weighted average price
}
// Rate limit helper
function isRateLimited(ip: string): boolean {
  const now = Date.now()
  const userRequests = requestLog.get(ip)
  if (!userRequests) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (now - userRequests.timestamp > RATE_LIMIT_DURATION) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (userRequests.count >= MAX_REQUESTS) {
    return true
  }
  userRequests.count++
  return false
}
export async function GET(request: NextRequest) {
  try {
    const apiKey = process.env.POLYGON_API_KEY
    if (!apiKey) {
      throw new Error("Polygon API key not set")
    }
    // Rate limiting
    const ip = request.headers.get("x-forwarded-for") || "unknown"
    if (isRateLimited(ip)) {
      return NextResponse.json(
        { error: "Rate limit exceeded. Please try again later." },
        { status: 429 }
      )
    }
    // Get today's date in YYYY-MM-DD format
    const today = new Date().toISOString().split('T')[0]
    // Construct URLs for parallel requests
    const urls = {
      allStocks: `https://api.polygon.io/v2/aggs/grouped/locale/us/market/stocks/${today}?adjusted=true&apiKey=${apiKey}`,
      details: `https://api.polygon.io/v3/reference/tickers?type=CS&market=stocks&active=true&sort=market_cap&order=desc&limit=1000&apiKey=${apiKey}`
    }
    // Make parallel requests
    const [stocksResponse, detailsResponse] = await Promise.all([
      fetch(urls.allStocks),
      fetch(urls.details)
    ])
    // Check responses
    if (!stocksResponse.ok || !detailsResponse.ok) {
      throw new Error("Failed to fetch market data")
    }
    // Parse responses
    const [stocksData, detailsData] = await Promise.all([
      stocksResponse.json(),
      detailsResponse.json()
    ])
    // Create maps for quick lookups
    const stocksMap = new Map<string, AggregateResult>(
      stocksData.results?.map((result: AggregateResult) => [result.T, result]) || []
    )
    const detailsMap = new Map(
      detailsData.results?.map((result: any) => [result.ticker, result]) || []
    )
    // Transform indices data
    const indices: MarketIndex[] = INDICES.map(symbol => {
      const stockData = stocksMap.get(symbol)
      if (!stockData) return {
        symbol,
        name: getIndexName(symbol),
        price: null,
        change: null,
        changePercent: null,
        volume: null
      }
      const priceChange = stockData.c - stockData.o
      const changePercent = (priceChange / stockData.o) * 100
      return {
        symbol,
        name: getIndexName(symbol),
        price: stockData.c,
        change: Number(priceChange.toFixed(2)),
        changePercent: Number(changePercent.toFixed(2)),
        volume: stockData.v
      }
    })
    // Transform all stocks for gainers/losers/active lists
    const allStocks = stocksData.results?.map((stock: AggregateResult) => {
      const priceChange = stock.c - stock.o
      const changePercent = (priceChange / stock.o) * 100
      return {
        symbol: stock.T,
        price: stock.c,
        change: Number(priceChange.toFixed(2)),
        changePercent: Number(changePercent.toFixed(2)),
        volume: stock.v
      }
    }) || []
    // Sort for different lists
    const topGainers = [...allStocks]
      .sort((a, b) => (b.changePercent || 0) - (a.changePercent || 0))
      .slice(0, 5)
    const topLosers = [...allStocks]
      .sort((a, b) => (a.changePercent || 0) - (b.changePercent || 0))
      .slice(0, 5)
    const mostActive = [...allStocks]
      .sort((a, b) => (b.volume || 0) - (a.volume || 0))
      .slice(0, 5)
    // Transform sector data
    const sectors: SectorPerformance[] = Object.entries(SECTOR_ETFS).map(([symbol, sector]) => {
      const stockData = stocksMap.get(symbol)
      if (!stockData) return {
        sector,
        symbol,
        price: null,
        change: null,
        changePercent: null,
        volume: null,
        previousClose: null,
        updated: null,
        marketCap: null
      }
      const priceChange = stockData.c - stockData.o
      const changePercent = (priceChange / stockData.o) * 100
      return {
        sector,
        symbol,
        price: stockData.c,
        change: Number(priceChange.toFixed(2)),
        changePercent: Number(changePercent.toFixed(2)),
        volume: stockData.v,
        previousClose: stockData.o,
        updated: stockData.t,
        marketCap: stockData.vw * stockData.v
      }
    }).sort((a, b) => (b.changePercent || 0) - (a.changePercent || 0))
    // Calculate market breadth
    const gainingSectors = sectors.filter(sector => (sector.changePercent || 0) > 0)
    const losingSectors = sectors.filter(sector => (sector.changePercent || 0) < 0)
    const marketBreadth: MarketBreadth = {
      advancing: gainingSectors.length,
      declining: losingSectors.length,
      unchanged: sectors.length - gainingSectors.length - losingSectors.length,
      totalSectors: sectors.length,
      averagePerformance: sectors.reduce((acc, sector) => acc + (sector.changePercent || 0), 0) / sectors.length
    }
    // Construct response
    const marketData: MarketData = {
      indices,
      topGainers,
      topLosers,
      mostActive,
      sectors,
      marketBreadth,
      timestamp: new Date().toISOString()
    }
    return NextResponse.json(marketData)
  } catch (error: any) {
    console.error(`Error fetching market data: ${error.message}`)
    return NextResponse.json(
      {
        error: error.message || "Failed to fetch market data",
        status: "error",
        timestamp: new Date().toISOString()
      },
      { status: error.status || 500 }
    )
  }
}
function getIndexName(symbol: string): string {
  const indexNames: { [key: string]: string } = {
    "SPY": "S&P 500",
    "QQQ": "NASDAQ 100",
    "DIA": "Dow Jones Industrial Average",
    "IWM": "Russell 2000"
  }
  return indexNames[symbol] || symbol
}
</file>

<file path="app/api/polygon-stocks/test/route.ts">
import { NextResponse } from "next/server"
import { polygonService } from "@/lib/api/polygon-service"
export async function GET() {
  try {
    // Try a simple API call to verify the key works
    const response = await polygonService.getAggregates(
      'AAPL',
      1,
      'day',
      new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      new Date().toISOString().split('T')[0]
    )
    if (!response.results || response.results.length === 0) {
      throw new Error('No data returned from Polygon API')
    }
    return NextResponse.json({
      status: "success",
      message: "Polygon.io API key is working",
      data: response.results[0]
    })
  } catch (error: any) {
    console.error(`Test failed: ${error.message}`)
    return NextResponse.json(
      {
        status: "error",
        message: error.message || "Failed to verify API key"
      },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/polygon-stocks/websocket/route.ts">
import { NextRequest, NextResponse } from "next/server"
// WebSocket connection details
const WS_AUTH_URL = "https://api.polygon.io/v3/reference/ws-auth"
const WS_STOCKS_URL = "wss://delayed.polygon.io/stocks"
export async function GET(request: NextRequest) {
  try {
    const apiKey = process.env.POLYGON_API_KEY
    if (!apiKey) {
      return NextResponse.json(
        { error: 'Polygon API key not configured' },
        { status: 500 }
      )
    }
    // For WebSocket connections, we'll use the API key directly as the token
    // This is safe because this endpoint is server-side only
    return NextResponse.json({
      wsUrl: WS_STOCKS_URL,
      token: apiKey,
      timestamp: new Date().toISOString()
    })
  } catch (error: any) {
    console.error('WebSocket connection error:', error)
    return NextResponse.json(
      { error: 'Failed to get WebSocket connection details' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/polygon-stocks/route.ts">
import { NextRequest, NextResponse } from "next/server"
// Rate limit helper
const RATE_LIMIT_DURATION = 60000 // 1 minute
const MAX_REQUESTS = 5
const requestLog = new Map<string, { count: number; timestamp: number }>()
function isRateLimited(ip: string): boolean {
  const now = Date.now()
  const userRequests = requestLog.get(ip)
  if (!userRequests) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (now - userRequests.timestamp > RATE_LIMIT_DURATION) {
    requestLog.set(ip, { count: 1, timestamp: now })
    return false
  }
  if (userRequests.count >= MAX_REQUESTS) {
    return true
  }
  userRequests.count++
  return false
}
// Input validation
function validateTicker(ticker: string): boolean {
  // Basic ticker validation: 1-5 uppercase letters
  return /^[A-Z]{1,5}$/.test(ticker)
}
export async function GET(request: NextRequest) {
  try {
    const apiKey = process.env.POLYGON_API_KEY
    if (!apiKey) {
      throw new Error("Polygon API key not set")
    }
    // Rate limiting
    const ip = request.headers.get("x-forwarded-for") || "unknown"
    if (isRateLimited(ip)) {
      return NextResponse.json(
        { error: "Rate limit exceeded. Please try again later." },
        { status: 429 }
      )
    }
    // Get and validate ticker
    const searchParams = request.nextUrl.searchParams
    const ticker = searchParams.get("ticker")?.toUpperCase()
    if (!ticker || !validateTicker(ticker)) {
      return NextResponse.json(
        { error: "Invalid ticker symbol. Please provide a valid stock symbol." },
        { status: 400 }
      )
    }
    // Get today's date in YYYY-MM-DD format
    const today = new Date().toISOString().split('T')[0]
    // Construct URLs for parallel requests
    const urls = {
      previousClose: `https://api.polygon.io/v2/aggs/ticker/${ticker}/prev?adjusted=true&apiKey=${apiKey}`,
      dailyOpen: `https://api.polygon.io/v1/open-close/${ticker}/${today}?adjusted=true&apiKey=${apiKey}`,
      details: `https://api.polygon.io/v3/reference/tickers/${ticker}?apiKey=${apiKey}`,
      // Use minute aggregates for current price instead of last trade
      currentAgg: `https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/minute/2024-01-01/${today}?adjusted=true&sort=desc&limit=1&apiKey=${apiKey}`
    }
    // Make parallel requests
    const [previousCloseResponse, dailyOpenResponse, detailsResponse, currentAggResponse] = await Promise.all([
      fetch(urls.previousClose),
      fetch(urls.dailyOpen),
      fetch(urls.details),
      fetch(urls.currentAgg)
    ])
    // Check for any failed requests
    const responses = [
      { name: 'previous close', response: previousCloseResponse },
      { name: 'details', response: detailsResponse },
      { name: 'current aggregates', response: currentAggResponse }
    ]
    for (const { name, response } of responses) {
      if (!response.ok) {
        console.error(`Failed to fetch ${name} data:`, await response.text())
        throw new Error(`Failed to fetch ${name} data: ${response.statusText}`)
      }
    }
    // Parse all responses
    const [previousCloseData, detailsData, currentAggData] = await Promise.all([
      previousCloseResponse.json(),
      detailsResponse.json(),
      currentAggResponse.json()
    ])
    // Parse daily open data if available
    const dailyOpenData = dailyOpenResponse.ok ? await dailyOpenResponse.json() : null
    // Extract and calculate values
    const previousClose = previousCloseData.results?.[0]?.c || null
    const currentPrice = currentAggData.results?.[0]?.c || previousClose
    const priceChange = currentPrice && previousClose ? currentPrice - previousClose : null
    const changePercent = currentPrice && previousClose ? ((currentPrice - previousClose) / previousClose) * 100 : null
    // Build enhanced response
    const response = {
      symbol: ticker,
      name: detailsData.results?.name || null,
      price: currentPrice,
      previousClose,
      change: priceChange ? Number(priceChange.toFixed(2)) : null,
      changePercent: changePercent ? Number(changePercent.toFixed(2)) : null,
      lastUpdated: currentAggData.results?.[0]?.t || null,
      volume: currentAggData.results?.[0]?.v || null,
      dayOpen: dailyOpenData?.open || null,
      dayHigh: dailyOpenData?.high || null,
      dayLow: dailyOpenData?.low || null,
      marketCap: detailsData.results?.market_cap || null,
      exchange: detailsData.results?.primary_exchange || null,
      type: detailsData.results?.type || null,
      status: "success",
      timestamp: new Date().toISOString()
    }
    return NextResponse.json(response)
  } catch (error: any) {
    console.error(`Error fetching stock data: ${error.message}`)
    return NextResponse.json(
      {
        error: error.message || "Failed to fetch stock data",
        status: "error",
        timestamp: new Date().toISOString()
      },
      { status: error.status || 500 }
    )
  }
}
</file>

<file path="app/api/search/route.ts">
import { NextRequest } from 'next/server';
import { polygonService } from '@/lib/api/polygon-service';
import { authMiddleware } from '@/lib/middleware/auth';
import { rateLimitMiddleware } from '@/lib/middleware/rate-limit';
import { errorHandler } from '@/lib/middleware/error-handler';
import { formatPaginatedResponse } from '@/lib/utils/response-formatter';
import { z } from 'zod';
interface TickerResult {
  ticker: string;
  name: string;
  market: string;
  type: string;
  active: boolean;
  primaryExchange: string;
  [key: string]: unknown;
}
const SearchQuerySchema = z.object({
  query: z.string().min(1),
  limit: z.string().regex(/^\d+$/).transform(Number).optional(),
  type: z.enum(['stocks', 'crypto', 'forex']).optional(),
  market: z.enum(['stocks', 'crypto', 'fx']).optional(),
  active: z.enum(['true', 'false']).transform(val => val === 'true').optional(),
});
export async function GET(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Get and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams.entries());
    const { query, limit = '10', active = true } = SearchQuerySchema.parse(searchParams);
    // Search tickers
    const searchResults = await polygonService.searchTickers(query, Number(limit));
    // Filter active/inactive if specified
    const filteredResults = active
      ? searchResults.results.filter((ticker: TickerResult) => ticker.active)
      : searchResults.results;
    // Format response with pagination
    return formatPaginatedResponse(
      filteredResults,
      {
        page: 1,
        limit: Number(limit),
        total: filteredResults.length,
        totalPages: Math.ceil(filteredResults.length / Number(limit)),
      },
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
// Advanced search endpoint
export async function POST(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate request body
    const body = await req.json();
    const {
      query,
      limit = 10,
      type = 'stocks',
      market = 'stocks',
      active = true,
      filters = {},
    } = body;
    // Search tickers
    const searchResults = await polygonService.searchTickers(query, limit);
    // Apply filters
    let filteredResults = searchResults.results as TickerResult[];
    // Filter by active status
    if (active !== undefined) {
      filteredResults = filteredResults.filter((ticker: TickerResult) => ticker.active === active);
    }
    // Filter by type
    if (type) {
      filteredResults = filteredResults.filter((ticker: TickerResult) => ticker.type === type);
    }
    // Filter by market
    if (market) {
      filteredResults = filteredResults.filter((ticker: TickerResult) => ticker.market === market);
    }
    // Apply custom filters
    if (Object.keys(filters).length > 0) {
      filteredResults = filteredResults.filter((ticker: TickerResult) => {
        return Object.entries(filters).every(([key, value]) => {
          if (typeof value === 'object' && value !== null) {
            const { min, max } = value as { min?: number; max?: number };
            const tickerValue = ticker[key];
            if (typeof tickerValue !== 'number') return false;
            if (min !== undefined && tickerValue < min) return false;
            if (max !== undefined && tickerValue > max) return false;
            return true;
          }
          return ticker[key] === value;
        });
      });
    }
    // Format response with pagination
    return formatPaginatedResponse(
      filteredResults,
      {
        page: 1,
        limit,
        total: filteredResults.length,
        totalPages: Math.ceil(filteredResults.length / limit),
      },
      {
        source: 'polygon',
        cached: true,
      }
    );
  } catch (error) {
    return errorHandler(error, req);
  }
}
</file>

<file path="app/api/stock/prev/[symbol]/route.ts">
import { NextResponse } from "next/server"
import { polygonService } from "@/lib/api/polygon-service"
import { rateLimitManager } from "@/lib/utils/rate-limiter"
// Cache for previous day data
const prevDayCache = new Map<string, {
  data: any;
  timestamp: number;
}>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
export async function GET(
  request: Request,
  { params }: { params: { symbol: string } }
) {
  try {
    // Rate limiting
    const ip = request.headers.get("x-forwarded-for") || "unknown"
    const rateLimit = await rateLimitManager.checkRateLimit(ip, "/api/stock/prev", {
      tokensPerInterval: 20,
      interval: "minute"
    });
    if (!rateLimit.success) {
      return NextResponse.json(
        { error: "Rate limit exceeded. Please try again later." },
        { 
          status: 429,
          headers: {
            'Retry-After': rateLimit.retryAfter?.toString() || '60'
          }
        }
      )
    }
    const symbol = params.symbol.toUpperCase()
    // Check cache
    const cached = prevDayCache.get(symbol)
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return NextResponse.json(cached.data)
    }
    // Get previous day's data
    const [prevDay, details] = await Promise.all([
      polygonService.getAggregates(
        symbol,
        1,
        'day',
        new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0]
      ),
      polygonService.getTickerDetails(symbol)
    ])
    if (!prevDay.results || prevDay.results.length === 0) {
      return NextResponse.json(
        { error: "No data available" },
        { status: 404 }
      )
    }
    const data = {
      symbol,
      description: details.results?.description,
      o: prevDay.results[0].o,
      h: prevDay.results[0].h,
      l: prevDay.results[0].l,
      c: prevDay.results[0].c,
      v: prevDay.results[0].v,
      vw: prevDay.results[0].vw,
      t: prevDay.results[0].t
    }
    // Update cache
    prevDayCache.set(symbol, {
      data,
      timestamp: Date.now()
    })
    return NextResponse.json(data)
  } catch (error) {
    console.error(`Error fetching previous day data for ${params.symbol}:`, error)
    return NextResponse.json(
      { error: "Failed to fetch previous day data" },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/stock/quote/[symbol]/route.ts">
import { NextResponse } from "next/server"
import { polygonService } from "@/lib/api/polygon-service"
export async function GET(
  request: Request,
  { params }: { params: { symbol: string } }
) {
  try {
    const symbol = params.symbol.toUpperCase()
    const [quote, aggregates] = await Promise.all([
      polygonService.getLastQuote(symbol),
      polygonService.getAggregates(
        symbol,
        1,
        'day',
        new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        new Date().toISOString().split('T')[0]
      ),
    ])
    // Calculate price and change
    const midPrice = (quote.results.P + quote.results.p) / 2
    const prevClose = aggregates.results[0].c
    const change = midPrice - prevClose
    const changePercent = (change / prevClose) * 100
    return NextResponse.json({
      symbol,
      price: midPrice,
      change,
      changePercent,
      timestamp: quote.results.t,
    })
  } catch (error) {
    console.error(`Error fetching quote for ${params.symbol}:`, error)
    return NextResponse.json(
      { error: "Failed to fetch quote" },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/stock/tickers/[preset]/route.ts">
import { NextResponse } from "next/server"
import { polygonService } from "@/lib/api/polygon-service"
import { TickerDetails } from "@/types/polygon"
interface SnapshotTicker {
  ticker: string;
  day?: {
    o: number;
    h: number;
    l: number;
    c: number;
    v: number;
    vw: number;
  };
  lastTrade?: {
    p: number;
    s: number;
    t: number;
    c: number[];
  };
  min?: {
    av: number;
    vw: number;
    o: number;
    c: number;
    h: number;
    l: number;
    v: number;
    t: number;
  };
  prevDay?: {
    o: number;
    h: number;
    l: number;
    c: number;
    v: number;
    vw: number;
  };
  todaysChange?: number;
  todaysChangePerc?: number;
  updated?: number;
}
// Cache for ticker lists
const tickerListCache = new Map<string, {
  tickers: string[];
  timestamp: number;
}>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
const TRENDING_TICKERS = [
  'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'NVDA', 'TSLA', 'JPM',
  'V', 'WMT', 'UNH', 'JNJ', 'MA', 'PG', 'HD', 'BAC', 'AVGO', 'XOM'
]
const SECTOR_TICKERS = {
  technology: ['AAPL', 'MSFT', 'GOOGL', 'META', 'NVDA', 'AVGO', 'CRM', 'ADBE', 'ORCL', 'CSCO'],
  healthcare: ['UNH', 'JNJ', 'LLY', 'PFE', 'ABT', 'TMO', 'MRK', 'DHR', 'BMY', 'ABBV'],
  finance: ['JPM', 'V', 'MA', 'BAC', 'WFC', 'MS', 'GS', 'BLK', 'C', 'AXP'],
  consumer: ['AMZN', 'WMT', 'PG', 'HD', 'MCD', 'NKE', 'COST', 'PEP', 'KO', 'DIS']
}
export async function GET(
  request: Request,
  { params }: { params: { preset: string } }
) {
  try {
    const { searchParams } = new URL(request.url)
    const sector = searchParams.get('sector')
    const customTickers = searchParams.get('tickers')?.split(',')
    const cacheKey = `${params.preset}-${sector || ''}`
    // Check cache
    const cached = tickerListCache.get(cacheKey)
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      return NextResponse.json({ tickers: cached.tickers })
    }
    let tickers: string[] = []
    switch (params.preset) {
      case 'trending':
        tickers = TRENDING_TICKERS
        break
      case 'sector':
        if (!sector || !SECTOR_TICKERS[sector as keyof typeof SECTOR_TICKERS]) {
          return NextResponse.json(
            { error: 'Invalid sector' },
            { status: 400 }
          )
        }
        tickers = SECTOR_TICKERS[sector as keyof typeof SECTOR_TICKERS]
        break
      case 'custom':
        if (!customTickers || customTickers.length === 0) {
          return NextResponse.json(
            { error: 'No tickers provided' },
            { status: 400 }
          )
        }
        tickers = customTickers
        break
      default:
        return NextResponse.json(
          { error: 'Invalid preset' },
          { status: 400 }
        )
    }
    // Validate the tickers exist on Polygon
    const snapshot = await polygonService.getSnapshots(tickers)
    if (snapshot.status === 'error' || !snapshot.tickers) {
      throw new Error('Failed to validate tickers')
    }
    // Only return tickers that have valid data
    const validTickers = snapshot.tickers
      .filter(ticker => ticker.lastTrade && ticker.day)
      .map(ticker => ticker.ticker)
    // Update cache
    tickerListCache.set(cacheKey, {
      tickers: validTickers,
      timestamp: Date.now(),
    })
    return NextResponse.json({ tickers: validTickers })
  } catch (error) {
    console.error('Error in tickers endpoint:', error)
    return NextResponse.json(
      { error: 'Failed to fetch tickers' },
      { status: 500 }
    )
  }
}
function getSectorTickers(sector: string): string[] {
  const sectorMap: { [key: string]: string[] } = {
    'Technology': ['AAPL', 'MSFT', 'NVDA', 'ADBE', 'CRM', 'CSCO', 'INTC', 'AMD', 'ORCL', 'IBM'],
    'Healthcare': ['JNJ', 'UNH', 'PFE', 'ABT', 'TMO', 'MRK', 'DHR', 'BMY', 'ABBV', 'LLY'],
    'Financials': ['JPM', 'BAC', 'WFC', 'C', 'GS', 'MS', 'BLK', 'AXP', 'USB', 'PNC'],
    'Consumer Discretionary': ['AMZN', 'HD', 'MCD', 'NKE', 'SBUX', 'TGT', 'LOW', 'BKNG', 'TJX', 'MAR'],
    'Consumer Staples': ['PG', 'KO', 'PEP', 'WMT', 'COST', 'PM', 'MO', 'EL', 'CL', 'KMB'],
    'Industrials': ['HON', 'UNP', 'UPS', 'BA', 'CAT', 'GE', 'MMM', 'LMT', 'RTX', 'DE'],
    'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'EOG', 'MPC', 'PSX', 'VLO', 'OXY', 'KMI'],
    'Materials': ['LIN', 'APD', 'ECL', 'SHW', 'FCX', 'NEM', 'DOW', 'DD', 'NUE', 'VMC'],
    'Utilities': ['NEE', 'DUK', 'SO', 'D', 'AEP', 'EXC', 'SRE', 'XEL', 'PEG', 'WEC'],
    'Real Estate': ['AMT', 'PLD', 'CCI', 'EQIX', 'PSA', 'DLR', 'O', 'WELL', 'AVB', 'EQR'],
    'Communication Services': ['GOOGL', 'META', 'NFLX', 'CMCSA', 'VZ', 'T', 'TMUS', 'DIS', 'ATVI', 'EA'],
  }
  return sectorMap[sector] || []
}
</file>

<file path="app/api/stock/tickers/trending/route.ts">
import { NextResponse } from 'next/server';
// Default list of popular tech stocks
const DEFAULT_SYMBOLS = [
  'AAPL',  // Apple
  'MSFT',  // Microsoft
  'GOOGL', // Alphabet
  'AMZN',  // Amazon
  'META',  // Meta
  'NVDA',  // NVIDIA
  'TSLA',  // Tesla
  'AMD',   // AMD
  'INTC',  // Intel
  'NFLX'   // Netflix
];
export async function GET() {
  try {
    // In a real implementation, you might want to fetch this from a market data API
    // For now, we'll return a static list of popular tech stocks
    return NextResponse.json({
      symbols: DEFAULT_SYMBOLS,
      timestamp: Date.now()
    });
  } catch (error) {
    console.error('Error fetching trending tickers:', error);
    return NextResponse.json(
      { error: 'Failed to fetch trending tickers' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/technical/route.ts">
import { NextRequest } from 'next/server';
import { polygonService, TechnicalIndicatorsResponse } from '@/lib/api/polygon-service';
import { authMiddleware } from '@/lib/middleware/auth';
import { rateLimitMiddleware } from '@/lib/middleware/rate-limit';
import { errorHandler } from '@/lib/middleware/error-handler';
import { validateRequest } from '@/lib/utils/request-validator';
import { TechnicalIndicatorRequestSchema } from '@/lib/utils/request-validator';
import { formatResponse } from '@/lib/utils/response-formatter';
import { DataTransformer } from '@/lib/utils/data-validator';
export async function POST(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Validate request body
    const validatedData = await validateRequest(req, TechnicalIndicatorRequestSchema);
    // Get technical indicator data based on type
    let indicatorData: TechnicalIndicatorsResponse;
    switch (validatedData.indicator) {
      case 'SMA':
        indicatorData = await polygonService.getSMA(
          validatedData.symbol,
          '1d', // Default timeframe
          validatedData.period,
          validatedData.startDate,
          validatedData.endDate
        );
        break;
      case 'RSI':
        indicatorData = await polygonService.getRSI(
          validatedData.symbol,
          '1d', // Default timeframe
          validatedData.period,
          validatedData.startDate,
          validatedData.endDate
        );
        break;
      default:
        throw new Error(`Unsupported indicator: ${validatedData.indicator}`);
    }
    // Transform and validate the data
    const transformedData = indicatorData.results.values.map(result =>
      DataTransformer.formatTechnicalIndicator(
        result,
        validatedData.indicator,
        validatedData.period
      )
    );
    // Format response
    return formatResponse(transformedData, {
      source: 'polygon',
      cached: false,
    });
  } catch (error) {
    return errorHandler(error, req);
  }
}
// GET endpoint for predefined technical indicators
export async function GET(req: NextRequest) {
  try {
    // Apply middleware
    const authResponse = await authMiddleware(req);
    if (authResponse.status !== 200) return authResponse;
    const rateLimitResponse = await rateLimitMiddleware(req);
    if (rateLimitResponse.status !== 200) return rateLimitResponse;
    // Get query parameters
    const symbol = req.nextUrl.searchParams.get('symbol');
    if (!symbol) {
      throw new Error('Symbol is required');
    }
    // Get common technical indicators
    const [sma20, sma50, sma200, rsi14] = await Promise.all([
      polygonService.getSMA(symbol, '1d', 20, '', ''),
      polygonService.getSMA(symbol, '1d', 50, '', ''),
      polygonService.getSMA(symbol, '1d', 200, '', ''),
      polygonService.getRSI(symbol, '1d', 14, '', ''),
    ]);
    // Transform and combine the data
    const technicalData = {
      sma: {
        20: DataTransformer.formatTechnicalIndicator(
          sma20.results.values[sma20.results.values.length - 1],
          'SMA',
          20
        ),
        50: DataTransformer.formatTechnicalIndicator(
          sma50.results.values[sma50.results.values.length - 1],
          'SMA',
          50
        ),
        200: DataTransformer.formatTechnicalIndicator(
          sma200.results.values[sma200.results.values.length - 1],
          'SMA',
          200
        ),
      },
      rsi: DataTransformer.formatTechnicalIndicator(
        rsi14.results.values[rsi14.results.values.length - 1],
        'RSI',
        14
      ),
    };
    // Format response
    return formatResponse(technicalData, {
      source: 'polygon',
      cached: false,
    });
  } catch (error) {
    return errorHandler(error, req);
  }
}
</file>

<file path="app/asset-screener/page.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Slider } from "@/components/ui/slider"
import { Switch } from "@/components/ui/switch"
import { Label } from "@/components/ui/label"
import { AssetCard } from "@/components/asset-search/asset-card"
import { screenAssets, getRealtimeData } from "@/lib/api/asset-screener"
import { Loader2, AlertTriangle } from "lucide-react"
import { useToast } from "@/components/ui/use-toast"
interface Fundamentals {
  peRatioMin: number
  peRatioMax: number
  epsGrowthMin: number
  debtToEquityMax: number
  dividendYieldMin: number
  marketCapMin: number
}
interface Technicals {
  rsiMin: number
  rsiMax: number
  macdSignal: string
  movingAveragePeriod: number
  movingAverageType: string
}
interface Sentiment {
  analystRatingMin: number
  newsScore: string
  insiderBuying: boolean
}
interface ScreeningCriteria {
  assetClass: string
  fundamentals: Fundamentals
  technicals: Technicals
  sentiment: Sentiment
}
interface Asset {
  id: string
  name: string
  symbol: string
  assetClass: string
  price: number
  change: number
  score: number
  volume: number
  marketCap: number
  peRatio: number
}
type ScreeningField = keyof Fundamentals | keyof Technicals | keyof Sentiment
interface AssetData {
  [key: string]: {
    price: number
    change: number
    volume: number
    marketCap: number
    peRatio: number
  }
}
export default function AssetScreenerPage() {
  const [screeningCriteria, setScreeningCriteria] = useState<ScreeningCriteria>({
    assetClass: "stocks",
    fundamentals: {
      peRatioMin: 0,
      peRatioMax: 50,
      epsGrowthMin: 10,
      debtToEquityMax: 2,
      dividendYieldMin: 0,
      marketCapMin: 1000000000,
    },
    technicals: {
      rsiMin: 30,
      rsiMax: 70,
      macdSignal: "bullish",
      movingAveragePeriod: 50,
      movingAverageType: "simple",
    },
    sentiment: {
      analystRatingMin: 4,
      newsScore: "positive",
      insiderBuying: true,
    },
  })
  const [screeningResults, setScreeningResults] = useState<Asset[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const { toast } = useToast()
  const handleScreeningCriteriaChange = (
    category: keyof ScreeningCriteria,
    field: ScreeningField,
    value: string | number | boolean
  ) => {
    setScreeningCriteria((prevCriteria: ScreeningCriteria) => {
      if (category === 'fundamentals') {
        return {
          ...prevCriteria,
          fundamentals: {
            ...prevCriteria.fundamentals,
            [field]: value,
          },
        }
      } else if (category === 'technicals') {
        return {
          ...prevCriteria,
          technicals: {
            ...prevCriteria.technicals,
            [field]: value,
          },
        }
      } else if (category === 'sentiment') {
        return {
          ...prevCriteria,
          sentiment: {
            ...prevCriteria.sentiment,
            [field]: value,
          },
        }
      }
      return prevCriteria
    })
    toast({
      title: "Criteria Updated",
      description: `${category} ${field} set to ${value}`,
    })
  }
  const handleScreening = async () => {
    setIsLoading(true)
    setError(null)
    try {
      const results = await screenAssets(screeningCriteria)
      setScreeningResults(results as Asset[])
    } catch (error) {
      console.error("Error during asset screening:", error)
      setError("An error occurred while screening assets. Please try again.")
      toast({
        title: "Screening Error",
        description: "An error occurred while screening assets. Please try again.",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }
  useEffect(() => {
    let intervalId: NodeJS.Timeout | undefined
    if (screeningResults.length > 0) {
      intervalId = setInterval(async () => {
        try {
          const updatedData = await getRealtimeData(screeningResults.map((asset) => asset.symbol))
          setScreeningResults((prevResults) =>
            prevResults.map((asset) => ({
              ...asset,
              ...(updatedData[asset.symbol] as Partial<Asset>),
            }))
          )
        } catch (error) {
          console.error("Error fetching real-time data:", error)
        }
      }, 5000)
    }
    return () => {
      if (intervalId) clearInterval(intervalId)
    }
  }, [screeningResults])
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">AI-Powered Asset Screener</h1>
      <Card>
        <CardHeader>
          <CardTitle>Screening Criteria</CardTitle>
          <CardDescription>Set your criteria to filter assets</CardDescription>
        </CardHeader>
        <CardContent>
          <Tabs defaultValue="fundamentals">
            <TabsList>
              <TabsTrigger value="fundamentals">Fundamentals</TabsTrigger>
              <TabsTrigger value="technicals">Technicals</TabsTrigger>
              <TabsTrigger value="sentiment">Sentiment</TabsTrigger>
            </TabsList>
            <TabsContent value="fundamentals">
              <div className="space-y-4">
                <div>
                  <Label>P/E Ratio Range</Label>
                  <div className="flex items-center space-x-2">
                    <Input
                      type="number"
                      value={screeningCriteria.fundamentals.peRatioMin}
                      onChange={(e) =>
                        handleScreeningCriteriaChange("fundamentals", "peRatioMin", Number.parseFloat(e.target.value))
                      }
                      className="w-20"
                    />
                    <span>to</span>
                    <Input
                      type="number"
                      value={screeningCriteria.fundamentals.peRatioMax}
                      onChange={(e) =>
                        handleScreeningCriteriaChange("fundamentals", "peRatioMax", Number.parseFloat(e.target.value))
                      }
                      className="w-20"
                    />
                  </div>
                </div>
                <div>
                  <Label>Minimum EPS Growth (%)</Label>
                  <Input
                    type="number"
                    value={screeningCriteria.fundamentals.epsGrowthMin}
                    onChange={(e) =>
                      handleScreeningCriteriaChange("fundamentals", "epsGrowthMin", Number.parseFloat(e.target.value))
                    }
                  />
                </div>
                <div>
                  <Label>Maximum Debt to Equity Ratio</Label>
                  <Input
                    type="number"
                    value={screeningCriteria.fundamentals.debtToEquityMax}
                    onChange={(e) =>
                      handleScreeningCriteriaChange("fundamentals", "debtToEquityMax", Number.parseFloat(e.target.value))
                    }
                  />
                </div>
                <div>
                  <Label>Minimum Dividend Yield (%)</Label>
                  <Input
                    type="number"
                    value={screeningCriteria.fundamentals.dividendYieldMin}
                    onChange={(e) =>
                      handleScreeningCriteriaChange("fundamentals", "dividendYieldMin", Number.parseFloat(e.target.value))
                    }
                  />
                </div>
                <div>
                  <Label>Minimum Market Cap (in billions)</Label>
                  <Input
                    type="number"
                    value={screeningCriteria.fundamentals.marketCapMin}
                    onChange={(e) =>
                      handleScreeningCriteriaChange("fundamentals", "marketCapMin", Number.parseFloat(e.target.value))
                    }
                  />
                </div>
              </div>
            </TabsContent>
            <TabsContent value="technicals">
              <div className="space-y-4">
                <div>
                  <Label>RSI Range</Label>
                  <Slider
                    min={0}
                    max={100}
                    step={1}
                    value={[screeningCriteria.technicals.rsiMin, screeningCriteria.technicals.rsiMax]}
                    onValueChange={(value) => {
                      handleScreeningCriteriaChange("technicals", "rsiMin", value[0])
                      handleScreeningCriteriaChange("technicals", "rsiMax", value[1])
                    }}
                  />
                  <div className="flex justify-between">
                    <span>{screeningCriteria.technicals.rsiMin}</span>
                    <span>{screeningCriteria.technicals.rsiMax}</span>
                  </div>
                </div>
                <div>
                  <Label>MACD Signal</Label>
                  <Select
                    value={screeningCriteria.technicals.macdSignal}
                    onValueChange={(value) => handleScreeningCriteriaChange("technicals", "macdSignal", value)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select MACD signal" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="bullish">Bullish</SelectItem>
                      <SelectItem value="bearish">Bearish</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <Label>Moving Average</Label>
                  <div className="flex items-center space-x-2">
                    <Input
                      type="number"
                      value={screeningCriteria.technicals.movingAveragePeriod}
                      onChange={(e) =>
                        handleScreeningCriteriaChange(
                          "technicals",
                          "movingAveragePeriod",
                          Number.parseInt(e.target.value),
                        )
                      }
                      className="w-20"
                    />
                    <Select
                      value={screeningCriteria.technicals.movingAverageType}
                      onValueChange={(value) => handleScreeningCriteriaChange("technicals", "movingAverageType", value)}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Type" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="simple">Simple</SelectItem>
                        <SelectItem value="exponential">Exponential</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              </div>
            </TabsContent>
            <TabsContent value="sentiment">
              <div className="space-y-4">
                <div>
                  <Label>Minimum News Sentiment Score</Label>
                  <Slider
                    min={-100}
                    max={100}
                    step={1}
                    value={[screeningCriteria.sentiment.analystRatingMin]}
                    onValueChange={(value) => handleScreeningCriteriaChange("sentiment", "analystRatingMin", value[0])}
                  />
                  <div className="text-center">{screeningCriteria.sentiment.analystRatingMin}</div>
                </div>
                <div>
                  <Label>Analyst Rating</Label>
                  <Select
                    value={screeningCriteria.sentiment.newsScore}
                    onValueChange={(value) => handleScreeningCriteriaChange("sentiment", "newsScore", value)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select news score" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="positive">Positive</SelectItem>
                      <SelectItem value="neutral">Neutral</SelectItem>
                      <SelectItem value="negative">Negative</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex items-center space-x-2">
                  <Switch
                    id="insider-buying"
                    checked={screeningCriteria.sentiment.insiderBuying}
                    onCheckedChange={(checked) => handleScreeningCriteriaChange("sentiment", "insiderBuying", checked)}
                  />
                  <Label htmlFor="insider-buying">Insider Buying</Label>
                </div>
              </div>
            </TabsContent>
          </Tabs>
          <div className="mt-6">
            <Button onClick={handleScreening} disabled={isLoading}>
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Screening...
                </>
              ) : (
                "Screen Assets"
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
      {error && (
        <Card className="bg-destructive/15">
          <CardContent className="pt-6">
            <div className="flex items-center space-x-2">
              <AlertTriangle className="h-4 w-4 text-destructive" />
              <p className="text-destructive">{error}</p>
            </div>
          </CardContent>
        </Card>
      )}
      {screeningResults.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Screening Results</CardTitle>
            <CardDescription>{screeningResults.length} assets found</CardDescription>
          </CardHeader>
          <CardContent>
            <ScrollArea className="h-[400px]">
              {screeningResults.map((asset) => (
                <AssetCard key={asset.id} asset={asset} onSelect={() => {}} />
              ))}
            </ScrollArea>
          </CardContent>
        </Card>
      )}
    </div>
  )
}
</file>

<file path="app/asset-search/page.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Loader2 } from "lucide-react"
import { AssetCard } from "@/components/asset-search/asset-card"
import { RelatedAssets } from "@/components/asset-search/related-assets"
import { searchAssets, getAssetDetails } from "@/lib/api/asset-search"
import { useDebounce } from "@/lib/hooks/use-debounce"
import { useToast } from "@/components/ui/use-toast"
import { Skeleton } from "@/components/ui/skeleton"
import { Asset } from "@/types/asset-screener"
interface AssetDetails {
  name: string
  description: string
  sector: string
  industry: string
  marketCap: number
  peRatio: number
  dividendYield: number
  beta: number
  yearHigh: number
  yearLow: number
}
interface NewsItem {
  id: string
  title: string
  summary: string
  url: string
  publishedAt: string
  source: string
}
interface APIResponse {
  name: string
  description: string
  sector: string
  industry: string
  marketCap: number
  peRatio: number
  dividendYield: number
  beta: number
  yearHigh: number
  yearLow: number
  relatedAssets: Asset[]
  newsItems: NewsItem[]
}
export default function AssetSearchPage() {
  const [searchTerm, setSearchTerm] = useState("")
  const [searchResults, setSearchResults] = useState<Asset[]>([])
  const [selectedAsset, setSelectedAsset] = useState<Asset | null>(null)
  const [assetDetails, setAssetDetails] = useState<AssetDetails | null>(null)
  const [relatedAssets, setRelatedAssets] = useState<Asset[]>([])
  const [newsItems, setNewsItems] = useState<NewsItem[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [isLoadingDetails, setIsLoadingDetails] = useState(false)
  const debouncedSearchTerm = useDebounce(searchTerm, 500)
  const { toast } = useToast()
  useEffect(() => {
    const performSearch = async () => {
      if (!debouncedSearchTerm) {
        setSearchResults([])
        return
      }
      setIsLoading(true)
      try {
        const results = await searchAssets(debouncedSearchTerm)
        setSearchResults(results as Asset[])
      } catch (error) {
        console.error("Error searching assets:", error)
        toast({
          title: "Search Error",
          description: "An error occurred while searching assets. Please try again.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }
    performSearch()
  }, [debouncedSearchTerm, toast])
  const handleAssetSelect = async (asset: Asset) => {
    setSelectedAsset(asset)
    setIsLoadingDetails(true)
    try {
      const response = await getAssetDetails(asset.symbol)
      const details = response as unknown as APIResponse
      setAssetDetails({
        name: details.name,
        description: details.description,
        sector: details.sector,
        industry: details.industry,
        marketCap: details.marketCap,
        peRatio: details.peRatio,
        dividendYield: details.dividendYield,
        beta: details.beta,
        yearHigh: details.yearHigh,
        yearLow: details.yearLow,
      })
      setRelatedAssets(details.relatedAssets)
      setNewsItems(details.newsItems)
    } catch (error) {
      console.error("Error fetching asset details:", error)
      toast({
        title: "Error",
        description: "Failed to load asset details. Please try again.",
        variant: "destructive",
      })
    } finally {
      setIsLoadingDetails(false)
    }
  }
  return (
    <div className="container mx-auto p-6">
      <Card>
        <CardHeader>
          <CardTitle>Asset Search</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="relative">
            <Input
              type="text"
              placeholder="Search assets..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full"
            />
            {isLoading && (
              <div className="absolute right-3 top-1/2 -translate-y-1/2">
                <Loader2 className="h-4 w-4 animate-spin" />
              </div>
            )}
          </div>
          <div className="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-1">
              <ScrollArea className="h-[600px]">
                {searchResults.map((asset) => (
                  <AssetCard key={asset.id} asset={asset} onSelect={() => handleAssetSelect(asset)} />
                ))}
                {!isLoading && searchTerm && searchResults.length === 0 && (
                  <p className="text-center text-muted-foreground">No assets found</p>
                )}
              </ScrollArea>
            </div>
            {selectedAsset && (
              <div className="lg:col-span-2">
                <Tabs defaultValue="details">
                  <TabsList>
                    <TabsTrigger value="details">Details</TabsTrigger>
                    <TabsTrigger value="related">Related Assets</TabsTrigger>
                    <TabsTrigger value="news">News</TabsTrigger>
                  </TabsList>
                  <TabsContent value="details">
                    {isLoadingDetails ? (
                      <div className="space-y-4">
                        <Skeleton className="h-4 w-3/4" />
                        <Skeleton className="h-4 w-1/2" />
                        <Skeleton className="h-4 w-2/3" />
                      </div>
                    ) : assetDetails ? (
                      <div className="space-y-4">
                        <h3 className="text-xl font-bold">{assetDetails.name}</h3>
                        <p className="text-muted-foreground">{assetDetails.description}</p>
                        {/* Add more details here */}
                      </div>
                    ) : null}
                  </TabsContent>
                  <TabsContent value="related">
                    <RelatedAssets assets={relatedAssets} onSelect={handleAssetSelect} />
                  </TabsContent>
                  <TabsContent value="news">
                    <div className="space-y-4">
                      {newsItems.map((item) => (
                        <Card key={item.id}>
                          <CardContent className="p-4">
                            <h4 className="font-semibold">{item.title}</h4>
                            <p className="text-sm text-muted-foreground">{item.summary}</p>
                            <div className="mt-2 flex justify-between text-xs text-muted-foreground">
                              <span>{item.source}</span>
                              <span>{new Date(item.publishedAt).toLocaleDateString()}</span>
                            </div>
                          </CardContent>
                        </Card>
                      ))}
                    </div>
                  </TabsContent>
                </Tabs>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/backtesting/page.tsx">
import { BacktestingDashboard } from "@/components/backtesting/backtesting-dashboard"
export default function BacktestingPage() {
  return (
    <div className="container mx-auto p-4">
      <BacktestingDashboard />
    </div>
  )
}
</file>

<file path="app/business-major/courses/page.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import Link from "next/link"
const courses = [
  { id: "BUS101", name: "Introduction to Business", credits: 3, level: "Beginner", duration: "4 weeks" },
  { id: "ECON201", name: "Microeconomics", credits: 3, level: "Intermediate", duration: "6 weeks" },
  { id: "ACCT301", name: "Financial Accounting", credits: 4, level: "Intermediate", duration: "8 weeks" },
  { id: "MKT401", name: "Marketing Strategy", credits: 3, level: "Advanced", duration: "6 weeks" },
  { id: "FIN501", name: "Corporate Finance", credits: 4, level: "Advanced", duration: "8 weeks" },
]
export default function CourseCatalogPage() {
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Course Catalog</h1>
      <Card>
        <CardHeader>
          <CardTitle>Available Courses</CardTitle>
          <CardDescription>Browse our comprehensive list of business courses</CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Course Code</TableHead>
                <TableHead>Course Name</TableHead>
                <TableHead>Credits</TableHead>
                <TableHead>Level</TableHead>
                <TableHead>Duration</TableHead>
                <TableHead>Action</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {courses.map((course) => (
                <TableRow key={course.id}>
                  <TableCell>{course.id}</TableCell>
                  <TableCell>{course.name}</TableCell>
                  <TableCell>{course.credits}</TableCell>
                  <TableCell>
                    <Badge
                      variant={
                        course.level === "Beginner"
                          ? "secondary"
                          : course.level === "Intermediate"
                            ? "default"
                            : "destructive"
                      }
                    >
                      {course.level}
                    </Badge>
                  </TableCell>
                  <TableCell>{course.duration}</TableCell>
                  <TableCell>
                    <Button asChild size="sm">
                      <Link href={`/business-major/courses/${course.id}`}>Details</Link>
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Specializations</CardTitle>
          <CardDescription>Focus your studies with one of our specialized tracks</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {["Finance", "Marketing", "Management", "Entrepreneurship", "International Business"].map(
              (specialization) => (
                <Card key={specialization}>
                  <CardHeader>
                    <CardTitle className="text-lg">{specialization}</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <Button asChild>
                      <Link href={`/business-major/specializations/${specialization.toLowerCase().replace(" ", "-")}`}>
                        View Courses
                      </Link>
                    </Button>
                  </CardContent>
                </Card>
              ),
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/business-major/dashboard/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { BarChart, Calendar, GraduationCap, BookOpen } from "lucide-react"
export default function StudentDashboardPage() {
  const [overallProgress, setOverallProgress] = useState(35)
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Student Dashboard</h1>
      <Card>
        <CardHeader>
          <CardTitle>Overall Progress</CardTitle>
          <CardDescription>Track your journey towards your business major</CardDescription>
        </CardHeader>
        <CardContent>
          <Progress value={overallProgress} className="w-full h-4 mb-2" />
          <div className="flex justify-between text-sm text-muted-foreground">
            <span>0%</span>
            <span>{overallProgress}% Complete</span>
            <span>100%</span>
          </div>
        </CardContent>
      </Card>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Credits Completed</CardTitle>
            <BookOpen className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">42 / 120</div>
            <p className="text-xs text-muted-foreground">Credits</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Current GPA</CardTitle>
            <GraduationCap className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">3.7</div>
            <p className="text-xs text-muted-foreground">Out of 4.0</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Courses In Progress</CardTitle>
            <BarChart className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">3</div>
            <p className="text-xs text-muted-foreground">Active courses</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Estimated Completion</CardTitle>
            <Calendar className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">May 2024</div>
            <p className="text-xs text-muted-foreground">Based on current pace</p>
          </CardContent>
        </Card>
      </div>
      <Tabs defaultValue="current-courses">
        <TabsList>
          <TabsTrigger value="current-courses">Current Courses</TabsTrigger>
          <TabsTrigger value="completed-courses">Completed Courses</TabsTrigger>
          <TabsTrigger value="upcoming-courses">Upcoming Courses</TabsTrigger>
        </TabsList>
        <TabsContent value="current-courses">
          <Card>
            <CardHeader>
              <CardTitle>Current Courses</CardTitle>
              <CardDescription>Courses you are currently enrolled in</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {["Marketing Strategy", "Corporate Finance", "Business Ethics"].map((course, index) => (
                  <div key={index} className="flex items-center justify-between">
                    <div>
                      <h3 className="font-semibold">{course}</h3>
                      <p className="text-sm text-muted-foreground">In progress</p>
                    </div>
                    <Badge>Active</Badge>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="completed-courses">
          <Card>
            <CardHeader>
              <CardTitle>Completed Courses</CardTitle>
              <CardDescription>Courses you have successfully finished</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {["Introduction to Business", "Microeconomics", "Financial Accounting"].map((course, index) => (
                  <div key={index} className="flex items-center justify-between">
                    <div>
                      <h3 className="font-semibold">{course}</h3>
                      <p className="text-sm text-muted-foreground">Completed</p>
                    </div>
                    <Badge variant="secondary">Passed</Badge>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="upcoming-courses">
          <Card>
            <CardHeader>
              <CardTitle>Upcoming Courses</CardTitle>
              <CardDescription>Recommended courses for your next semester</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {["Operations Management", "International Business", "Strategic Management"].map((course, index) => (
                  <div key={index} className="flex items-center justify-between">
                    <div>
                      <h3 className="font-semibold">{course}</h3>
                      <p className="text-sm text-muted-foreground">Recommended</p>
                    </div>
                    <Button size="sm">Enroll</Button>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  )
}
</file>

<file path="app/business-major/page.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import Link from "next/link"
import { BookOpen, Clock, Award, BarChart2, GraduationCap, Users, FileText } from "lucide-react"
export default function BusinessMajorPage() {
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Accelerated Business Major Program</h1>
      <Card>
        <CardHeader>
          <CardTitle>Program Overview</CardTitle>
          <CardDescription>
            Complete your business major in 1-2 years with our accelerated, asynchronous program
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <p>
            Our innovative program allows you to complete a full business major at your own pace, with the potential to
            finish in just 1-2 years instead of the traditional 3-4 year timeline.
          </p>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="flex items-center space-x-2">
              <Clock className="h-5 w-5 text-primary" />
              <span>Flexible, self-paced learning</span>
            </div>
            <div className="flex items-center space-x-2">
              <BookOpen className="h-5 w-5 text-primary" />
              <span>Comprehensive curriculum</span>
            </div>
            <div className="flex items-center space-x-2">
              <Award className="h-5 w-5 text-primary" />
              <span>Accredited degree program</span>
            </div>
            <div className="flex items-center space-x-2">
              <BarChart2 className="h-5 w-5 text-primary" />
              <span>Industry-relevant skills</span>
            </div>
            <div className="flex items-center space-x-2">
              <GraduationCap className="h-5 w-5 text-primary" />
              <span>Career-focused education</span>
            </div>
            <div className="flex items-center space-x-2">
              <Users className="h-5 w-5 text-primary" />
              <span>Networking opportunities</span>
            </div>
          </div>
        </CardContent>
      </Card>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Program Highlights</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <div className="flex items-center justify-between">
              <span>Total Credits</span>
              <Badge>120</Badge>
            </div>
            <div className="flex items-center justify-between">
              <span>Core Business Courses</span>
              <Badge>15</Badge>
            </div>
            <div className="flex items-center justify-between">
              <span>Specializations Available</span>
              <Badge>5</Badge>
            </div>
            <div className="flex items-center justify-between">
              <span>Minimum Completion Time</span>
              <Badge>12 months</Badge>
            </div>
            <div className="flex items-center justify-between">
              <span>Maximum Completion Time</span>
              <Badge>24 months</Badge>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Getting Started</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p>Ready to accelerate your business education? Follow these steps to begin:</p>
            <ol className="list-decimal list-inside space-y-2">
              <li>Review the course catalog</li>
              <li>Create your personalized learning plan</li>
              <li>Enroll in your first set of courses</li>
              <li>Start learning at your own pace</li>
            </ol>
            <div className="flex justify-between mt-4">
              <Button asChild>
                <Link href="/business-major/courses">View Course Catalog</Link>
              </Button>
              <Button asChild variant="outline">
                <Link href="/business-major/dashboard">Student Dashboard</Link>
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
      <Card>
        <CardHeader>
          <CardTitle>Program Structure</CardTitle>
          <CardDescription>Understanding the components of your business major</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">Core Courses</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground">Foundational business knowledge and skills</p>
                <FileText className="h-12 w-12 text-primary mt-2" />
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">Specializations</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground">Focus areas for in-depth expertise</p>
                <BarChart2 className="h-12 w-12 text-primary mt-2" />
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">Electives</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground">Customize your learning experience</p>
                <BookOpen className="h-12 w-12 text-primary mt-2" />
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">Capstone Project</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground">Apply your knowledge to real-world scenarios</p>
                <Award className="h-12 w-12 text-primary mt-2" />
              </CardContent>
            </Card>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/certifications/page.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
import { Progress } from "@/components/ui/progress"
import { Button } from "@/components/ui/button"
import { CheckCircle2, BookOpen, FileQuestion, BarChart, Clock, Award, DollarSign } from "lucide-react"
const cfaLevels = [
  {
    level: "Level I",
    topics: [
      { name: "Ethical and Professional Standards", progress: 75 },
      { name: "Quantitative Methods", progress: 60 },
      { name: "Economics", progress: 80 },
      { name: "Financial Reporting and Analysis", progress: 70 },
      { name: "Corporate Finance", progress: 65 },
      { name: "Equity Investments", progress: 85 },
      { name: "Fixed Income", progress: 55 },
      { name: "Derivatives", progress: 50 },
      { name: "Alternative Investments", progress: 45 },
      { name: "Portfolio Management and Wealth Planning", progress: 70 },
    ],
  },
  {
    level: "Level II",
    topics: [
      { name: "Ethical and Professional Standards", progress: 0 },
      { name: "Quantitative Methods", progress: 0 },
      { name: "Economics", progress: 0 },
      { name: "Financial Reporting and Analysis", progress: 0 },
      { name: "Corporate Finance", progress: 0 },
      { name: "Equity Investments", progress: 0 },
      { name: "Fixed Income", progress: 0 },
      { name: "Derivatives", progress: 0 },
      { name: "Alternative Investments", progress: 0 },
      { name: "Portfolio Management and Wealth Planning", progress: 0 },
    ],
  },
  {
    level: "Level III",
    topics: [
      { name: "Ethical and Professional Standards", progress: 0 },
      { name: "Economics", progress: 0 },
      { name: "Financial Reporting and Analysis", progress: 0 },
      { name: "Equity Investments", progress: 0 },
      { name: "Fixed Income", progress: 0 },
      { name: "Derivatives", progress: 0 },
      { name: "Alternative Investments", progress: 0 },
      { name: "Portfolio Management and Wealth Planning", progress: 0 },
    ],
  },
]
const ctmTopics = [
  { name: "Treasury Management Fundamentals", progress: 80 },
  { name: "Working Capital Management", progress: 75 },
  { name: "Capital Markets and Funding", progress: 70 },
  { name: "Cash Management", progress: 85 },
  { name: "Treasury Operations and Controls", progress: 65 },
  { name: "Risk Management", progress: 60 },
  { name: "Financial Planning and Analysis", progress: 55 },
]
const practiceQuestions = [
  {
    question: "What is the primary purpose of the Sharpe ratio?",
    options: [
      "To measure the volatility of a portfolio",
      "To compare the return of different portfolios",
      "To measure risk-adjusted performance",
      "To calculate the correlation between assets",
    ],
    correctAnswer: 2,
  },
  {
    question: "Which of the following is NOT a type of market efficiency?",
    options: ["Weak form", "Semi-strong form", "Strong form", "Ultra-strong form"],
    correctAnswer: 3,
  },
  {
    question: "What does WACC stand for in corporate finance?",
    options: [
      "Weighted Average Cost of Capital",
      "Weighted Asset Cost Calculation",
      "Whole Asset Cost of Capital",
      "Weighted Average Capital Cost",
    ],
    correctAnswer: 0,
  },
]
export default function CertificationsPage() {
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">CFA and CTM Training Modules</h1>
      <Tabs defaultValue="cfa" className="space-y-4">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="cfa">CFA Certification</TabsTrigger>
          <TabsTrigger value="ctm">CTM Certification</TabsTrigger>
        </TabsList>
        <TabsContent value="cfa">
          <Card>
            <CardHeader>
              <CardTitle>Chartered Financial Analyst (CFA) Program</CardTitle>
              <CardDescription>Comprehensive study modules for each CFA level</CardDescription>
            </CardHeader>
            <CardContent>
              <Tabs defaultValue="Level I" className="space-y-4">
                <TabsList className="grid w-full grid-cols-3">
                  {cfaLevels.map((level) => (
                    <TabsTrigger key={level.level} value={level.level}>
                      {level.level}
                    </TabsTrigger>
                  ))}
                </TabsList>
                {cfaLevels.map((level) => (
                  <TabsContent key={level.level} value={level.level}>
                    <div className="space-y-4">
                      {level.topics.map((topic, index) => (
                        <div key={index}>
                          <div className="flex justify-between mb-1">
                            <span className="text-sm font-medium">{topic.name}</span>
                            <span className="text-sm font-medium">{topic.progress}%</span>
                          </div>
                          <Progress value={topic.progress} className="h-2" />
                        </div>
                      ))}
                    </div>
                  </TabsContent>
                ))}
              </Tabs>
              <div className="mt-6 space-y-4">
                <h3 className="text-lg font-semibold">Practice Questions</h3>
                <Accordion type="single" collapsible className="w-full">
                  {practiceQuestions.map((q, index) => (
                    <AccordionItem value={`question-${index}`} key={index}>
                      <AccordionTrigger>{q.question}</AccordionTrigger>
                      <AccordionContent>
                        <ul className="list-disc pl-5 space-y-2">
                          {q.options.map((option, optionIndex) => (
                            <li key={optionIndex} className={optionIndex === q.correctAnswer ? "font-bold" : ""}>
                              {option}
                              {optionIndex === q.correctAnswer && (
                                <CheckCircle2 className="inline-block ml-2 h-4 w-4 text-green-500" />
                              )}
                            </li>
                          ))}
                        </ul>
                      </AccordionContent>
                    </AccordionItem>
                  ))}
                </Accordion>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="ctm">
          <Card>
            <CardHeader>
              <CardTitle>Certified Treasury Management (CTM) Program</CardTitle>
              <CardDescription>Study modules and progress tracking for CTM certification</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-6">
                <div className="space-y-4">
                  {ctmTopics.map((topic, index) => (
                    <div key={index}>
                      <div className="flex justify-between mb-1">
                        <span className="text-sm font-medium">{topic.name}</span>
                        <span className="text-sm font-medium">{topic.progress}%</span>
                      </div>
                      <Progress value={topic.progress} className="h-2" />
                    </div>
                  ))}
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                    <BookOpen className="h-6 w-6 mb-2" />
                    <span>Study Materials</span>
                  </Button>
                  <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                    <FileQuestion className="h-6 w-6 mb-2" />
                    <span>Practice Exams</span>
                  </Button>
                  <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                    <BarChart className="h-6 w-6 mb-2" />
                    <span>Performance Analytics</span>
                  </Button>
                  <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                    <Clock className="h-6 w-6 mb-2" />
                    <span>Study Planner</span>
                  </Button>
                </div>
                <div>
                  <h3 className="text-lg font-semibold mb-2">Certification Path</h3>
                  <ol className="list-decimal pl-5 space-y-2">
                    <li>Complete all study modules</li>
                    <li>Pass practice exams with a score of 80% or higher</li>
                    <li>Register for the CTM exam</li>
                    <li>Pass the CTM exam</li>
                    <li>Submit application for certification</li>
                  </ol>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      <Card>
        <CardHeader>
          <CardTitle>Certification Benefits</CardTitle>
          <CardDescription>Why pursue CFA or CTM certification?</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="flex items-start space-x-2">
              <Award className="h-5 w-5 text-primary mt-0.5" />
              <div>
                <h4 className="font-semibold">Professional Recognition</h4>
                <p className="text-sm text-muted-foreground">Gain respect and credibility in the financial industry</p>
              </div>
            </div>
            <div className="flex items-start space-x-2">
              <BarChart className="h-5 w-5 text-primary mt-0.5" />
              <div>
                <h4 className="font-semibold">Career Advancement</h4>
                <p className="text-sm text-muted-foreground">Open doors to new opportunities and higher positions</p>
              </div>
            </div>
            <div className="flex items-start space-x-2">
              <BookOpen className="h-5 w-5 text-primary mt-0.5" />
              <div>
                <h4 className="font-semibold">In-depth Knowledge</h4>
                <p className="text-sm text-muted-foreground">Develop a comprehensive understanding of finance</p>
              </div>
            </div>
            <div className="flex items-start space-x-2">
              <DollarSign className="h-5 w-5 text-primary mt-0.5" />
              <div>
                <h4 className="font-semibold">Higher Earning Potential</h4>
                <p className="text-sm text-muted-foreground">Increase your value and earning capacity</p>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/chat/page.tsx">
import { GenerativeChat } from "@/components/generative-chat"
export default function ChatPage() {
  return (
    <div className="container max-w-2xl mx-auto py-8">
      <h1 className="text-2xl font-bold mb-4">Weather Chat</h1>
      <GenerativeChat />
    </div>
  )
}
</file>

<file path="app/dashboard/layout.tsx">
import React from 'react';
interface DashboardLayoutProps {
  children: React.ReactNode;
}
export default function DashboardLayout({ children }: DashboardLayoutProps) {
  return (
    <div className="min-h-screen bg-background">
      <header className="border-b">
        <div className="container mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <h1 className="text-xl font-bold">Trading Dashboard</h1>
            <nav className="flex items-center space-x-4">
              <a
                href="/dashboard"
                className="text-sm font-medium hover:text-primary"
              >
                Overview
              </a>
              <a
                href="/dashboard/watchlist"
                className="text-sm font-medium hover:text-primary"
              >
                Watchlist
              </a>
              <a
                href="/dashboard/portfolio"
                className="text-sm font-medium hover:text-primary"
              >
                Portfolio
              </a>
              <a
                href="/dashboard/settings"
                className="text-sm font-medium hover:text-primary"
              >
                Settings
              </a>
            </nav>
          </div>
        </div>
      </header>
      <main className="min-h-[calc(100vh-4rem)]">
        {children}
      </main>
      <footer className="border-t">
        <div className="container mx-auto px-4 py-3">
          <div className="flex items-center justify-between text-sm text-muted-foreground">
            <p>© 2024 Trading Dashboard. All rights reserved.</p>
            <div className="flex items-center space-x-4">
              <a href="/terms" className="hover:text-primary">
                Terms
              </a>
              <a href="/privacy" className="hover:text-primary">
                Privacy
              </a>
              <a href="/help" className="hover:text-primary">
                Help
              </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="app/dashboard/page.tsx">
import React from 'react';
import { SearchBar } from '@/components/search/SearchBar';
import { MarketDataGrid } from '@/components/market/MarketDataGrid';
import { TechnicalChart } from '@/components/technical/TechnicalChart';
import { NewsCard } from '@/components/news/NewsCard';
import { CompanyInfoCard } from '@/components/company/CompanyInfoCard';
const DEFAULT_SYMBOLS = ['AAPL', 'GOOGL', 'MSFT', 'AMZN'];
const REFRESH_INTERVAL = 5000; // 5 seconds
export default function DashboardPage() {
  const [selectedSymbol, setSelectedSymbol] = React.useState(DEFAULT_SYMBOLS[0]);
  const handleSymbolSelect = (result: any) => {
    setSelectedSymbol(result.ticker);
  };
  return (
    <div className="container mx-auto p-4 space-y-6">
      <div className="w-full max-w-xl mx-auto">
        <SearchBar onSelect={handleSymbolSelect} />
      </div>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 space-y-6">
          <MarketDataGrid
            symbols={DEFAULT_SYMBOLS}
            refreshInterval={REFRESH_INTERVAL}
          />
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <TechnicalChart
              symbol={selectedSymbol}
              indicator="SMA"
              period={20}
              timeRange={{
                startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                endDate: new Date().toISOString(),
              }}
              refreshInterval={REFRESH_INTERVAL}
            />
            <TechnicalChart
              symbol={selectedSymbol}
              indicator="RSI"
              period={14}
              timeRange={{
                startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                endDate: new Date().toISOString(),
              }}
              refreshInterval={REFRESH_INTERVAL}
            />
          </div>
        </div>
        <div className="space-y-6">
          <CompanyInfoCard
            symbol={selectedSymbol}
            refreshInterval={REFRESH_INTERVAL * 12} // 1 minute
          />
          <NewsCard
            symbols={[selectedSymbol]}
            limit={5}
            useStream={true}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/due-diligence/page.tsx">
import { DueDiligenceDashboard } from "@/components/due-diligence/due-diligence-dashboard"
export default function DueDiligencePage() {
  return (
    <div className="container mx-auto p-4">
      <DueDiligenceDashboard />
    </div>
  )
}
</file>

<file path="app/economic-calendar/page.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { DatePickerWithRange } from "@/components/ui/date-range-picker"
import { ScrollArea } from "@/components/ui/scroll-area"
import { getEconomicEvents } from "@/lib/api/economic-calendar"
import { useToast } from "@/components/ui/use-toast"
import { Loader2 } from "lucide-react"
import { DateRange } from "react-day-picker"
interface EconomicEvent {
  id: string
  date: string
  time: string
  currency: string
  event: string
  importance: "low" | "medium" | "high"
  actual: string
  forecast: string
  previous: string
}
export default function EconomicCalendarPage() {
  const [dateRange, setDateRange] = useState<DateRange | undefined>({
    from: new Date(),
    to: new Date(new Date().setMonth(new Date().getMonth() + 1))
  })
  const [importance, setImportance] = useState<string>("all")
  const [events, setEvents] = useState<EconomicEvent[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  const handleDateRangeChange = (range: DateRange | undefined) => {
    setDateRange(range)
  }
  useEffect(() => {
    const fetchEvents = async () => {
      if (!dateRange?.from || !dateRange?.to) return
      setIsLoading(true)
      try {
        const data = await getEconomicEvents({
          from: dateRange.from,
          to: dateRange.to,
          importance: importance === "all" ? undefined : importance,
        })
        setEvents(data)
      } catch (error) {
        console.error("Error fetching economic events:", error)
        toast({
          title: "Error",
          description: "Failed to load economic events. Please try again.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }
    fetchEvents()
  }, [dateRange, importance, toast])
  return (
    <div className="container mx-auto p-6">
      <Card>
        <CardHeader>
          <CardTitle>Economic Calendar</CardTitle>
        </CardHeader>
        <CardContent className="flex justify-between items-center">
          <DatePickerWithRange date={dateRange} onSelect={handleDateRangeChange} />
          <Select value={importance} onValueChange={setImportance}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Select importance" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Events</SelectItem>
              <SelectItem value="low">Low Impact</SelectItem>
              <SelectItem value="medium">Medium Impact</SelectItem>
              <SelectItem value="high">High Impact</SelectItem>
            </SelectContent>
          </Select>
        </CardContent>
      </Card>
      <Card className="mt-6">
        <CardContent className="p-0">
          <ScrollArea className="h-[600px] w-full">
            {isLoading ? (
              <div className="flex justify-center items-center h-full">
                <Loader2 className="h-8 w-8 animate-spin" />
              </div>
            ) : events.length > 0 ? (
              <table className="w-full">
                <thead className="sticky top-0 bg-background border-b">
                  <tr>
                    <th className="text-left p-4">Date/Time</th>
                    <th className="text-left p-4">Currency</th>
                    <th className="text-left p-4">Event</th>
                    <th className="text-center p-4">Importance</th>
                    <th className="text-right p-4">Actual</th>
                    <th className="text-right p-4">Forecast</th>
                    <th className="text-right p-4">Previous</th>
                  </tr>
                </thead>
                <tbody>
                  {events.map((event) => (
                    <tr key={event.id} className="border-b hover:bg-muted/50">
                      <td className="p-4">
                        <div>{new Date(event.date).toLocaleDateString()}</div>
                        <div className="text-sm text-muted-foreground">{event.time}</div>
                      </td>
                      <td className="p-4">{event.currency}</td>
                      <td className="p-4">{event.event}</td>
                      <td className="p-4 text-center">
                        <span
                          className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${
                            event.importance === "high"
                              ? "bg-destructive/20 text-destructive"
                              : event.importance === "medium"
                              ? "bg-yellow-500/20 text-yellow-700"
                              : "bg-green-500/20 text-green-700"
                          }`}
                        >
                          {event.importance}
                        </span>
                      </td>
                      <td className="p-4 text-right">{event.actual}</td>
                      <td className="p-4 text-right">{event.forecast}</td>
                      <td className="p-4 text-right">{event.previous}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            ) : (
              <div className="flex justify-center items-center h-full text-muted-foreground">
                No economic events found for the selected criteria
              </div>
            )}
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/economic-event-tracker/page.tsx">
import { EconomicEventTracker } from "@/components/economic-event-tracker/economic-event-tracker"
export default function EconomicEventTrackerPage() {
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">AI-Powered Economic Event Tracker</h1>
      <EconomicEventTracker />
    </div>
  )
}
</file>

<file path="app/financial-advisor/clients/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Search, Plus, MoreHorizontal } from "lucide-react"
const mockClients = [
  { id: 1, name: "John Doe", email: "john@example.com", aum: 500000, lastContact: "2023-06-01", status: "Active" },
  { id: 2, name: "Jane Smith", email: "jane@example.com", aum: 750000, lastContact: "2023-05-28", status: "Active" },
  { id: 3, name: "Bob Johnson", email: "bob@example.com", aum: 250000, lastContact: "2023-05-15", status: "Inactive" },
  { id: 4, name: "Alice Brown", email: "alice@example.com", aum: 1000000, lastContact: "2023-06-03", status: "Active" },
  {
    id: 5,
    name: "Charlie Davis",
    email: "charlie@example.com",
    aum: 350000,
    lastContact: "2023-05-20",
    status: "Active",
  },
]
export default function ClientManagementPage() {
  const [searchTerm, setSearchTerm] = useState("")
  const [clients, setClients] = useState(mockClients)
  const filteredClients = clients.filter(
    (client) =>
      client.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      client.email.toLowerCase().includes(searchTerm.toLowerCase()),
  )
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Client Management</h1>
      <Card>
        <CardHeader>
          <CardTitle>Client List</CardTitle>
          <CardDescription>Manage and view details of your clients</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex justify-between mb-4">
            <div className="flex items-center space-x-2">
              <Input
                placeholder="Search clients..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-[300px]"
              />
              <Button size="icon">
                <Search className="h-4 w-4" />
              </Button>
            </div>
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Add New Client
            </Button>
          </div>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Name</TableHead>
                <TableHead>Email</TableHead>
                <TableHead>AUM</TableHead>
                <TableHead>Last Contact</TableHead>
                <TableHead>Status</TableHead>
                <TableHead>Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredClients.map((client) => (
                <TableRow key={client.id}>
                  <TableCell>{client.name}</TableCell>
                  <TableCell>{client.email}</TableCell>
                  <TableCell>${client.aum.toLocaleString()}</TableCell>
                  <TableCell>{client.lastContact}</TableCell>
                  <TableCell>
                    <Badge variant={client.status === "Active" ? "default" : "secondary"}>{client.status}</Badge>
                  </TableCell>
                  <TableCell>
                    <Button variant="ghost" size="icon">
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/financial-advisor/dashboard/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { Users, DollarSign, PieChart, FileText, Briefcase, Calendar, AlertTriangle } from "lucide-react"
import Link from "next/link"
import { Badge } from "@/components/ui/badge" // Import Badge component
const mockData = [
  { name: "Jan", value: 4000 },
  { name: "Feb", value: 3000 },
  { name: "Mar", value: 5000 },
  { name: "Apr", value: 4500 },
  { name: "May", value: 6000 },
  { name: "Jun", value: 5500 },
]
export default function FinancialAdvisorDashboard() {
  const [activeClients, setActiveClients] = useState(50)
  const [totalAssets, setTotalAssets] = useState(10000000)
  const [revenueYTD, setRevenueYTD] = useState(500000)
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Financial Advisor Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Clients</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{activeClients}</div>
            <p className="text-xs text-muted-foreground">+2 from last month</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Assets Under Management</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">${(totalAssets / 1000000).toFixed(2)}M</div>
            <p className="text-xs text-muted-foreground">+5% from last month</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Revenue YTD</CardTitle>
            <PieChart className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">${(revenueYTD / 1000).toFixed(0)}K</div>
            <p className="text-xs text-muted-foreground">+12% from last year</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Pending Tasks</CardTitle>
            <FileText className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">7</div>
            <p className="text-xs text-muted-foreground">5 high priority</p>
          </CardContent>
        </Card>
      </div>
      <Card>
        <CardHeader>
          <CardTitle>Performance Overview</CardTitle>
          <CardDescription>Monthly revenue for the current year</CardDescription>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={mockData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Line type="monotone" dataKey="value" stroke="#8884d8" />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>
      <Tabs defaultValue="clients">
        <TabsList>
          <TabsTrigger value="clients">Client Overview</TabsTrigger>
          <TabsTrigger value="tasks">Pending Tasks</TabsTrigger>
          <TabsTrigger value="pitches">Recent Pitches</TabsTrigger>
        </TabsList>
        <TabsContent value="clients">
          <Card>
            <CardHeader>
              <CardTitle>Client Overview</CardTitle>
              <CardDescription>Quick summary of your client base</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span>High Net Worth Clients</span>
                  <span className="font-bold">12</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>Clients Needing Review</span>
                  <span className="font-bold">8</span>
                </div>
                <div className="flex items-center justify-between">
                  <span>New Clients This Month</span>
                  <span className="font-bold">3</span>
                </div>
              </div>
              <Button className="w-full mt-4">
                <Link href="/financial-advisor/clients">View All Clients</Link>
              </Button>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="tasks">
          <Card>
            <CardHeader>
              <CardTitle>Pending Tasks</CardTitle>
              <CardDescription>Tasks that require your attention</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <AlertTriangle className="h-4 w-4 text-red-500" />
                    <span>Review John Doe's portfolio</span>
                  </div>
                  <Badge>High Priority</Badge>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <Calendar className="h-4 w-4 text-blue-500" />
                    <span>Schedule meeting with new client</span>
                  </div>
                  <Badge variant="secondary">Medium Priority</Badge>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <FileText className="h-4 w-4 text-green-500" />
                    <span>Prepare quarterly report</span>
                  </div>
                  <Badge variant="outline">Low Priority</Badge>
                </div>
              </div>
              <Button className="w-full mt-4">View All Tasks</Button>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="pitches">
          <Card>
            <CardHeader>
              <CardTitle>Recent Pitches</CardTitle>
              <CardDescription>Your latest client presentations</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <Briefcase className="h-4 w-4 text-primary" />
                    <span>Retirement Planning for Smith Family</span>
                  </div>
                  <Badge>Successful</Badge>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <Briefcase className="h-4 w-4 text-primary" />
                    <span>Investment Strategy for XYZ Corp</span>
                  </div>
                  <Badge variant="secondary">Pending</Badge>
                </div>
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <Briefcase className="h-4 w-4 text-primary" />
                    <span>Estate Planning for Johnson Estate</span>
                  </div>
                  <Badge variant="outline">In Progress</Badge>
                </div>
              </div>
              <Button className="w-full mt-4">
                <Link href="/financial-advisor/pitch-builder">Create New Pitch</Link>
              </Button>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      <div className="flex justify-end space-x-4">
        <Button variant="outline">
          <Link href="/financial-advisor/clients">Manage Clients</Link>
        </Button>
        <Button>
          <Link href="/financial-advisor/pitch-builder">Create New Pitch</Link>
        </Button>
      </div>
    </div>
  )
}
</file>

<file path="app/financial-advisor/pitch-builder/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  Legend,
} from "recharts"
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8"]
export default function PitchBuilderPage() {
  const [clientName, setClientName] = useState("")
  const [pitchTitle, setPitchTitle] = useState("")
  const [investmentGoal, setInvestmentGoal] = useState("")
  const [riskTolerance, setRiskTolerance] = useState("")
  const [timeHorizon, setTimeHorizon] = useState("")
  const [portfolioAllocation, setPortfolioAllocation] = useState([
    { name: "Stocks", value: 60 },
    { name: "Bonds", value: 30 },
    { name: "Cash", value: 10 },
  ])
  const [projectedReturns, setProjectedReturns] = useState([
    { year: "2023", conservative: 20000, moderate: 22000, aggressive: 25000 },
    { year: "2024", conservative: 21000, moderate: 24000, aggressive: 28000 },
    { year: "2025", conservative: 22000, moderate: 26000, aggressive: 32000 },
    { year: "2026", conservative: 23000, moderate: 28000, aggressive: 36000 },
    { year: "2027", conservative: 24000, moderate: 30000, aggressive: 40000 },
  ])
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    // Handle pitch submission logic here
    console.log("Pitch submitted")
  }
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Pitch Builder</h1>
      <form onSubmit={handleSubmit} className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Client Information</CardTitle>
            <CardDescription>Enter the basic details for your pitch</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <label htmlFor="clientName" className="text-sm font-medium">
                  Client Name
                </label>
                <Input
                  id="clientName"
                  value={clientName}
                  onChange={(e) => setClientName(e.target.value)}
                  placeholder="Enter client name"
                />
              </div>
              <div className="space-y-2">
                <label htmlFor="pitchTitle" className="text-sm font-medium">
                  Pitch Title
                </label>
                <Input
                  id="pitchTitle"
                  value={pitchTitle}
                  onChange={(e) => setPitchTitle(e.target.value)}
                  placeholder="Enter pitch title"
                />
              </div>
            </div>
            <div className="space-y-2">
              <label htmlFor="investmentGoal" className="text-sm font-medium">
                Investment Goal
              </label>
              <Textarea
                id="investmentGoal"
                value={investmentGoal}
                onChange={(e) => setInvestmentGoal(e.target.value)}
                placeholder="Describe the client's investment goals"
              />
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <label htmlFor="riskTolerance" className="text-sm font-medium">
                  Risk Tolerance
                </label>
                <Select value={riskTolerance} onValueChange={setRiskTolerance}>
                  <SelectTrigger id="riskTolerance">
                    <SelectValue placeholder="Select risk tolerance" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="conservative">Conservative</SelectItem>
                    <SelectItem value="moderate">Moderate</SelectItem>
                    <SelectItem value="aggressive">Aggressive</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <label htmlFor="timeHorizon" className="text-sm font-medium">
                  Time Horizon
                </label>
                <Select value={timeHorizon} onValueChange={setTimeHorizon}>
                  <SelectTrigger id="timeHorizon">
                    <SelectValue placeholder="Select time horizon" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="short-term">Short-term (0-3 years)</SelectItem>
                    <SelectItem value="medium-term">Medium-term (3-7 years)</SelectItem>
                    <SelectItem value="long-term">Long-term (7+ years)</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Portfolio Allocation</CardTitle>
            <CardDescription>Visualize the proposed asset allocation</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={portfolioAllocation}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  >
                    {portfolioAllocation.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Projected Returns</CardTitle>
            <CardDescription>Visualize potential investment outcomes</CardDescription>
          </CardHeader>
          <CardContent>
            <Tabs defaultValue="chart">
              <TabsList>
                <TabsTrigger value="chart">Chart</TabsTrigger>
                <TabsTrigger value="table">Table</TabsTrigger>
              </TabsList>
              <TabsContent value="chart">
                <div className="h-[300px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={projectedReturns}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="year" />
                      <YAxis />
                      <Tooltip />
                      <Legend />
                      <Line type="monotone" dataKey="conservative" stroke="#8884d8" />
                      <Line type="monotone" dataKey="moderate" stroke="#82ca9d" />
                      <Line type="monotone" dataKey="aggressive" stroke="#ffc658" />
                    </LineChart>
                  </ResponsiveContainer>
                </div>
              </TabsContent>
              <TabsContent value="table">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead>
                      <tr>
                        <th className="text-left">Year</th>
                        <th className="text-right">Conservative</th>
                        <th className="text-right">Moderate</th>
                        <th className="text-right">Aggressive</th>
                      </tr>
                    </thead>
                    <tbody>
                      {projectedReturns.map((row) => (
                        <tr key={row.year}>
                          <td>{row.year}</td>
                          <td className="text-right">${row.conservative.toLocaleString()}</td>
                          <td className="text-right">${row.moderate.toLocaleString()}</td>
                          <td className="text-right">${row.aggressive.toLocaleString()}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
        <div className="flex justify-end">
          <Button type="submit">Generate Pitch</Button>
        </div>
      </form>
    </div>
  )
}
</file>

<file path="app/financial-advisor/page.tsx">
import { redirect } from "next/navigation"
export default function FinancialAdvisorPage() {
  redirect("/financial-advisor/dashboard")
}
</file>

<file path="app/financial-heatmap/page.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { getHeatmapData } from "@/lib/api/financial-heatmap"
import { useToast } from "@/components/ui/use-toast"
import { Loader2 } from "lucide-react"
interface HeatmapData {
  symbol: string
  name: string
  sector: string
  value: number
  change: number
}
export default function FinancialHeatmapPage() {
  const [selectedMetric, setSelectedMetric] = useState<string>("price")
  const [selectedTimeframe, setSelectedTimeframe] = useState<string>("1d")
  const [heatmapData, setHeatmapData] = useState<HeatmapData[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true)
      try {
        const data = await getHeatmapData(selectedMetric, selectedTimeframe)
        setHeatmapData(data)
      } catch (error) {
        console.error("Error fetching heatmap data:", error)
        toast({
          title: "Error",
          description: "Failed to load heatmap data. Please try again.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }
    fetchData()
  }, [selectedMetric, selectedTimeframe, toast])
  return (
    <div className="container mx-auto p-6">
      <Card>
        <CardHeader>
          <CardTitle>Market Heatmap</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex justify-between items-center mb-6">
            <Select value={selectedMetric} onValueChange={setSelectedMetric}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Select metric" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="price">Price Change</SelectItem>
                <SelectItem value="volume">Volume</SelectItem>
                <SelectItem value="volatility">Volatility</SelectItem>
                <SelectItem value="rsi">RSI</SelectItem>
              </SelectContent>
            </Select>
            <Select value={selectedTimeframe} onValueChange={setSelectedTimeframe}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Select timeframe" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1d">1 Day</SelectItem>
                <SelectItem value="1w">1 Week</SelectItem>
                <SelectItem value="1m">1 Month</SelectItem>
                <SelectItem value="3m">3 Months</SelectItem>
                <SelectItem value="1y">1 Year</SelectItem>
              </SelectContent>
            </Select>
          </div>
          {isLoading ? (
            <div className="flex justify-center items-center h-[500px]">
              <Loader2 className="h-8 w-8 animate-spin" />
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {heatmapData.map((item) => (
                <Card key={item.symbol}>
                  <CardContent className="p-4">
                    <div className="flex justify-between items-start">
                      <div>
                        <div className="font-medium">{item.name}</div>
                        <div className="text-sm text-muted-foreground">{item.symbol}</div>
                        <div className="text-sm text-muted-foreground">{item.sector}</div>
                      </div>
                      <div
                        className={`text-lg font-bold ${
                          item.change >= 0 ? "text-green-600" : "text-red-600"
                        }`}
                      >
                        {item.change >= 0 ? "+" : ""}
                        {item.change.toFixed(2)}%
                      </div>
                    </div>
                    <div
                      className="mt-2 h-2 rounded-full"
                      style={{
                        background: `linear-gradient(90deg, ${
                          item.value >= 0 ? "rgb(34 197 94)" : "rgb(239 68 68)"
                        } ${Math.abs(item.value)}%, transparent ${Math.abs(item.value)}%)`,
                      }}
                    />
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/help/page.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
export default function HelpPage() {
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Help Center</h1>
      <Card>
        <CardHeader>
          <CardTitle>Frequently Asked Questions</CardTitle>
          <CardDescription>Find answers to common questions about using the platform</CardDescription>
        </CardHeader>
        <CardContent>
          <Accordion type="single" collapsible className="w-full">
            <AccordionItem value="item-1">
              <AccordionTrigger>How do I create a new watchlist?</AccordionTrigger>
              <AccordionContent>
                To create a new watchlist, navigate to the Watchlist page and click on the "Create New Watchlist"
                button. Enter a name for your watchlist and start adding stocks by their ticker symbols.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-2">
              <AccordionTrigger>How can I customize my dashboard?</AccordionTrigger>
              <AccordionContent>
                You can customize your dashboard by clicking on the settings icon in the top right corner of the
                dashboard. From there, you can add, remove, or rearrange widgets to suit your preferences.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-3">
              <AccordionTrigger>How do I access the Business Major program?</AccordionTrigger>
              <AccordionContent>
                To access the Business Major program, click on the "Business Major" link in the sidebar. From there, you
                can view the program overview, course catalog, and track your progress through the asynchronous learning
                modules.
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-4">
              <AccordionTrigger>How can I use the Financial Advisor tools?</AccordionTrigger>
              <AccordionContent>
                The Financial Advisor tools can be accessed by clicking on the "Financial Advisor" link in the sidebar.
                This section includes features like client management, pitch builder, and visualization tools to help
                you create compelling presentations for your clients.
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Contact Support</CardTitle>
          <CardDescription>Need additional help? Reach out to our support team</CardDescription>
        </CardHeader>
        <CardContent>
          <p>Email: support@example.com</p>
          <p>Phone: +1 (555) 123-4567</p>
          <p>Support Hours: Monday - Friday, 9 AM - 5 PM EST</p>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/investment-banking/page.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from "recharts"
import { BookOpen, FileText, PieChartIcon, BarChart2 } from "lucide-react"
const ibAreas = [
  { name: "M&A Advisory", value: 30, color: "#8884d8" },
  { name: "Capital Markets", value: 25, color: "#82ca9d" },
  { name: "Restructuring", value: 15, color: "#ffc658" },
  { name: "Private Placements", value: 20, color: "#ff8042" },
  { name: "Industry Coverage", value: 10, color: "#0088FE" },
]
const tools = [
  { name: "Financial Modeling", description: "Build complex financial models for valuation and analysis" },
  { name: "Pitch Books", description: "Create compelling presentations for client pitches" },
  { name: "Due Diligence", description: "Conduct thorough research and analysis on target companies" },
  { name: "Deal Structuring", description: "Design optimal transaction structures for various deals" },
  { name: "Market Research", description: "Analyze industry trends and market conditions" },
]
const caseStudies = [
  {
    title: "Tech Merger: SoftCo Acquires CloudTech",
    type: "M&A",
    description: "A strategic acquisition in the software industry, valued at $5 billion.",
    keyPoints: [
      "Synergy analysis revealed $500M in potential cost savings",
      "Deal structure: 60% cash, 40% stock",
      "Regulatory challenges in EU markets",
    ],
  },
  {
    title: "GreenEnergy IPO",
    type: "Capital Markets",
    description: "Successful IPO of a renewable energy company, raising $2 billion.",
    keyPoints: [
      "Oversubscribed by 3x, indicating strong market demand",
      "Innovative green bond component included",
      "Roadshow across 12 major cities",
    ],
  },
  {
    title: "RetailCo Restructuring",
    type: "Restructuring",
    description: "Comprehensive restructuring of a struggling retail chain.",
    keyPoints: [
      "Debt reduction of $1.5 billion through negotiation",
      "Store footprint optimized, closing 30% of locations",
      "New management team installed with turnaround expertise",
    ],
  },
]
export default function InvestmentBankingPage() {
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Investment Banking Resources</h1>
      <Tabs defaultValue="overview" className="space-y-4">
        <TabsList className="grid w-full grid-cols-1 md:grid-cols-4">
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="tools">Tools & Skills</TabsTrigger>
          <TabsTrigger value="caseStudies">Case Studies</TabsTrigger>
          <TabsTrigger value="resources">Additional Resources</TabsTrigger>
        </TabsList>
        <TabsContent value="overview">
          <Card>
            <CardHeader>
              <CardTitle>Investment Banking Overview</CardTitle>
              <CardDescription>Key areas and their importance in the industry</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h3 className="text-lg font-semibold mb-2">Key Areas of Investment Banking</h3>
                  <ul className="space-y-2">
                    {ibAreas.map((area) => (
                      <li key={area.name} className="flex items-center">
                        <Badge variant="outline" style={{ backgroundColor: `${area.color}20`, color: area.color }}>
                          {area.value}%
                        </Badge>
                        <span className="ml-2">{area.name}</span>
                      </li>
                    ))}
                  </ul>
                </div>
                <div className="h-[300px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <PieChart>
                      <Pie
                        data={ibAreas}
                        cx="50%"
                        cy="50%"
                        labelLine={false}
                        outerRadius={80}
                        fill="#8884d8"
                        dataKey="value"
                        label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                      >
                        {ibAreas.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.color} />
                        ))}
                      </Pie>
                      <Tooltip />
                    </PieChart>
                  </ResponsiveContainer>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Industry Overview</h3>
                <p>
                  Investment banking plays a crucial role in the financial world, facilitating large-scale financial
                  transactions and providing strategic advice to corporations, institutions, and governments. The
                  industry is known for its fast-paced environment, high-stakes deals, and significant impact on global
                  markets.
                </p>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="tools">
          <Card>
            <CardHeader>
              <CardTitle>Essential Tools and Skills</CardTitle>
              <CardDescription>Key competencies for success in investment banking</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {tools.map((tool, index) => (
                  <Card key={index}>
                    <CardHeader>
                      <CardTitle className="text-lg">{tool.name}</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <p>{tool.description}</p>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="caseStudies">
          <Card>
            <CardHeader>
              <CardTitle>Case Studies</CardTitle>
              <CardDescription>Real-world examples of investment banking deals</CardDescription>
            </CardHeader>
            <CardContent>
              <Accordion type="single" collapsible className="w-full">
                {caseStudies.map((study, index) => (
                  <AccordionItem value={`item-${index}`} key={index}>
                    <AccordionTrigger>
                      <div className="flex items-center">
                        <Badge className="mr-2">{study.type}</Badge>
                        {study.title}
                      </div>
                    </AccordionTrigger>
                    <AccordionContent>
                      <p className="mb-2">{study.description}</p>
                      <ul className="list-disc pl-5">
                        {study.keyPoints.map((point, idx) => (
                          <li key={idx}>{point}</li>
                        ))}
                      </ul>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="resources">
          <Card>
            <CardHeader>
              <CardTitle>Additional Resources</CardTitle>
              <CardDescription>Further learning materials and industry insights</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                  <BookOpen className="h-6 w-6 mb-2" />
                  <span>Industry Reports</span>
                </Button>
                <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                  <FileText className="h-6 w-6 mb-2" />
                  <span>Deal Databases</span>
                </Button>
                <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                  <PieChartIcon className="h-6 w-6 mb-2" />
                  <span>Valuation Guides</span>
                </Button>
                <Button variant="outline" className="h-20 flex flex-col items-center justify-center">
                  <BarChart2 className="h-6 w-6 mb-2" />
                  <span>Market Analysis Tools</span>
                </Button>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  )
}
</file>

<file path="app/market-overview/page.tsx">
import { MarketOverview } from "@/components/market-overview"
import { LiveMarketData } from "@/components/live-market-data"
import { MarketBreadth } from "@/components/market-breadth"
import { TradingVolume } from "@/components/trading-volume"
import { SupportResistanceLevels } from "@/components/support-resistance-levels"
import { AIInsights } from "@/components/ai-insights"
export default function MarketOverviewPage() {
  return (
    <div className="container mx-auto p-4 space-y-4">
      <h1 className="text-3xl font-bold mb-6">Market Overview</h1>
      <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
        <MarketOverview />
        <LiveMarketData />
        <MarketBreadth />
        <TradingVolume />
        <SupportResistanceLevels />
        <AIInsights />
      </div>
    </div>
  )
}
</file>

<file path="app/portfolio/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  BarChart,
  Bar,
} from "recharts"
import { DollarSign, TrendingUp, TrendingDown, AlertTriangle, Plus } from "lucide-react"
// Mock data
const portfolioOverview = {
  totalValue: 125000,
  cashBalance: 10000,
  performance: {
    day: 2.5,
    week: -1.2,
    month: 5.8,
    year: 12.3,
  },
}
const assetAllocation = [
  { name: "Stocks", value: 70000 },
  { name: "Bonds", value: 30000 },
  { name: "Real Estate", value: 15000 },
  { name: "Crypto", value: 5000 },
  { name: "Cash", value: 5000 },
]
const holdings = [
  {
    symbol: "AAPL",
    name: "Apple Inc.",
    quantity: 50,
    averagePrice: 150,
    currentPrice: 175,
    value: 8750,
    change: 16.67,
  },
  {
    symbol: "GOOGL",
    name: "Alphabet Inc.",
    quantity: 20,
    averagePrice: 2000,
    currentPrice: 2200,
    value: 44000,
    change: 10,
  },
  {
    symbol: "MSFT",
    name: "Microsoft Corporation",
    quantity: 30,
    averagePrice: 220,
    currentPrice: 280,
    value: 8400,
    change: 27.27,
  },
  {
    symbol: "AMZN",
    name: "Amazon.com Inc.",
    quantity: 15,
    averagePrice: 3000,
    currentPrice: 3200,
    value: 48000,
    change: 6.67,
  },
  {
    symbol: "TSLA",
    name: "Tesla, Inc.",
    quantity: 25,
    averagePrice: 600,
    currentPrice: 650,
    value: 16250,
    change: 8.33,
  },
]
const performanceData = [
  { date: "2023-01-01", value: 100000 },
  { date: "2023-02-01", value: 102000 },
  { date: "2023-03-01", value: 105000 },
  { date: "2023-04-01", value: 103000 },
  { date: "2023-05-01", value: 108000 },
  { date: "2023-06-01", value: 112000 },
  { date: "2023-07-01", value: 125000 },
]
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8"]
export default function PortfolioPage() {
  const [timeframe, setTimeframe] = useState("1Y")
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Portfolio</h1>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Value</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">${portfolioOverview.totalValue.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              +${(portfolioOverview.totalValue - portfolioOverview.cashBalance).toLocaleString()} since last month
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Cash Balance</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">${portfolioOverview.cashBalance.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">Available for trading</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Day Change</CardTitle>
            {portfolioOverview.performance.day >= 0 ? (
              <TrendingUp className="h-4 w-4 text-green-500" />
            ) : (
              <TrendingDown className="h-4 w-4 text-red-500" />
            )}
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {portfolioOverview.performance.day >= 0 ? "+" : ""}
              {portfolioOverview.performance.day}%
            </div>
            <p className="text-xs text-muted-foreground">
              ${((portfolioOverview.totalValue * portfolioOverview.performance.day) / 100).toLocaleString()}
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">YTD Return</CardTitle>
            {portfolioOverview.performance.year >= 0 ? (
              <TrendingUp className="h-4 w-4 text-green-500" />
            ) : (
              <TrendingDown className="h-4 w-4 text-red-500" />
            )}
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {portfolioOverview.performance.year >= 0 ? "+" : ""}
              {portfolioOverview.performance.year}%
            </div>
            <p className="text-xs text-muted-foreground">
              ${((portfolioOverview.totalValue * portfolioOverview.performance.year) / 100).toLocaleString()}
            </p>
          </CardContent>
        </Card>
      </div>
      <div className="grid gap-6 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Asset Allocation</CardTitle>
            <CardDescription>Breakdown of your portfolio by asset class</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={assetAllocation}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  >
                    {assetAllocation.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Portfolio Performance</CardTitle>
            <CardDescription>Historical performance of your portfolio</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex justify-end space-x-2 mb-4">
              <Button variant={timeframe === "1M" ? "secondary" : "outline"} onClick={() => setTimeframe("1M")}>
                1M
              </Button>
              <Button variant={timeframe === "3M" ? "secondary" : "outline"} onClick={() => setTimeframe("3M")}>
                3M
              </Button>
              <Button variant={timeframe === "6M" ? "secondary" : "outline"} onClick={() => setTimeframe("6M")}>
                6M
              </Button>
              <Button variant={timeframe === "1Y" ? "secondary" : "outline"} onClick={() => setTimeframe("1Y")}>
                1Y
              </Button>
              <Button variant={timeframe === "ALL" ? "secondary" : "outline"} onClick={() => setTimeframe("ALL")}>
                ALL
              </Button>
            </div>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={performanceData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Line type="monotone" dataKey="value" stroke="#8884d8" />
                </LineChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>
      </div>
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle>Holdings</CardTitle>
              <CardDescription>Your current investment positions</CardDescription>
            </div>
            <Button>
              <Plus className="mr-2 h-4 w-4" /> Add Position
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Symbol</TableHead>
                <TableHead>Name</TableHead>
                <TableHead className="text-right">Quantity</TableHead>
                <TableHead className="text-right">Avg Price</TableHead>
                <TableHead className="text-right">Current Price</TableHead>
                <TableHead className="text-right">Value</TableHead>
                <TableHead className="text-right">Change</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {holdings.map((holding) => (
                <TableRow key={holding.symbol}>
                  <TableCell className="font-medium">{holding.symbol}</TableCell>
                  <TableCell>{holding.name}</TableCell>
                  <TableCell className="text-right">{holding.quantity}</TableCell>
                  <TableCell className="text-right">${holding.averagePrice.toFixed(2)}</TableCell>
                  <TableCell className="text-right">${holding.currentPrice.toFixed(2)}</TableCell>
                  <TableCell className="text-right">${holding.value.toLocaleString()}</TableCell>
                  <TableCell className="text-right">
                    <Badge variant={holding.change >= 0 ? "default" : "destructive"}>
                      {holding.change >= 0 ? "+" : ""}
                      {holding.change.toFixed(2)}%
                    </Badge>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Portfolio Analysis</CardTitle>
          <CardDescription>Key metrics and insights about your portfolio</CardDescription>
        </CardHeader>
        <CardContent>
          <Tabs defaultValue="performance" className="space-y-4">
            <TabsList>
              <TabsTrigger value="performance">Performance</TabsTrigger>
              <TabsTrigger value="risk">Risk</TabsTrigger>
              <TabsTrigger value="diversification">Diversification</TabsTrigger>
            </TabsList>
            <TabsContent value="performance">
              <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Total Return</CardTitle>
                    <TrendingUp className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">+15.8%</div>
                    <p className="text-xs text-muted-foreground">Since inception</p>
                  </CardContent>
                </Card>
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Annualized Return</CardTitle>
                    <TrendingUp className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">+8.2%</div>
                    <p className="text-xs text-muted-foreground">Per year on average</p>
                  </CardContent>
                </Card>
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Dividend Yield</CardTitle>
                    <DollarSign className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">2.3%</div>
                    <p className="text-xs text-muted-foreground">Annual yield based on current prices</p>
                  </CardContent>
                </Card>
              </div>
            </TabsContent>
            <TabsContent value="risk">
              <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Beta</CardTitle>
                    <AlertTriangle className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">1.2</div>
                    <p className="text-xs text-muted-foreground">Relative to S&P 500</p>
                  </CardContent>
                </Card>
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Shar pe Ratio</CardTitle>
                    <TrendingUp className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">0.8</div>
                    <p className="text-xs text-muted-foreground">Risk-adjusted return</p>
                  </CardContent>
                </Card>
                <Card>
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">Max Drawdown</CardTitle>
                    <TrendingDown className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">-15.3%</div>
                    <p className="text-xs text-muted-foreground">Largest peak-to-trough decline</p>
                  </CardContent>
                </Card>
              </div>
            </TabsContent>
            <TabsContent value="diversification">
              <div className="space-y-4">
                <div className="grid gap-4 md:grid-cols-2">
                  <Card>
                    <CardHeader>
                      <CardTitle className="text-sm font-medium">Sector Allocation</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="h-[200px]">
                        <ResponsiveContainer width="100%" height="100%">
                          <BarChart
                            data={[
                              { name: "Technology", value: 35 },
                              { name: "Healthcare", value: 20 },
                              { name: "Financials", value: 15 },
                              { name: "Consumer", value: 10 },
                              { name: "Energy", value: 10 },
                              { name: "Others", value: 10 },
                            ]}
                          >
                            <CartesianGrid strokeDasharray="3 3" />
                            <XAxis dataKey="name" />
                            <YAxis />
                            <Tooltip />
                            <Bar dataKey="value" fill="#8884d8" />
                          </BarChart>
                        </ResponsiveContainer>
                      </div>
                    </CardContent>
                  </Card>
                  <Card>
                    <CardHeader>
                      <CardTitle className="text-sm font-medium">Geographic Exposure</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="h-[200px]">
                        <ResponsiveContainer width="100%" height="100%">
                          <PieChart>
                            <Pie
                              data={[
                                { name: "North America", value: 60 },
                                { name: "Europe", value: 20 },
                                { name: "Asia", value: 15 },
                                { name: "Other", value: 5 },
                              ]}
                              cx="50%"
                              cy="50%"
                              outerRadius={80}
                              fill="#8884d8"
                              dataKey="value"
                              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                            >
                              {COLORS.map((color, index) => (
                                <Cell key={`cell-${index}`} fill={color} />
                              ))}
                            </Pie>
                            <Tooltip />
                          </PieChart>
                        </ResponsiveContainer>
                      </div>
                    </CardContent>
                  </Card>
                </div>
                <Card>
                  <CardHeader>
                    <CardTitle className="text-sm font-medium">Correlation Matrix</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground mb-2">
                      Correlation between your top holdings (1 = perfect correlation, -1 = perfect negative correlation)
                    </p>
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Symbol</TableHead>
                          {holdings.slice(0, 5).map((holding) => (
                            <TableHead key={holding.symbol} className="text-right">
                              {holding.symbol}
                            </TableHead>
                          ))}
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {holdings.slice(0, 5).map((holding, i) => (
                          <TableRow key={holding.symbol}>
                            <TableCell className="font-medium">{holding.symbol}</TableCell>
                            {holdings.slice(0, 5).map((_, j) => (
                              <TableCell key={j} className="text-right">
                                {i === j ? "1.00" : (Math.random() * 2 - 1).toFixed(2)}
                              </TableCell>
                            ))}
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </CardContent>
                </Card>
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/portfolio-analytics/page.tsx">
import { PortfolioAnalyticsDashboard } from "@/components/portfolio-analytics/portfolio-analytics-dashboard"
export default function PortfolioAnalyticsPage() {
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">AI-Powered Portfolio Analytics</h1>
      <PortfolioAnalyticsDashboard />
    </div>
  )
}
</file>

<file path="app/portfolio-optimizer/page.tsx">
import { PortfolioOptimizerDashboard } from "@/components/portfolio-optimizer/portfolio-optimizer-dashboard"
export default function PortfolioOptimizerPage() {
  return (
    <div className="container mx-auto p-4">
      <PortfolioOptimizerDashboard />
    </div>
  )
}
</file>

<file path="app/settings/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Switch } from "@/components/ui/switch"
import { Label } from "@/components/ui/label"
import { Button } from "@/components/ui/button"
import { useTheme } from "next-themes"
export default function SettingsPage() {
  const { setTheme, theme } = useTheme()
  const [notifications, setNotifications] = useState(true)
  const [autoRefresh, setAutoRefresh] = useState(true)
  return (
    <div className="container mx-auto p-6 space-y-6">
      <h1 className="text-3xl font-bold mb-6">Settings</h1>
      <Card>
        <CardHeader>
          <CardTitle>Appearance</CardTitle>
          <CardDescription>Customize the look and feel of the application</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <Label htmlFor="theme-toggle">Dark Mode</Label>
            <Switch
              id="theme-toggle"
              checked={theme === "dark"}
              onCheckedChange={(checked) => setTheme(checked ? "dark" : "light")}
            />
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Notifications</CardTitle>
          <CardDescription>Manage your notification preferences</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <Label htmlFor="notifications-toggle">Enable Notifications</Label>
            <Switch id="notifications-toggle" checked={notifications} onCheckedChange={setNotifications} />
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Data Refresh</CardTitle>
          <CardDescription>Configure data update settings</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <Label htmlFor="auto-refresh-toggle">Auto-refresh Data</Label>
            <Switch id="auto-refresh-toggle" checked={autoRefresh} onCheckedChange={setAutoRefresh} />
          </div>
        </CardContent>
      </Card>
      <div className="flex justify-end">
        <Button>Save Changes</Button>
      </div>
    </div>
  )
}
</file>

<file path="app/stock-analysis/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import {
  Search,
  TrendingUp,
  TrendingDown,
  BarChart2,
  Target,
  Shield,
  AlertTriangle,
  DollarSign,
  Users,
  Building,
} from "lucide-react"
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  AreaChart,
  Area,
  BarChart,
  Bar,
  Legend,
} from "recharts"
// Mock data for demonstration
const mockStockData = {
  symbol: "AAPL",
  name: "Apple Inc.",
  price: 185.92,
  change: 2.45,
  changePercent: 1.34,
  marketCap: "3.02T",
  peRatio: 28.5,
  beta: 1.2,
  alphaSpreads: {
    valueSpread: 15.2,
    growthSpread: 8.4,
    qualitySpread: 12.7,
    momentumSpread: 6.8,
  },
  historicalPrices: Array.from({ length: 30 }, (_, i) => ({
    date: new Date(Date.now() - (30 - i) * 24 * 60 * 60 * 1000).toISOString().split("T")[0],
    price: 180 + Math.random() * 20,
    volume: Math.floor(Math.random() * 1000000),
  })),
  financials: {
    revenue: [
      { year: "2020", value: 274.5 },
      { year: "2021", value: 365.8 },
      { year: "2022", value: 394.3 },
      { year: "2023", value: 383.9 },
    ],
    margins: {
      gross: 43.5,
      operating: 30.2,
      net: 25.8,
    },
  },
}
const investmentThesis = [
  {
    title: "Market Leadership",
    description: "Dominant position in premium consumer electronics with strong brand loyalty",
    sentiment: "positive",
  },
  {
    title: "Services Growth",
    description: "Expanding high-margin services business with recurring revenue",
    sentiment: "positive",
  },
  {
    title: "Innovation Pipeline",
    description: "Strong R&D investments in AI, AR/VR, and autonomous systems",
    sentiment: "positive",
  },
  {
    title: "Competition Risk",
    description: "Increasing competition in key markets and product categories",
    sentiment: "negative",
  },
]
export default function StockAnalysisPage() {
  const [stockSymbol, setStockSymbol] = useState("")
  const [stockData, setStockData] = useState(mockStockData)
  const handleSearch = () => {
    // In a real application, this would fetch data from an API
    console.log("Searching for:", stockSymbol)
    // For now, we'll just update the stock symbol in our mock data
    setStockData({ ...mockStockData, symbol: stockSymbol })
  }
  return (
    <div className="container mx-auto p-6 space-y-6">
      <div className="flex items-center space-x-4">
        <div className="flex-1">
          <Input
            placeholder="Enter stock symbol (e.g., AAPL)"
            value={stockSymbol}
            onChange={(e) => setStockSymbol(e.target.value.toUpperCase())}
            className="max-w-sm"
          />
        </div>
        <Button onClick={handleSearch}>
          <Search className="h-4 w-4 mr-2" />
          Analyze
        </Button>
      </div>
      {stockData && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-start">
                  <div>
                    <CardTitle className="text-2xl">{stockData.symbol}</CardTitle>
                    <CardDescription>{stockData.name}</CardDescription>
                  </div>
                  <div className="text-right">
                    <div className="text-2xl font-bold">${stockData.price}</div>
                    <Badge variant={stockData.change >= 0 ? "default" : "destructive"}>
                      {stockData.change >= 0 ? (
                        <TrendingUp className="h-4 w-4 mr-1" />
                      ) : (
                        <TrendingDown className="h-4 w-4 mr-1" />
                      )}
                      {stockData.change > 0 ? "+" : ""}
                      {stockData.change} ({stockData.changePercent}%)
                    </Badge>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <div className="h-[200px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <AreaChart data={stockData.historicalPrices}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="date" />
                      <YAxis domain={["auto", "auto"]} />
                      <Tooltip />
                      <Area type="monotone" dataKey="price" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} />
                    </AreaChart>
                  </ResponsiveContainer>
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <CardTitle>Alpha Spread Analysis</CardTitle>
                <CardDescription>Relative value metrics compared to peers</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {Object.entries(stockData.alphaSpreads).map(([key, value]) => (
                    <div key={key}>
                      <div className="flex justify-between mb-1">
                        <span className="text-sm font-medium capitalize">{key.replace("Spread", "")}</span>
                        <span className="text-sm font-medium">{value}%</span>
                      </div>
                      <div className="h-2 bg-secondary rounded-full overflow-hidden">
                        <div className="h-full bg-primary" style={{ width: `${Math.min(Math.max(value, 0), 100)}%` }} />
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </div>
          <Tabs defaultValue="thesis" className="space-y-4">
            <TabsList>
              <TabsTrigger value="thesis">Investment Thesis</TabsTrigger>
              <TabsTrigger value="financials">Financials</TabsTrigger>
              <TabsTrigger value="risks">Risk Analysis</TabsTrigger>
              <TabsTrigger value="valuation">Valuation</TabsTrigger>
            </TabsList>
            <TabsContent value="thesis">
              <Card>
                <CardHeader>
                  <CardTitle>Investment Thesis</CardTitle>
                  <CardDescription>Key investment considerations and analysis</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid gap-4 md:grid-cols-2">
                    {investmentThesis.map((point, index) => (
                      <Card key={index}>
                        <CardContent className="pt-6">
                          <div className="flex items-start space-x-2">
                            {point.sentiment === "positive" ? (
                              <Target className="h-5 w-5 text-green-500" />
                            ) : (
                              <AlertTriangle className="h-5 w-5 text-red-500" />
                            )}
                            <div>
                              <h3 className="font-semibold">{point.title}</h3>
                              <p className="text-sm text-muted-foreground">{point.description}</p>
                            </div>
                          </div>
                        </CardContent>
                      </Card>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
            <TabsContent value="financials">
              <Card>
                <CardHeader>
                  <CardTitle>Financial Performance</CardTitle>
                  <CardDescription>Revenue growth and margin analysis</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid gap-6 md:grid-cols-2">
                    <div>
                      <h3 className="font-semibold mb-4">Revenue Growth</h3>
                      <div className="h-[200px]">
                        <ResponsiveContainer width="100%" height="100%">
                          <LineChart data={stockData.financials.revenue}>
                            <CartesianGrid strokeDasharray="3 3" />
                            <XAxis dataKey="year" />
                            <YAxis />
                            <Tooltip />
                            <Line type="monotone" dataKey="value" stroke="#8884d8" />
                          </LineChart>
                        </ResponsiveContainer>
                      </div>
                    </div>
                    <div>
                      <h3 className="font-semibold mb-4">Margin Analysis</h3>
                      <div className="space-y-4">
                        {Object.entries(stockData.financials.margins).map(([key, value]) => (
                          <div key={key}>
                            <div className="flex justify-between mb-1">
                              <span className="text-sm font-medium capitalize">{key} Margin</span>
                              <span className="text-sm font-medium">{value}%</span>
                            </div>
                            <div className="h-2 bg-secondary rounded-full overflow-hidden">
                              <div className="h-full bg-primary" style={{ width: `${value}%` }} />
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
            <TabsContent value="risks">
              <Card>
                <CardHeader>
                  <CardTitle>Risk Analysis</CardTitle>
                  <CardDescription>Key risk factors and metrics</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid gap-4 md:grid-cols-3">
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <BarChart2 className="h-8 w-8 mx-auto mb-2 text-blue-500" />
                          <div className="text-2xl font-bold">{stockData.beta}</div>
                          <div className="text-sm text-muted-foreground">Beta</div>
                        </div>
                      </CardContent>
                    </Card>
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <Target className="h-8 w-8 mx-auto mb-2 text-green-500" />
                          <div className="text-2xl font-bold">{stockData.peRatio}</div>
                          <div className="text-sm text-muted-foreground">P/E Ratio</div>
                        </div>
                      </CardContent>
                    </Card>
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <Shield className="h-8 w-8 mx-auto mb-2 text-red-500" />
                          <div className="text-2xl font-bold">{stockData.marketCap}</div>
                          <div className="text-sm text-muted-foreground">Market Cap</div>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                  <div className="mt-6">
                    <h3 className="font-semibold mb-4">Risk Factors</h3>
                    <ul className="space-y-2">
                      <li className="flex items-center">
                        <AlertTriangle className="h-4 w-4 mr-2 text-yellow-500" />
                        <span>Market volatility and economic uncertainties</span>
                      </li>
                      <li className="flex items-center">
                        <AlertTriangle className="h-4 w-4 mr-2 text-yellow-500" />
                        <span>Regulatory changes and compliance risks</span>
                      </li>
                      <li className="flex items-center">
                        <AlertTriangle className="h-4 w-4 mr-2 text-yellow-500" />
                        <span>Competitive pressures in the tech industry</span>
                      </li>
                      <li className="flex items-center">
                        <AlertTriangle className="h-4 w-4 mr-2 text-yellow-500" />
                        <span>Supply chain disruptions and geopolitical risks</span>
                      </li>
                    </ul>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
            <TabsContent value="valuation">
              <Card>
                <CardHeader>
                  <CardTitle>Valuation Metrics</CardTitle>
                  <CardDescription>Key valuation indicators and comparisons</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <DollarSign className="h-8 w-8 mx-auto mb-2 text-green-500" />
                          <div className="text-2xl font-bold">{stockData.peRatio}</div>
                          <div className="text-sm text-muted-foreground">P/E Ratio</div>
                        </div>
                      </CardContent>
                    </Card>
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <BarChart2 className="h-8 w-8 mx-auto mb-2 text-blue-500" />
                          <div className="text-2xl font-bold">2.5</div>
                          <div className="text-sm text-muted-foreground">P/B Ratio</div>
                        </div>
                      </CardContent>
                    </Card>
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <Users className="h-8 w-8 mx-auto mb-2 text-purple-500" />
                          <div className="text-2xl font-bold">1.8%</div>
                          <div className="text-sm text-muted-foreground">Dividend Yield</div>
                        </div>
                      </CardContent>
                    </Card>
                    <Card>
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <Building className="h-8 w-8 mx-auto mb-2 text-orange-500" />
                          <div className="text-2xl font-bold">{stockData.marketCap}</div>
                          <div className="text-sm text-muted-foreground">Market Cap</div>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                  <div className="mt-6">
                    <h3 className="font-semibold mb-4">Industry Comparison</h3>
                    <div className="h-[300px]">
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={[
                            { name: "P/E Ratio", company: stockData.peRatio, industry: 22.5 },
                            { name: "P/B Ratio", company: 2.5, industry: 3.2 },
                            { name: "Dividend Yield", company: 1.8, industry: 2.1 },
                          ]}
                        >
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis dataKey="name" />
                          <YAxis />
                          <Tooltip />
                          <Legend />
                          <Bar dataKey="company" fill="#8884d8" name={stockData.symbol} />
                          <Bar dataKey="industry" fill="#82ca9d" name="Industry Average" />
                        </BarChart>
                      </ResponsiveContainer>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>
          </Tabs>
          <Card>
            <CardHeader>
              <CardTitle>Company Overview</CardTitle>
              <CardDescription>Key information about {stockData.name}</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid gap-4 md:grid-cols-2">
                <div>
                  <h3 className="font-semibold mb-2">About {stockData.name}</h3>
                  <p className="text-sm text-muted-foreground">
                    {stockData.name} is a leading technology company that designs, develops, and sells consumer
                    electronics, computer software, and online services. Known for its innovative products including the
                    iPhone, iPad, Mac, and Apple Watch, the company has a strong focus on user experience and ecosystem
                    integration.
                  </p>
                </div>
                <div>
                  <h3 className="font-semibold mb-2">Key Statistics</h3>
                  <ul className="space-y-1 text-sm">
                    <li className="flex justify-between">
                      <span>Founded:</span>
                      <span className="font-medium">1976</span>
                    </li>
                    <li className="flex justify-between">
                      <span>Headquarters:</span>
                      <span className="font-medium">Cupertino, California</span>
                    </li>
                    <li className="flex justify-between">
                      <span>Employees:</span>
                      <span className="font-medium">~147,000</span>
                    </li>
                    <li className="flex justify-between">
                      <span>CEO:</span>
                      <span className="font-medium">Tim Cook</span>
                    </li>
                    <li className="flex justify-between">
                      <span>Industry:</span>
                      <span className="font-medium">Consumer Electronics, Software</span>
                    </li>
                  </ul>
                </div>
              </div>
              <div className="mt-6">
                <h3 className="font-semibold mb-2">Global Presence</h3>
                <div className="h-[300px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={[
                        { region: "Americas", revenue: 51.5 },
                        { region: "Europe", revenue: 25.3 },
                        { region: "Greater China", revenue: 18.8 },
                        { region: "Japan", revenue: 7.2 },
                        { region: "Rest of Asia Pacific", revenue: 6.8 },
                      ]}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="region" />
                      <YAxis />
                      <Tooltip />
                      <Bar dataKey="revenue" fill="#8884d8" />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
                <p className="text-sm text-muted-foreground mt-2">
                  Revenue distribution by geographic region (in billions USD)
                </p>
              </div>
            </CardContent>
          </Card>
        </>
      )}
    </div>
  )
}
</file>

<file path="app/technical-analysis/page.tsx">
import { TechnicalAnalysis } from "@/components/technical-analysis"
export default function TechnicalAnalysisPage() {
  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Technical Analysis</h1>
      <TechnicalAnalysis />
    </div>
  )
}
</file>

<file path="app/trading/page.tsx">
import { TradingInterface } from "@/components/trading-interface"
import { OrderBook } from "@/components/order-book"
import { TradingHistory } from "@/components/trading-history"
import { OptionChain } from "@/components/option-chain"
export default function TradingPage() {
  return (
    <div className="container mx-auto p-4 space-y-4">
      <h1 className="text-3xl font-bold mb-6">Trading</h1>
      <div className="grid gap-4 grid-cols-1 lg:grid-cols-2">
        <TradingInterface />
        <OrderBook />
        <TradingHistory />
        <OptionChain />
      </div>
    </div>
  )
}
</file>

<file path="app/trading-journal/page.tsx">
import { TradingJournalDashboard } from "@/components/trading-journal/trading-journal-dashboard"
export default function TradingJournalPage() {
  return (
    <div className="container mx-auto p-4">
      <TradingJournalDashboard />
    </div>
  )
}
</file>

<file path="app/valuation/page.tsx">
"use client"
import { useState } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Card, CardContent } from "@/components/ui/card"
import { StockSelector } from "@/components/valuation/stock-selector"
import { IntrinsicValueDashboard } from "@/components/intrinsic-value-dashboard"
import { DCFAnalysis } from "@/components/valuation/dcf-analysis"
import { RelativeValuation } from "@/components/valuation/relative-valuation"
import { SensitivityAnalysis } from "@/components/valuation/sensitivity-analysis"
import { MonteCarloSimulation } from "@/components/valuation/monte-carlo"
import { CompanyHealthMetrics } from "@/components/valuation/company-health-metrics"
import { AnalystEstimates } from "@/components/valuation/analyst-estimates"
import { fetchStockData } from "@/lib/api/stock-data"
import { ErrorMessage } from "@/components/error-message"
import { Loader2 } from "lucide-react"
export default function ValuationPage() {
  const [activeTab, setActiveTab] = useState("select")
  const [selectedStock, setSelectedStock] = useState<string | null>(null)
  const [stockData, setStockData] = useState<any>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const handleSelectStock = async (symbol: string) => {
    setIsLoading(true)
    setError(null)
    try {
      const data = await fetchStockData(symbol)
      setStockData(data)
      setSelectedStock(symbol)
      setActiveTab("overview")
    } catch (err) {
      setError("Failed to fetch stock data. Please try again.")
    } finally {
      setIsLoading(false)
    }
  }
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-4rem)]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }
  return (
    <div className="container mx-auto p-6">
      <div className="space-y-6">
        <div>
          <h1 className="text-4xl font-bold tracking-tight">Stock Valuation Analysis</h1>
          <p className="text-lg text-muted-foreground mt-2">
            Select a stock to analyze its intrinsic value and financial metrics
          </p>
        </div>
        <Card className="mt-6">
          <CardContent className="p-6">
            <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
              <div className="border-b">
                <TabsList className="w-full h-auto inline-flex p-0 bg-transparent">
                  <TabsTrigger
                    value="select"
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Select Stock
                  </TabsTrigger>
                  <TabsTrigger
                    value="overview"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Overview
                  </TabsTrigger>
                  <TabsTrigger
                    value="dcf"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    DCF Analysis
                  </TabsTrigger>
                  <TabsTrigger
                    value="relative"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Relative
                  </TabsTrigger>
                  <TabsTrigger
                    value="sensitivity"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Sensitivity
                  </TabsTrigger>
                  <TabsTrigger
                    value="simulation"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Monte Carlo
                  </TabsTrigger>
                  <TabsTrigger
                    value="analyst"
                    disabled={!selectedStock}
                    className="data-[state=active]:border-b-2 data-[state=active]:border-primary rounded-none flex-1 h-12"
                  >
                    Analyst Views
                  </TabsTrigger>
                </TabsList>
              </div>
              <div className="mt-6">
                <TabsContent value="select" className="m-0">
                  <StockSelector onSelectStock={handleSelectStock} />
                </TabsContent>
                {error ? (
                  <div className="flex items-center justify-center min-h-[400px]">
                    <ErrorMessage message={error} onRetry={() => handleSelectStock(selectedStock!)} />
                  </div>
                ) : (
                  stockData && (
                    <>
                      <TabsContent value="overview" className="m-0 space-y-6">
                        <CompanyHealthMetrics {...stockData.healthMetrics} />
                        <IntrinsicValueDashboard />
                      </TabsContent>
                      <TabsContent value="dcf" className="m-0">
                        <DCFAnalysis />
                      </TabsContent>
                      <TabsContent value="relative" className="m-0">
                        <RelativeValuation />
                      </TabsContent>
                      <TabsContent value="sensitivity" className="m-0">
                        <SensitivityAnalysis />
                      </TabsContent>
                      <TabsContent value="simulation" className="m-0">
                        <MonteCarloSimulation />
                      </TabsContent>
                      <TabsContent value="analyst" className="m-0">
                        <AnalystEstimates
                          companyName={stockData.basicInfo.name}
                          priceTargets={stockData.analystData.priceTargets}
                          revenueEstimates={stockData.analystData.revenueEstimates}
                        />
                      </TabsContent>
                    </>
                  )
                )}
              </div>
            </Tabs>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/watchlist/page.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { WatchlistTable } from "@/components/watchlist-table"
import { WatchlistAlerts } from "@/components/watchlist-alerts"
export default function WatchlistPage() {
  const [searchTerm, setSearchTerm] = useState("")
  return (
    <div className="space-y-4">
      <h1 className="text-3xl font-bold mb-6">Watchlist</h1>
      <div className="flex justify-between items-center mb-4">
        <Input
          className="max-w-sm"
          placeholder="Search symbols..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
        <Button>Add Symbol</Button>
      </div>
      <Card>
        <CardHeader>
          <CardTitle>Your Watchlist</CardTitle>
          <CardDescription>Track and monitor your favorite stocks</CardDescription>
        </CardHeader>
        <CardContent>
          <WatchlistTable searchTerm={searchTerm} />
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Alerts</CardTitle>
          <CardDescription>Manage your watchlist alerts</CardDescription>
        </CardHeader>
        <CardContent>
          <WatchlistAlerts />
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5.9% 10%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 346.8 77.2% 49.8%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 346.8 77.2% 49.8%;
  }
}
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
.react-grid-item {
  transition: all 200ms ease;
  transition-property: left, top, width, height;
}
.react-grid-item.react-grid-placeholder {
  background: rgba(var(--primary), 0.2);
  border: 2px dashed rgba(var(--primary), 0.4);
  border-radius: var(--radius);
}
.react-resizable-handle {
  background-image: none !important;
  background-color: rgba(var(--primary), 0.2);
  border-radius: 0 0 var(--radius) 0;
  width: 20px !important;
  height: 20px !important;
}
</file>

<file path="app/layout.tsx">
import { Inter } from "next/font/google"
import "./globals.css"
import "../styles/ticker.css"
import { AuthProvider } from "@/components/auth/auth-provider"
import { AppStateProvider } from "@/lib/app-state-context"
import { Sidebar } from "@/components/sidebar"
import { MarketStatusHeader } from "@/components/market-status-header"
import { ThemeProvider } from "@/components/theme-provider"
import type React from "react"
const inter = Inter({ subsets: ["latin"] })
export const metadata = {
  generator: 'v0.dev'
};
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem disableTransitionOnChange>
          <AppStateProvider>
            <AuthProvider>
              <div className="flex h-screen w-full overflow-hidden">
                <Sidebar />
                <div className="flex-1 flex flex-col min-w-0">
                  <MarketStatusHeader />
                  <main className="flex-1 overflow-auto p-4">{children}</main>
                </div>
              </div>
            </AuthProvider>
          </AppStateProvider>
        </ThemeProvider>
      </body>
    </html>
  )
}
</file>

<file path="app/page.tsx">
import { DashboardLayout } from "@/components/dashboard-layout"
export default function HomePage() {
  return <DashboardLayout />
}
</file>

<file path="components/ai-researcher/dashboard.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { getEconomicData, subscribeToAlerts } from "@/lib/api/ai-researcher"
import { MacroIndicator } from "@/components/ai-researcher/macro-indicator"
import { RiskAssessment } from "@/components/ai-researcher/risk-assessment"
import { ResearchReport } from "@/components/ai-researcher/research-report"
import { TrendAnalysis } from "@/components/ai-researcher/trend-analysis"
import { BadgeAlertIcon as AlertIcon, TrendingUp, TrendingDown, AlertTriangle } from "lucide-react"
import { EconomicData, ResearchReport as ResearchReportType } from "@/types/ai-researcher"
export function AIResearcherDashboard() {
  const [economicData, setEconomicData] = useState<EconomicData | null>(null)
  const [alerts, setAlerts] = useState<Array<{ title: string; description: string }>>([])
  const [selectedReport, setSelectedReport] = useState<ResearchReportType | null>(null)
  useEffect(() => {
    const fetchData = async () => {
      const data = await getEconomicData()
      setEconomicData(data)
    }
    fetchData()
    const unsubscribe = subscribeToAlerts((newAlert) => {
      setAlerts((prevAlerts) => [newAlert, ...prevAlerts])
    })
    return () => unsubscribe()
  }, [])
  if (!economicData) {
    return <div>Loading...</div>
  }
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>AI Researcher Dashboard</CardTitle>
          <CardDescription>Real-time macroeconomic analysis and insights</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <MacroIndicator
              title="GDP Growth"
              value={economicData.gdpGrowth}
              change={economicData.gdpGrowthChange}
              icon={economicData.gdpGrowthChange >= 0 ? TrendingUp : TrendingDown}
            />
            <MacroIndicator
              title="Inflation (CPI)"
              value={economicData.inflation}
              change={economicData.inflationChange}
              icon={economicData.inflationChange <= 0 ? TrendingDown : TrendingUp}
            />
            <MacroIndicator
              title="Interest Rate"
              value={economicData.interestRate}
              change={economicData.interestRateChange}
              icon={AlertTriangle}
            />
            <MacroIndicator
              title="Unemployment Rate"
              value={economicData.unemploymentRate}
              change={economicData.unemploymentRateChange}
              icon={economicData.unemploymentRateChange <= 0 ? TrendingDown : TrendingUp}
            />
          </div>
          <Tabs defaultValue="riskAssessment">
            <TabsList>
              <TabsTrigger value="riskAssessment">Risk Assessment</TabsTrigger>
              <TabsTrigger value="economicCycle">Economic Cycle</TabsTrigger>
              <TabsTrigger value="geopoliticalRisk">Geopolitical Risk</TabsTrigger>
            </TabsList>
            <TabsContent value="riskAssessment">
              <RiskAssessment data={economicData.riskAssessment} />
            </TabsContent>
            <TabsContent value="economicCycle">
              <div className="h-[300px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={economicData.economicCycle}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" />
                    <YAxis />
                    <Tooltip />
                    <Line type="monotone" dataKey="value" stroke="#8884d8" />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </TabsContent>
            <TabsContent value="geopoliticalRisk">
              <TrendAnalysis data={economicData.geopoliticalRisk} />
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>AI-Generated Research Reports</CardTitle>
          <CardDescription>Latest insights for institutional investors and hedge funds</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
            {economicData.researchReports.map((report) => (
              <Button
                key={report.id}
                variant="outline"
                className="h-auto text-left flex flex-col items-start p-4"
                onClick={() => setSelectedReport(report)}
              >
                <h3 className="font-semibold mb-2">{report.title}</h3>
                <p className="text-sm text-muted-foreground mb-2">{report.summary}</p>
                <Badge>{report.category}</Badge>
              </Button>
            ))}
          </div>
          {selectedReport && <ResearchReport report={selectedReport} />}
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>AI Alerts</CardTitle>
          <CardDescription>Real-time notifications on significant economic events</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {alerts.map((alert, index) => (
              <Alert key={index}>
                <AlertIcon className="h-4 w-4" />
                <AlertTitle>{alert.title}</AlertTitle>
                <AlertDescription>{alert.description}</AlertDescription>
              </Alert>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/ai-researcher/macro-indicator.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import type React from "react" // Import React
interface MacroIndicatorProps {
  title: string
  value: number
  change: number
  icon: React.ElementType
}
export function MacroIndicator({ title, value, change, icon: Icon }: MacroIndicatorProps) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        <Icon className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value.toFixed(2)}</div>
        <Badge variant={change >= 0 ? "default" : "destructive"} className="mt-1">
          {change >= 0 ? "+" : ""}
          {change.toFixed(2)}%
        </Badge>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/ai-researcher/research-report.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface ResearchReportProps {
  report: {
    id: string
    title: string
    summary: string
    category: string
    content: string
    date: string
    author: string
  }
}
export function ResearchReport({ report }: ResearchReportProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{report.title}</CardTitle>
        <div className="flex justify-between items-center">
          <Badge>{report.category}</Badge>
          <span className="text-sm text-muted-foreground">{report.date}</span>
        </div>
      </CardHeader>
      <CardContent>
        <p className="font-semibold mb-2">{report.summary}</p>
        <div className="prose max-w-none" dangerouslySetInnerHTML={{ __html: report.content }} />
        <p className="mt-4 text-sm text-muted-foreground">Author: {report.author}</p>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/ai-researcher/risk-assessment.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
interface RiskAssessmentProps {
  data: {
    recessionRisk: number
    marketVolatility: number
    creditRisk: number
    liquidityRisk: number
  }
}
export function RiskAssessment({ data }: RiskAssessmentProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <Card>
        <CardHeader>
          <CardTitle>Recession Risk</CardTitle>
        </CardHeader>
        <CardContent>
          <Progress value={data.recessionRisk} className="w-full" />
          <p className="mt-2 text-sm text-muted-foreground">{data.recessionRisk}% probability</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Market Volatility</CardTitle>
        </CardHeader>
        <CardContent>
          <Progress value={data.marketVolatility} className="w-full" />
          <p className="mt-2 text-sm text-muted-foreground">{data.marketVolatility}% above average</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Credit Risk</CardTitle>
        </CardHeader>
        <CardContent>
          <Progress value={data.creditRisk} className="w-full" />
          <p className="mt-2 text-sm text-muted-foreground">{data.creditRisk}% risk level</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Liquidity Risk</CardTitle>
        </CardHeader>
        <CardContent>
          <Progress value={data.liquidityRisk} className="w-full" />
          <p className="mt-2 text-sm text-muted-foreground">{data.liquidityRisk}% risk level</p>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/ai-researcher/trend-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface TrendAnalysisProps {
  data: {
    trends: {
      name: string
      impact: "positive" | "negative" | "neutral"
      description: string
    }[]
  }
}
export function TrendAnalysis({ data }: TrendAnalysisProps) {
  return (
    <div className="space-y-4">
      {data.trends.map((trend, index) => (
        <Card key={index}>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>{trend.name}</span>
              <Badge
                variant={
                  trend.impact === "positive" ? "default" : trend.impact === "negative" ? "destructive" : "secondary"
                }
              >
                {trend.impact}
              </Badge>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p>{trend.description}</p>
          </CardContent>
        </Card>
      ))}
    </div>
  )
}
</file>

<file path="components/asset-search/asset-card.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { TrendingUp, TrendingDown } from "lucide-react"
interface AssetCardProps {
  asset: {
    id: string
    name: string
    symbol: string
    assetClass: string
    price: number
    change: number
    score: number
  }
  onSelect: () => void
}
export function AssetCard({ asset, onSelect }: AssetCardProps) {
  return (
    <Card className="mb-2 cursor-pointer hover:bg-accent" onClick={onSelect}>
      <CardContent className="p-4 flex justify-between items-center">
        <div>
          <h3 className="font-semibold">{asset.name}</h3>
          <p className="text-sm text-muted-foreground">
            {asset.symbol} • {asset.assetClass}
          </p>
        </div>
        <div className="text-right">
          <p className="font-semibold">${asset.price.toFixed(2)}</p>
          <div className="flex items-center">
            {asset.change >= 0 ? (
              <TrendingUp className="h-4 w-4 text-green-500 mr-1" />
            ) : (
              <TrendingDown className="h-4 w-4 text-red-500 mr-1" />
            )}
            <span className={asset.change >= 0 ? "text-green-500" : "text-red-500"}>{asset.change.toFixed(2)}%</span>
          </div>
        </div>
        <Badge variant="secondary">Score: {asset.score}</Badge>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/asset-search/asset-chart.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { getAssetChartData } from "@/lib/api/asset-search"
interface ChartDataPoint {
  date: string
  price: number
}
interface AssetChartProps {
  assetId: string
}
export function AssetChart({ assetId }: AssetChartProps) {
  const [chartData, setChartData] = useState<ChartDataPoint[]>([])
  const [timeframe, setTimeframe] = useState("1D")
  useEffect(() => {
    const fetchChartData = async () => {
      const data = await getAssetChartData(assetId, timeframe)
      setChartData(data)
    }
    fetchChartData()
  }, [assetId, timeframe])
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Price Chart</CardTitle>
        <Select value={timeframe} onValueChange={setTimeframe}>
          <SelectTrigger className="w-[100px]">
            <SelectValue placeholder="Timeframe" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="1D">1 Day</SelectItem>
            <SelectItem value="1W">1 Week</SelectItem>
            <SelectItem value="1M">1 Month</SelectItem>
            <SelectItem value="3M">3 Months</SelectItem>
            <SelectItem value="1Y">1 Year</SelectItem>
            <SelectItem value="5Y">5 Years</SelectItem>
          </SelectContent>
        </Select>
      </CardHeader>
      <CardContent>
        <div className="h-[400px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={chartData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Line type="monotone" dataKey="price" stroke="#8884d8" dot={false} />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/asset-search/asset-details.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface AssetDetailsProps {
  details: {
    marketCap: number
    volume: number
    peRatio: number
    dividend: number
    sector: string
    industry: string
    beta: number
    eps: number
    high52Week: number
    low52Week: number
    price: number
  } | null
}
export function AssetDetails({ details }: AssetDetailsProps) {
  if (!details) return <div>Loading asset details...</div>
  return (
    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
      <Card>
        <CardHeader>
          <CardTitle>Market Cap</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">${(details.marketCap / 1e9).toFixed(2)}B</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Volume</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">{(details.volume / 1e6).toFixed(2)}M</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>P/E Ratio</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">{details.peRatio.toFixed(2)}</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Dividend Yield</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">{details.dividend.toFixed(2)}%</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Beta</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">{details.beta.toFixed(2)}</p>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>EPS</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-2xl font-bold">${details.eps.toFixed(2)}</p>
        </CardContent>
      </Card>
      <Card className="col-span-2 md:col-span-3">
        <CardHeader>
          <CardTitle>52 Week Range</CardTitle>
        </CardHeader>
        <CardContent className="flex justify-between items-center">
          <Badge variant="outline">${details.low52Week.toFixed(2)}</Badge>
          <div className="h-2 flex-1 bg-secondary mx-4 rounded-full overflow-hidden">
            <div
              className="h-full bg-primary"
              style={{
                width: `${((details.price - details.low52Week) / (details.high52Week - details.low52Week)) * 100}%`,
              }}
            />
          </div>
          <Badge variant="outline">${details.high52Week.toFixed(2)}</Badge>
        </CardContent>
      </Card>
      <Card className="col-span-2 md:col-span-3">
        <CardHeader>
          <CardTitle>Classification</CardTitle>
        </CardHeader>
        <CardContent className="flex justify-between">
          <Badge variant="outline">{details.sector}</Badge>
          <Badge variant="outline">{details.industry}</Badge>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/asset-search/news-panel.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
interface NewsItem {
  id: string
  title: string
  source: string
  date: string
  sentiment: "positive" | "negative" | "neutral"
  url: string
}
interface NewsPanelProps {
  news: NewsItem[]
}
export function NewsPanel({ news }: NewsPanelProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Latest News</CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px]">
          {news.map((item) => (
            <div key={item.id} className="mb-4 pb-4 border-b last:border-b-0">
              <h3 className="font-semibold mb-1">
                <a href={item.url} target="_blank" rel="noopener noreferrer" className="hover:underline">
                  {item.title}
                </a>
              </h3>
              <div className="flex justify-between items-center text-sm text-muted-foreground">
                <span>{item.source}</span>
                <span>{item.date}</span>
              </div>
              <Badge
                variant={
                  item.sentiment === "positive"
                    ? "default"
                    : item.sentiment === "negative"
                    ? "destructive"
                    : "secondary"
                }
                className="mt-2"
              >
                {item.sentiment}
              </Badge>
            </div>
          ))}
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/asset-search/related-assets.tsx">
import { ScrollArea } from "@/components/ui/scroll-area"
import { AssetCard } from "./asset-card"
interface RelatedAssetsProps {
  assets: Array<{
    id: string
    name: string
    symbol: string
    assetClass: string
    price: number
    change: number
    score: number
  }>
  onSelect: (asset: any) => void
}
export function RelatedAssets({ assets, onSelect }: RelatedAssetsProps) {
  return (
    <ScrollArea className="h-[400px]">
      {assets.map((asset) => (
        <AssetCard key={asset.id} asset={asset} onSelect={() => onSelect(asset)} />
      ))}
    </ScrollArea>
  )
}
</file>

<file path="components/auth/auth-provider.tsx">
"use client"
import type React from "react"
import { createContext, useContext, useState, useEffect } from "react"
interface User {
  id: string
  name: string
  email: string
}
interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  isLoading: boolean
}
const AuthContext = createContext<AuthContextType | undefined>(undefined)
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  useEffect(() => {
    // Check if user is already logged in
    const storedUser = localStorage.getItem("user")
    if (storedUser) {
      setUser(JSON.parse(storedUser))
    }
    setIsLoading(false)
  }, [])
  const login = async (email: string, password: string) => {
    // Simulating API call
    setIsLoading(true)
    await new Promise((resolve) => setTimeout(resolve, 1000))
    const user: User = { id: "1", name: "John Doe", email }
    setUser(user)
    localStorage.setItem("user", JSON.stringify(user))
    setIsLoading(false)
  }
  const logout = () => {
    setUser(null)
    localStorage.removeItem("user")
  }
  return <AuthContext.Provider value={{ user, login, logout, isLoading }}>{children}</AuthContext.Provider>
}
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
}
</file>

<file path="components/auth/login-form.tsx">
"use client"
import { useState } from "react"
import { useAuth } from "@/components/auth/auth-provider"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
export function LoginForm() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const { login, isLoading } = useAuth()
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    await login(email, password)
  }
  return (
    <Card className="w-[350px]">
      <CardHeader>
        <CardTitle>Login</CardTitle>
        <CardDescription>Enter your credentials to access your account</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <label htmlFor="email">Email</label>
            <Input id="email" type="email" value={email} onChange={(e) => setEmail(e.target.value)} required />
          </div>
          <div className="space-y-2">
            <label htmlFor="password">Password</label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? "Logging in..." : "Login"}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/backtesting/asset-selector.tsx">
"use client"
import { useState } from "react"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { searchAssets } from "@/lib/api/asset-search"
interface Asset {
  symbol: string
  name: string
}
interface AssetSelectorProps {
  selectedAssets: Asset[]
  setSelectedAssets: (assets: Asset[]) => void
}
export function AssetSelector({ selectedAssets, setSelectedAssets }: AssetSelectorProps) {
  const [searchTerm, setSearchTerm] = useState("")
  const [searchResults, setSearchResults] = useState<Asset[]>([])
  const handleSearch = async () => {
    if (searchTerm.trim()) {
      const results = await searchAssets(searchTerm)
      setSearchResults(results)
    }
  }
  const handleSelect = (asset) => {
    if (!selectedAssets.some((a) => a.symbol === asset.symbol)) {
      setSelectedAssets([...selectedAssets, asset])
    }
  }
  const handleRemove = (asset) => {
    setSelectedAssets(selectedAssets.filter((a) => a.symbol !== asset.symbol))
  }
  return (
    <div className="space-y-4">
      <div className="flex space-x-2">
        <Input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search assets..." />
        <Button onClick={handleSearch}>Search</Button>
      </div>
      {searchResults.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-sm font-semibold">Search Results:</h3>
          <div className="flex flex-wrap gap-2">
            {searchResults.map((asset) => (
              <Badge
                key={asset.symbol}
                variant="outline"
                className="cursor-pointer"
                onClick={() => handleSelect(asset)}
              >
                {asset.symbol} - {asset.name}
              </Badge>
            ))}
          </div>
        </div>
      )}
      {selectedAssets.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-sm font-semibold">Selected Assets:</h3>
          <div className="flex flex-wrap gap-2">
            {selectedAssets.map((asset) => (
              <Badge
                key={asset.symbol}
                variant="secondary"
                className="cursor-pointer"
                onClick={() => handleRemove(asset)}
              >
                {asset.symbol} <span className="ml-1">&times;</span>
              </Badge>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="components/backtesting/backtest-results.tsx">
"use client"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
export function BacktestResults({ results }) {
  const { performanceData, metrics, comparisonData } = results
  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-semibold mb-2">Performance Chart</h2>
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={performanceData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="strategy" stroke="#8884d8" />
            <Line type="monotone" dataKey="benchmark" stroke="#82ca9d" />
          </LineChart>
        </ResponsiveContainer>
      </div>
      <div>
        <h2 className="text-xl font-semibold mb-2">Performance Metrics</h2>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Metric</TableHead>
              <TableHead>Value</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {Object.entries(metrics).map(([key, value]) => (
              <TableRow key={key}>
                <TableCell>{key}</TableCell>
                <TableCell>{typeof value === "number" ? value.toFixed(2) : value}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
      <div>
        <h2 className="text-xl font-semibold mb-2">Benchmark Comparisons</h2>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Benchmark</TableHead>
              <TableHead>Return</TableHead>
              <TableHead>Sharpe Ratio</TableHead>
              <TableHead>Max Drawdown</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {comparisonData.map((benchmark) => (
              <TableRow key={benchmark.name}>
                <TableCell>{benchmark.name}</TableCell>
                <TableCell>{benchmark.return.toFixed(2)}%</TableCell>
                <TableCell>{benchmark.sharpeRatio.toFixed(2)}</TableCell>
                <TableCell>{benchmark.maxDrawdown.toFixed(2)}%</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  )
}
</file>

<file path="components/backtesting/backtesting-dashboard.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { StrategyOptimizer } from "./strategy-optimizer"
import { AssetSelector } from "./asset-selector"
import { DatePickerWithRange } from "@/components/ui/date-range-picker"
import { runBacktest } from "@/lib/api/backtesting"
import { DateRange } from "react-day-picker"
import { Strategy } from "@/types/backtesting"
export function BacktestingDashboard() {
  const [selectedAssets, setSelectedAssets] = useState<string[]>([])
  const [selectedStrategy, setSelectedStrategy] = useState<Strategy>("momentum")
  const [backtestResults, setBacktestResults] = useState<BacktestResults | null>(null)
  const [dateRange, setDateRange] = useState<DateRange>({
    from: new Date(),
    to: new Date(new Date().setMonth(new Date().getMonth() + 1))
  })
  const [isLoading, setIsLoading] = useState(false)
  const handleDateRangeChange = (range: DateRange | undefined) => {
    if (range) {
      setDateRange(range)
    }
  }
  const handleStrategyChange = (value: string) => {
    setSelectedStrategy(value as Strategy)
  }
  const handleRunBacktest = async () => {
    if (!dateRange.from || !dateRange.to || selectedAssets.length === 0) return
    setIsLoading(true)
    try {
      const results = await runBacktest({
        assets: selectedAssets,
        strategy: selectedStrategy,
        startDate: dateRange.from,
        endDate: dateRange.to,
      })
      setBacktestResults(results)
    } catch (error) {
      console.error("Error running backtest:", error)
    } finally {
      setIsLoading(false)
    }
  }
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Backtest Configuration</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <AssetSelector selectedAssets={selectedAssets} setSelectedAssets={setSelectedAssets} />
            <DatePickerWithRange date={dateRange} onSelect={handleDateRangeChange} />
          </div>
          <div className="mb-4">
            <Select value={selectedStrategy} onValueChange={handleStrategyChange}>
              <SelectTrigger>
                <SelectValue placeholder="Select strategy" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="momentum">Momentum</SelectItem>
                <SelectItem value="meanReversion">Mean Reversion</SelectItem>
                <SelectItem value="trendFollowing">Trend Following</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <Button onClick={handleRunBacktest} disabled={isLoading}>
            {isLoading ? "Running..." : "Run Backtest"}
          </Button>
        </CardContent>
      </Card>
      {backtestResults && (
        <Card>
          <CardHeader>
            <CardTitle>Backtest Results</CardTitle>
          </CardHeader>
          <CardContent>
            <StrategyOptimizer results={backtestResults} />
          </CardContent>
        </Card>
      )}
    </div>
  )
}
</file>

<file path="components/backtesting/strategy-optimizer.tsx">
"use client"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { BacktestResults } from "@/types/backtesting"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
interface StrategyOptimizerProps {
  results: BacktestResults
}
export function StrategyOptimizer({ results }: StrategyOptimizerProps) {
  const chartData = results.dates.map((date, index) => ({
    date,
    return: results.returns[index],
  }))
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Performance Metrics</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
            <div>
              <div className="text-sm font-medium text-muted-foreground">Total Return</div>
              <div className="text-2xl font-bold">{results.metrics.totalReturn.toFixed(2)}%</div>
            </div>
            <div>
              <div className="text-sm font-medium text-muted-foreground">Annualized Return</div>
              <div className="text-2xl font-bold">{results.metrics.annualizedReturn.toFixed(2)}%</div>
            </div>
            <div>
              <div className="text-sm font-medium text-muted-foreground">Sharpe Ratio</div>
              <div className="text-2xl font-bold">{results.metrics.sharpeRatio.toFixed(2)}</div>
            </div>
            <div>
              <div className="text-sm font-medium text-muted-foreground">Max Drawdown</div>
              <div className="text-2xl font-bold">{results.metrics.maxDrawdown.toFixed(2)}%</div>
            </div>
            <div>
              <div className="text-sm font-medium text-muted-foreground">Volatility</div>
              <div className="text-2xl font-bold">{results.metrics.volatility.toFixed(2)}%</div>
            </div>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Performance Chart</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={chartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="return" stroke="#8884d8" name="Return %" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Trade History</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {results.trades.map((trade, index) => (
              <div key={index} className="flex justify-between items-center p-4 border rounded-lg">
                <div>
                  <div className="font-medium">{trade.asset}</div>
                  <div className="text-sm text-muted-foreground">{trade.date}</div>
                </div>
                <div>
                  <div className={`font-medium ${trade.type === "buy" ? "text-green-600" : "text-red-600"}`}>
                    {trade.type.toUpperCase()}
                  </div>
                  <div className="text-sm text-muted-foreground">
                    {trade.quantity} @ ${trade.price.toFixed(2)}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/company/CompanyInfoCard.tsx">
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useCompanyInfo } from '@/lib/hooks/use-company-info';
interface CompanyInfoCardProps {
  symbol: string;
  refreshInterval?: number;
}
export function CompanyInfoCard({
  symbol,
  refreshInterval,
}: CompanyInfoCardProps) {
  const { data, error, isLoading } = useCompanyInfo(symbol, {
    refreshInterval,
  });
  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Company Information</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-destructive">{error.message}</p>
        </CardContent>
      </Card>
    );
  }
  if (isLoading || !data) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Company Information</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse space-y-4">
            <div className="h-4 w-3/4 bg-muted rounded" />
            <div className="h-20 bg-muted rounded" />
            <div className="space-y-2">
              <div className="h-3 w-1/2 bg-muted rounded" />
              <div className="h-3 w-1/3 bg-muted rounded" />
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>{data.name}</span>
          <Badge variant="outline">{data.symbol}</Badge>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-muted-foreground">{data.description}</p>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <p className="text-sm font-medium">Sector</p>
            <p className="text-sm text-muted-foreground">{data.sector}</p>
          </div>
          <div>
            <p className="text-sm font-medium">Industry</p>
            <p className="text-sm text-muted-foreground">{data.industry}</p>
          </div>
          {data.employees && (
            <div>
              <p className="text-sm font-medium">Employees</p>
              <p className="text-sm text-muted-foreground">
                {data.employees.toLocaleString()}
              </p>
            </div>
          )}
          {data.marketCap && (
            <div>
              <p className="text-sm font-medium">Market Cap</p>
              <p className="text-sm text-muted-foreground">
                ${(data.marketCap / 1e9).toFixed(2)}B
              </p>
            </div>
          )}
        </div>
        {data.website && (
          <div>
            <p className="text-sm font-medium">Website</p>
            <a
              href={data.website}
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-primary hover:underline"
            >
              {data.website}
            </a>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/due-diligence/ai-generated-report.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
export function AIGeneratedReport({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>AI-Generated Stock Report</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="hedge-fund">
          <TabsList>
            <TabsTrigger value="hedge-fund">Hedge Fund</TabsTrigger>
            <TabsTrigger value="retail">Retail Trader</TabsTrigger>
            <TabsTrigger value="institutional">Institutional Investor</TabsTrigger>
          </TabsList>
          <TabsContent value="hedge-fund">
            <div className="prose max-w-none" dangerouslySetInnerHTML={{ __html: data.hedgeFund }} />
          </TabsContent>
          <TabsContent value="retail">
            <div className="prose max-w-none" dangerouslySetInnerHTML={{ __html: data.retail }} />
          </TabsContent>
          <TabsContent value="institutional">
            <div className="prose max-w-none" dangerouslySetInnerHTML={{ __html: data.institutional }} />
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/due-diligence-dashboard.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Search } from "lucide-react"
export function DueDiligenceDashboard() {
  const [symbol, setSymbol] = useState("")
  return (
    <Card className="w-full">
      <CardHeader>
        <div className="flex justify-between items-center">
          <div>
            <CardTitle>AI-Enhanced Due Diligence</CardTitle>
            <CardDescription>Comprehensive company analysis and research</CardDescription>
          </div>
          <div className="flex space-x-2">
            <Input
              placeholder="Enter symbol"
              value={symbol}
              onChange={(e) => setSymbol(e.target.value.toUpperCase())}
              className="w-24"
            />
            <Button>
              <Search className="h-4 w-4 mr-2" />
              Analyze
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="overview">
          <TabsList>
            <TabsTrigger value="overview">Overview</TabsTrigger>
            <TabsTrigger value="financials">Financials</TabsTrigger>
            <TabsTrigger value="management">Management</TabsTrigger>
            <TabsTrigger value="risks">Risks</TabsTrigger>
            <TabsTrigger value="competitors">Competitors</TabsTrigger>
            <TabsTrigger value="news">News & Events</TabsTrigger>
          </TabsList>
          <TabsContent value="overview">
            <Card>
              <CardHeader>
                <CardTitle>Company Overview</CardTitle>
                <CardDescription>Key information and business model</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view detailed analysis</p>
              </CardContent>
            </Card>
          </TabsContent>
          <TabsContent value="financials">
            <Card>
              <CardHeader>
                <CardTitle>Financial Analysis</CardTitle>
                <CardDescription>Financial statements and metrics</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view financial analysis</p>
              </CardContent>
            </Card>
          </TabsContent>
          <TabsContent value="management">
            <Card>
              <CardHeader>
                <CardTitle>Management Analysis</CardTitle>
                <CardDescription>Leadership team and corporate governance</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view management analysis</p>
              </CardContent>
            </Card>
          </TabsContent>
          <TabsContent value="risks">
            <Card>
              <CardHeader>
                <CardTitle>Risk Assessment</CardTitle>
                <CardDescription>Key risks and mitigation strategies</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view risk assessment</p>
              </CardContent>
            </Card>
          </TabsContent>
          <TabsContent value="competitors">
            <Card>
              <CardHeader>
                <CardTitle>Competitive Analysis</CardTitle>
                <CardDescription>Market position and competitor comparison</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view competitive analysis</p>
              </CardContent>
            </Card>
          </TabsContent>
          <TabsContent value="news">
            <Card>
              <CardHeader>
                <CardTitle>News & Events</CardTitle>
                <CardDescription>Recent developments and upcoming events</CardDescription>
              </CardHeader>
              <CardContent>
                <p>Select a company symbol to view news and events</p>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/earnings-call-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
export function EarningsCallAnalysis({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Earnings Call Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div>
            <h3 className="text-lg font-semibold mb-2">Key Takeaways</h3>
            <ul className="list-disc pl-5">
              {data.keyTakeaways.map((takeaway, index) => (
                <li key={index}>{takeaway}</li>
              ))}
            </ul>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Sentiment Analysis</h3>
            <div className="flex items-center space-x-2">
              <span>Overall Sentiment:</span>
              <Badge
                variant={
                  data.sentiment === "Positive"
                    ? "success"
                    : data.sentiment === "Negative"
                      ? "destructive"
                      : "secondary"
                }
              >
                {data.sentiment}
              </Badge>
            </div>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Notable Quotes</h3>
            {data.notableQuotes.map((quote, index) => (
              <blockquote key={index} className="border-l-4 border-gray-300 pl-4 my-2 italic">
                "{quote}"
              </blockquote>
            ))}
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/earnings-manipulation-detection.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { AlertTriangle } from "lucide-react"
export function EarningsManipulationDetection({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Earnings Manipulation Detection</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold mb-2">Overall Assessment</h3>
            <div className="flex items-center space-x-2">
              <Badge
                variant={
                  data.overallRisk === "Low" ? "success" : data.overallRisk === "Medium" ? "warning" : "destructive"
                }
              >
                {data.overallRisk} Risk
              </Badge>
              <span>{data.overallAssessment}</span>
            </div>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Risk Factors</h3>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Factor</TableHead>
                  <TableHead>Risk Level</TableHead>
                  <TableHead>Description</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {data.riskFactors.map((factor, index) => (
                  <TableRow key={index}>
                    <TableCell>{factor.name}</TableCell>
                    <TableCell>
                      <Badge
                        variant={
                          factor.risk === "Low" ? "success" : factor.risk === "Medium" ? "warning" : "destructive"
                        }
                      >
                        {factor.risk}
                      </Badge>
                    </TableCell>
                    <TableCell>{factor.description}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
          {data.redFlags.length > 0 && (
            <div>
              <h3 className="text-lg font-semibold mb-2">Red Flags</h3>
              <ul className="list-disc pl-5">
                {data.redFlags.map((flag, index) => (
                  <li key={index} className="flex items-center space-x-2">
                    <AlertTriangle className="text-red-500" />
                    <span>{flag}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/financial-statement-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
export function FinancialStatementAnalysis({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Financial Statement Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold mb-2">Key Metrics</h3>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Metric</TableHead>
                  <TableHead>Value</TableHead>
                  <TableHead>YoY Change</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {Object.entries(data.keyMetrics).map(([metric, values]) => (
                  <TableRow key={metric}>
                    <TableCell>{metric}</TableCell>
                    <TableCell>{values.value}</TableCell>
                    <TableCell>{values.yoyChange}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Revenue and Earnings Trend</h3>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={data.revenueEarningsTrend}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="year" />
                <YAxis yAxisId="left" />
                <YAxis yAxisId="right" orientation="right" />
                <Tooltip />
                <Legend />
                <Line yAxisId="left" type="monotone" dataKey="revenue" stroke="#8884d8" />
                <Line yAxisId="right" type="monotone" dataKey="earnings" stroke="#82ca9d" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/insider-transactions.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
export function InsiderTransactions({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Insider Transactions</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Insider</TableHead>
              <TableHead>Transaction Type</TableHead>
              <TableHead>Shares</TableHead>
              <TableHead>Value</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {data.transactions.map((transaction, index) => (
              <TableRow key={index}>
                <TableCell>{transaction.date}</TableCell>
                <TableCell>{transaction.insider}</TableCell>
                <TableCell>
                  <Badge variant={transaction.type === "Buy" ? "success" : "destructive"}>{transaction.type}</Badge>
                </TableCell>
                <TableCell>{transaction.shares.toLocaleString()}</TableCell>
                <TableCell>${transaction.value.toLocaleString()}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
        <div className="mt-4">
          <h3 className="text-lg font-semibold mb-2">AI Analysis</h3>
          <p>{data.aiAnalysis}</p>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/sec-filings-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
export function SECFilingsAnalysis({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>SEC Filings Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Filing Type</TableHead>
              <TableHead>Date</TableHead>
              <TableHead>Key Insights</TableHead>
              <TableHead>Sentiment</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {data.map((filing, index) => (
              <TableRow key={index}>
                <TableCell>{filing.type}</TableCell>
                <TableCell>{filing.date}</TableCell>
                <TableCell>{filing.keyInsights}</TableCell>
                <TableCell>
                  <Badge
                    variant={
                      filing.sentiment === "Positive"
                        ? "success"
                        : filing.sentiment === "Negative"
                          ? "destructive"
                          : "secondary"
                    }
                  >
                    {filing.sentiment}
                  </Badge>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/due-diligence/valuation-models.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
export function ValuationModels({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Valuation Models</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold mb-2">DCF Valuation</h3>
            <Table>
              <TableBody>
                <TableRow>
                  <TableCell>Intrinsic Value</TableCell>
                  <TableCell>${data.dcf.intrinsicValue.toFixed(2)}</TableCell>
                </TableRow>
                <TableRow>
                  <TableCell>Current Price</TableCell>
                  <TableCell>${data.dcf.currentPrice.toFixed(2)}</TableCell>
                </TableRow>
                <TableRow>
                  <TableCell>Upside/Downside</TableCell>
                  <TableCell>
                    <Badge variant={data.dcf.upside >= 0 ? "success" : "destructive"}>
                      {data.dcf.upside >= 0 ? "+" : ""}
                      {data.dcf.upside.toFixed(2)}%
                    </Badge>
                  </TableCell>
                </TableRow>
              </TableBody>
            </Table>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">EV/EBITDA Valuation</h3>
            <Table>
              <TableBody>
                <TableRow>
                  <TableCell>Company EV/EBITDA</TableCell>
                  <TableCell>{data.evEbitda.companyRatio.toFixed(2)}</TableCell>
                </TableRow>
                <TableRow>
                  <TableCell>Industry Average EV/EBITDA</TableCell>
                  <TableCell>{data.evEbitda.industryAverage.toFixed(2)}</TableCell>
                </TableRow>
                <TableRow>
                  <TableCell>Valuation</TableCell>
                  <TableCell>
                    <Badge variant={data.evEbitda.valuation === "Undervalued" ? "success" : "destructive"}>
                      {data.evEbitda.valuation}
                    </Badge>
                  </TableCell>
                </TableRow>
              </TableBody>
            </Table>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Peer Benchmarking</h3>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Metric</TableHead>
                  <TableHead>Company</TableHead>
                  <TableHead>Peer Average</TableHead>
                  <TableHead>Valuation</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {Object.entries(data.peerBenchmarking).map(([metric, values]) => (
                  <TableRow key={metric}>
                    <TableCell>{metric}</TableCell>
                    <TableCell>{values.company.toFixed(2)}</TableCell>
                    <TableCell>{values.peerAverage.toFixed(2)}</TableCell>
                    <TableCell>
                      <Badge variant={values.valuation === "Undervalued" ? "success" : "destructive"}>
                        {values.valuation}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/economic-event-tracker/ai-recommendations.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
export function AIRecommendations({ recommendations }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>AI-Generated Investment Recommendations</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Asset</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Recommendation</TableHead>
              <TableHead>Rationale</TableHead>
              <TableHead>Time Horizon</TableHead>
              <TableHead>Action</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {recommendations.map((rec, index) => (
              <TableRow key={index}>
                <TableCell>{rec.asset}</TableCell>
                <TableCell>
                  <Badge variant={rec.type === "Buy" ? "default" : "secondary"}>{rec.type}</Badge>
                </TableCell>
                <TableCell>{rec.recommendation}</TableCell>
                <TableCell>{rec.rationale}</TableCell>
                <TableCell>{rec.timeHorizon}</TableCell>
                <TableCell>
                  <Button size="sm">Execute</Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/economic-event-tracker/economic-event-tracker.tsx">
"use client"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Loader2 } from "lucide-react"
import { useEffect, useState } from "react"
import { EventCalendar } from "./event-calendar"
import { EventImpactAnalysis } from "./event-impact-analysis"
import { AIRecommendations } from "./ai-recommendations"
import { EconomicEventData } from "@/types/economic-events"
export function EconomicEventTracker() {
  const [economicEvents, setEconomicEvents] = useState<EconomicEventData | null>(null)
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    const fetchEconomicEvents = async () => {
      try {
        const response = await fetch("/api/economic-events")
        if (!response.ok) {
          throw new Error("Failed to fetch economic events")
        }
        const data: EconomicEventData = await response.json()
        setEconomicEvents(data)
      } catch (error) {
        console.error("Error fetching economic events:", error)
      } finally {
        setLoading(false)
      }
    }
    fetchEconomicEvents()
  }, [])
  if (loading) {
    return (
      <div className="flex h-[450px] items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    )
  }
  if (!economicEvents) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Economic Event Tracker</CardTitle>
        </CardHeader>
        <CardContent>
          <p>No economic events data available.</p>
        </CardContent>
      </Card>
    )
  }
  return (
    <Tabs defaultValue="calendar">
      <TabsList>
        <TabsTrigger value="calendar">Event Calendar</TabsTrigger>
        <TabsTrigger value="impact">Impact Analysis</TabsTrigger>
        <TabsTrigger value="recommendations">AI Recommendations</TabsTrigger>
      </TabsList>
      <TabsContent value="calendar">
        <EventCalendar events={economicEvents.upcomingEvents} />
      </TabsContent>
      <TabsContent value="impact">
        <EventImpactAnalysis events={economicEvents.highImpactEvents} />
      </TabsContent>
      <TabsContent value="recommendations">
        <AIRecommendations recommendations={economicEvents.aiRecommendations} />
      </TabsContent>
    </Tabs>
  )
}
</file>

<file path="components/economic-event-tracker/event-calendar.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
export function EventCalendar({ events }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Upcoming Economic Events</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Event</TableHead>
              <TableHead>Country</TableHead>
              <TableHead>Impact</TableHead>
              <TableHead>Previous</TableHead>
              <TableHead>Forecast</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {events.map((event, index) => (
              <TableRow key={index}>
                <TableCell>{event.date}</TableCell>
                <TableCell>{event.name}</TableCell>
                <TableCell>{event.country}</TableCell>
                <TableCell>
                  <Badge
                    variant={
                      event.impact === "High" ? "destructive" : event.impact === "Medium" ? "warning" : "default"
                    }
                  >
                    {event.impact}
                  </Badge>
                </TableCell>
                <TableCell>{event.previous}</TableCell>
                <TableCell>{event.forecast}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/economic-event-tracker/event-impact-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { TrendingUp, TrendingDown, Minus } from "lucide-react"
export function EventImpactAnalysis({ events }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>High-Impact Event Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Event</TableHead>
              <TableHead>Date</TableHead>
              <TableHead>Impact</TableHead>
              <TableHead>Market Implications</TableHead>
              <TableHead>Affected Sectors</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {events.map((event, index) => (
              <TableRow key={index}>
                <TableCell>{event.name}</TableCell>
                <TableCell>{event.date}</TableCell>
                <TableCell>
                  <Badge variant="destructive">High</Badge>
                </TableCell>
                <TableCell>
                  <div className="flex items-center space-x-2">
                    {event.marketImplications.direction === "up" && <TrendingUp className="text-green-500" />}
                    {event.marketImplications.direction === "down" && <TrendingDown className="text-red-500" />}
                    {event.marketImplications.direction === "neutral" && <Minus className="text-yellow-500" />}
                    <span>{event.marketImplications.description}</span>
                  </div>
                </TableCell>
                <TableCell>
                  {event.affectedSectors.map((sector, idx) => (
                    <Badge key={idx} variant="outline" className="mr-1">
                      {sector}
                    </Badge>
                  ))}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/economic-event-tracker/trend-opportunities.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { TrendingUp, TrendingDown } from "lucide-react"
export function TrendOpportunities({ trends }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Economic Trends and Trading Opportunities</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Trend</TableHead>
              <TableHead>Direction</TableHead>
              <TableHead>Duration</TableHead>
              <TableHead>Confidence</TableHead>
              <TableHead>Potential Opportunities</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {trends.map((trend, index) => (
              <TableRow key={index}>
                <TableCell>{trend.name}</TableCell>
                <TableCell>
                  {trend.direction === "up" ? (
                    <TrendingUp className="text-green-500" />
                  ) : (
                    <TrendingDown className="text-red-500" />
                  )}
                </TableCell>
                <TableCell>{trend.duration}</TableCell>
                <TableCell>
                  <Badge variant={trend.confidence >= 70 ? "default" : "secondary"}>{trend.confidence}%</Badge>
                </TableCell>
                <TableCell>
                  <ul className="list-disc pl-4">
                    {trend.opportunities.map((opp, idx) => (
                      <li key={idx}>{opp}</li>
                    ))}
                  </ul>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/financial-heatmap/heatmap-legend.tsx">
"use client"
import { useEffect, useRef } from "react"
import * as d3 from "d3"
interface HeatmapLegendProps {
  metric: string
}
export function HeatmapLegend({ metric }: HeatmapLegendProps) {
  const svgRef = useRef(null)
  useEffect(() => {
    const width = 300
    const height = 50
    const svg = d3.select(svgRef.current).attr("width", width).attr("height", height)
    const colorScale = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, 100])
    const legendScale = d3
      .scaleLinear()
      .domain([0, 100])
      .range([0, width - 20])
    const legendAxis = d3
      .axisBottom(legendScale)
      .ticks(5)
      .tickFormat((d) => `${d}%`)
    svg.selectAll("*").remove()
    const legend = svg.append("g").attr("transform", `translate(10, 10)`)
    legend
      .append("defs")
      .append("linearGradient")
      .attr("id", "legend-gradient")
      .selectAll("stop")
      .data(colorScale.ticks(10).map((t, i, n) => ({ offset: `${(100 * i) / n.length}%`, color: colorScale(t) })))
      .enter()
      .append("stop")
      .attr("offset", (d) => d.offset)
      .attr("stop-color", (d) => d.color)
    legend
      .append("rect")
      .attr("width", width - 20)
      .attr("height", 20)
      .style("fill", "url(#legend-gradient)")
    legend.append("g").attr("transform", `translate(0, 20)`).call(legendAxis)
    legend
      .append("text")
      .attr("x", (width - 20) / 2)
      .attr("y", 45)
      .attr("text-anchor", "middle")
      .text(metric)
  }, [metric])
  return <svg ref={svgRef}></svg>
}
</file>

<file path="components/financial-heatmap/heatmap.tsx">
"use client"
import { useRef, useEffect, useState } from "react"
import * as d3 from "d3"
import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Tooltip, TooltipProvider } from "@/components/ui/tooltip"
interface HeatmapProps {
  data: {
    id: string
    name: string
    value: number
    aiInsights?: string
    subSectors?: {
      name: string
      value: number
    }[]
  }[]
  showAIInsights: boolean
  metric: string
}
export function Heatmap({ data, showAIInsights, metric }: HeatmapProps) {
  const svgRef = useRef(null)
  const [selectedSector, setSelectedSector] = useState(null)
  useEffect(() => {
    if (!data.length) return
    const width = 800
    const height = 600
    const svg = d3.select(svgRef.current).attr("width", width).attr("height", height)
    const treemap = d3.treemap().size([width, height]).padding(1).round(true)
    const root = d3.hierarchy({ children: data }).sum((d) => d.value)
    const nodes = treemap(root).leaves()
    const colorScale = d3
      .scaleSequential(d3.interpolateRdYlGn)
      .domain([d3.min(data, (d) => d.value), d3.max(data, (d) => d.value)])
    svg.selectAll("g").remove()
    const cell = svg
      .selectAll("g")
      .data(nodes)
      .enter()
      .append("g")
      .attr("transform", (d) => `translate(${d.x0},${d.y0})`)
      .on("click", (event, d) => setSelectedSector(d.data))
    cell
      .append("rect")
      .attr("width", (d) => d.x1 - d.x0)
      .attr("height", (d) => d.y1 - d.y0)
      .attr("fill", (d) => colorScale(d.data.value))
    cell
      .append("text")
      .attr("x", 4)
      .attr("y", 14)
      .text((d) => d.data.name)
      .attr("font-size", "12px")
      .attr("fill", "white")
    if (showAIInsights) {
      cell
        .append("text")
        .attr("x", 4)
        .attr("y", 28)
        .text((d) => d.data.aiInsights || "")
        .attr("font-size", "10px")
        .attr("fill", "white")
        .attr("opacity", 0.8)
    }
  }, [data, showAIInsights])
  return (
    <TooltipProvider>
      <div className="space-y-4">
        <svg ref={svgRef}></svg>
        {selectedSector && (
          <Card>
            <CardContent className="p-4">
              <h3 className="text-lg font-semibold mb-2">{selectedSector.name}</h3>
              <p className="mb-2">
                {metric}: {selectedSector.value.toFixed(2)}
              </p>
              {showAIInsights && selectedSector.aiInsights && (
                <p className="mb-2">AI Insight: {selectedSector.aiInsights}</p>
              )}
              {selectedSector.subSectors && (
                <div>
                  <h4 className="font-semibold mb-1">Sub-sectors:</h4>
                  <ul className="list-disc pl-5">
                    {selectedSector.subSectors.map((subSector, index) => (
                      <li key={index}>
                        {subSector.name}: {subSector.value.toFixed(2)}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
              <Tooltip content="View detailed analysis">
                <Button className="mt-2">Analyze</Button>
              </Tooltip>
            </CardContent>
          </Card>
        )}
      </div>
    </TooltipProvider>
  )
}
</file>

<file path="components/generative-ui/chat-interface.tsx">
import { Badge, Button, Card, CardContent, CardHeader, Input } from "@/components/ui/card"
import { Loader2 } from "@/components/ui/loader"
import { Send } from "lucide-react"
import { useRef, useState } from "react"
import { Bot } from "./bot"
import { ScrollArea } from "./scroll-area"
const getSentimentColor = (sentiment: string) => {
  switch (sentiment) {
    case "positive":
      return "bg-green-500/10 text-green-500"
    case "negative":
      return "bg-red-500/10 text-red-500"
    case "neutral":
      return "bg-yellow-500/10 text-yellow-500"
    default:
      return ""
  }
}
interface Message {
  id: string
  role: "user" | "assistant"
  content: string
  sentiment?: string
  confidence?: number
}
export function ChatInterface({
  messages,
  handleMessageSubmit,
  isAnalyzing,
}: {
  messages: Message[]
  handleMessageSubmit: (e: React.FormEvent<HTMLFormElement>) => void
  isAnalyzing: boolean
}) {
  const [input, setInput] = useState("")
  const [context, setContext] = useState("")
  const inputRef = useRef<HTMLInputElement>(null)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }
  useState(() => {
    scrollToBottom()
  }, [messages])
  return (
    <Card>
      <CardHeader className="flex justify-between items-center">
        <h2 className="text-xl font-bold">Chat</h2>
        <div className="flex gap-2">
          <Input
            placeholder="Set conversation context..."
            value={context}
            onChange={(e) => setContext(e.target.value)}
            className="w-[200px]"
          />
        </div>
      </CardHeader>
      <CardContent className="flex-1 flex flex-col">
        <ScrollArea className="flex-1 pr-4">
          <div className="space-y-4">
            {messages.map((message) => (
              <div key={message.id} className={`flex ${message.role === "user" ? "justify-end" : "justify-start"}`}>
                <div
                  className={`flex gap-2 max-w-[80%] rounded-lg p-3 ${
                    message.role === "user" ? "bg-primary text-primary-foreground" : "bg-muted flex items-start"
                  }`}
                >
                  {message.role === "assistant" && <Bot className="h-5 w-5 mt-1 flex-shrink-0" />}
                  <div className="flex flex-col gap-1">
                    <p className="text-sm">{message.content}</p>
                    {message.sentiment && (
                      <Badge variant="outline" className={getSentimentColor(message.sentiment)}>
                        {message.sentiment}
                      </Badge>
                    )}
                    {message.confidence && (
                      <Badge variant="outline" className="bg-yellow-500/10 text-yellow-500">
                        Confidence: {(message.confidence * 100).toFixed(2)}%
                      </Badge>
                    )}
                  </div>
                </div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </div>
        </ScrollArea>
        <form onSubmit={handleMessageSubmit} className="mt-4 flex gap-2">
          <Input
            ref={inputRef}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask about markets, get trading ideas, or analyze trends..."
            className="flex-1"
            disabled={isAnalyzing}
          />
          <Button type="submit" disabled={isAnalyzing} className="w-24">
            {isAnalyzing ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <>
                <Send className="h-4 w-4 mr-2" />
                Send
              </>
            )}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-ui/data-visualization.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { useCompletion } from "ai/react"
import {
  LineChart,
  BarChart,
  PieChart,
  Pie,
  Line,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts"
import { Settings, LineChartIcon, BarChartIcon, PieChartIcon, LoaderIcon } from "lucide-react"
interface ChartConfig {
  type: "line" | "bar" | "pie"
  data: any[]
  title: string
  description?: string
  metrics: string[]
  colors: string[]
}
export function GenerativeDataVisualization() {
  const [query, setQuery] = useState("")
  const [chartType, setChartType] = useState<"line" | "bar" | "pie">("line")
  const [chartConfig, setChartConfig] = useState<ChartConfig | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const { complete } = useCompletion({
    api: "/api/generate-visualization",
  })
  const generateVisualization = async () => {
    if (!query.trim()) {
      return
    }
    setIsLoading(true)
    try {
      const prompt = `Generate a data visualization configuration for: ${query}
      Format the response as a JSON object with the following structure:
      {
        "type": "line" | "bar" | "pie",
        "data": Array<{ name: string, [key: string]: number }>,
        "title": string,
        "description": string,
        "metrics": string[],
        "colors": string[]
      }`
      const response = await complete(prompt)
      if (!response) {
        throw new Error("No response from AI model")
      }
      // Try to find a JSON object in the response
      const jsonMatch = response.match(/\{[\s\S]*\}/)
      if (!jsonMatch) {
        throw new Error("Invalid response format")
      }
      try {
        const config = JSON.parse(jsonMatch[0])
        // Validate the config
        if (!config.type || !config.data || !config.title || !config.metrics || !config.colors) {
          throw new Error("Missing required fields in configuration")
        }
        // Ensure the type matches the selected chart type
        config.type = chartType
        // Ensure colors are valid hex codes
        config.colors = config.colors.map((color: string) => {
          if (!/^#[0-9A-F]{6}$/i.test(color)) {
            return `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`
          }
          return color
        })
        // Ensure data is properly formatted
        config.data = config.data.map((item: any) => {
          const formattedItem: any = { name: String(item.name || '') }
          config.metrics.forEach((metric: string) => {
            formattedItem[metric] = Number(item[metric]) || 0
          })
          return formattedItem
        })
        setChartConfig(config)
      } catch (parseError) {
        console.error("Error parsing configuration:", parseError)
        throw new Error("Failed to parse visualization configuration")
      }
    } catch (error) {
      console.error("Error generating visualization:", error)
      // Show error state in UI
      setChartConfig({
        type: chartType,
        data: [],
        title: "Error Generating Visualization",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        metrics: [],
        colors: []
      })
    } finally {
      setIsLoading(false)
    }
  }
  const renderChart = () => {
    if (!chartConfig) return null
    const ChartComponent = chartType === "line" ? LineChart : chartType === "bar" ? BarChart : PieChart
    return (
      <ResponsiveContainer width="100%" height={400}>
        <ChartComponent data={chartConfig.data}>
          {chartType !== "pie" && (
            <>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
            </>
          )}
          <Tooltip />
          <Legend />
          {chartType === "line" &&
            chartConfig.metrics.map((metric, index) => (
              <Line key={metric} type="monotone" dataKey={metric} stroke={chartConfig.colors[index]} strokeWidth={2} />
            ))}
          {chartType === "bar" &&
            chartConfig.metrics.map((metric, index) => (
              <Bar key={metric} dataKey={metric} fill={chartConfig.colors[index]} />
            ))}
          {chartType === "pie" &&
            chartConfig.metrics.map((metric, index) => (
              <Pie
                key={metric}
                data={chartConfig.data}
                dataKey={metric}
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={80}
                fill={chartConfig.colors[index]}
                label
              />
            ))}
        </ChartComponent>
      </ResponsiveContainer>
    )
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Generative Data Visualization</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex items-center space-x-4 mb-6">
          <Input
            placeholder="Describe what you want to visualize..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            className="flex-1"
          />
          <Select value={chartType} onValueChange={(value: "line" | "bar" | "pie") => setChartType(value)}>
            <SelectTrigger className="w-[140px]">
              <SelectValue placeholder="Chart Type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="line">
                <div className="flex items-center">
                  <LineChartIcon className="w-4 h-4 mr-2" />
                  Line Chart
                </div>
              </SelectItem>
              <SelectItem value="bar">
                <div className="flex items-center">
                  <BarChartIcon className="w-4 h-4 mr-2" />
                  Bar Chart
                </div>
              </SelectItem>
              <SelectItem value="pie">
                <div className="flex items-center">
                  <PieChartIcon className="w-4 h-4 mr-2" />
                  Pie Chart
                </div>
              </SelectItem>
            </SelectContent>
          </Select>
          <Button onClick={generateVisualization} disabled={isLoading}>
            {isLoading ? <LoaderIcon className="w-4 h-4 mr-2 animate-spin" /> : <Settings className="w-4 h-4 mr-2" />}
            Generate
          </Button>
        </div>
        {chartConfig ? (
          <div>
            <h3 className="text-lg font-semibold mb-2">{chartConfig.title}</h3>
            {chartConfig.description && <p className="text-sm text-muted-foreground mb-4">{chartConfig.description}</p>}
            {renderChart()}
          </div>
        ) : (
          <div className="flex items-center justify-center h-[400px] border rounded-lg bg-muted/5">
            <p className="text-muted-foreground">Describe what you want to visualize and click Generate</p>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-ui/market-insights.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { useCompletion } from "ai/react"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ScrollArea } from "@/components/ui/scroll-area"
import { TrendingUp, TrendingDown, RefreshCw, Search, LineChart } from "lucide-react"
import { ResponsiveContainer, LineChart as RechartsLineChart, Line, XAxis, YAxis, Tooltip } from "recharts"
interface InsightCard {
  title: string
  description: string
  type: "bullish" | "bearish" | "neutral"
  probability: number
  timeframe: string
  tickers: string[]
  chart?: any[]
}
export function GenerativeMarketInsights() {
  const [searchQuery, setSearchQuery] = useState("")
  const [activeTab, setActiveTab] = useState("generated")
  const [insights, setInsights] = useState<InsightCard[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const { complete } = useCompletion({
    api: "/api/generate-insights",
  })
  const generateInsights = async () => {
    setIsGenerating(true)
    try {
      const response = await complete(searchQuery || "Generate market insights for major indices")
      const newInsights = JSON.parse(response)
      setInsights(newInsights)
    } catch (error) {
      console.error("Error generating insights:", error)
    } finally {
      setIsGenerating(false)
    }
  }
  const getInsightIcon = (type: string) => {
    switch (type) {
      case "bullish":
        return <TrendingUp className="h-5 w-5 text-green-500" />
      case "bearish":
        return <TrendingDown className="h-5 w-5 text-red-500" />
      default:
        return <LineChart className="h-5 w-5 text-yellow-500" />
    }
  }
  const renderChart = (data: any[]) => {
    if (!data) return null
    return (
      <div className="h-[150px] mt-4">
        <ResponsiveContainer width="100%" height="100%">
          <RechartsLineChart data={data}>
            <XAxis dataKey="time" hide />
            <YAxis hide />
            <Tooltip />
            <Line
              type="monotone"
              dataKey="value"
              stroke={
                insights[0]?.type === "bullish" ? "#10B981" : insights[0]?.type === "bearish" ? "#EF4444" : "#F59E0B"
              }
              dot={false}
            />
          </RechartsLineChart>
        </ResponsiveContainer>
      </div>
    )
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>AI Market Insights</CardTitle>
            <CardDescription>Generated analysis and predictions</CardDescription>
          </div>
          <div className="flex items-center space-x-2">
            <Input
              placeholder="Search or describe market conditions..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-[300px]"
            />
            <Button onClick={generateInsights} disabled={isGenerating}>
              {isGenerating ? <RefreshCw className="h-4 w-4 animate-spin" /> : <Search className="h-4 w-4" />}
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="mb-4">
            <TabsTrigger value="generated">Generated Insights</TabsTrigger>
            <TabsTrigger value="technical">Technical Analysis</TabsTrigger>
            <TabsTrigger value="sentiment">Market Sentiment</TabsTrigger>
          </TabsList>
          <TabsContent value="generated">
            <ScrollArea className="h-[500px] pr-4">
              <div className="space-y-4">
                {insights.map((insight, index) => (
                  <Card key={index} className="p-4">
                    <div className="flex items-start justify-between">
                      <div className="flex items-start gap-3">
                        {getInsightIcon(insight.type)}
                        <div>
                          <h3 className="font-semibold mb-1">{insight.title}</h3>
                          <p className="text-sm text-muted-foreground mb-2">{insight.description}</p>
                          <div className="flex flex-wrap gap-2">
                            {insight.tickers.map((ticker) => (
                              <Badge key={ticker} variant="outline">
                                ${ticker}
                              </Badge>
                            ))}
                            <Badge
                              variant="outline"
                              className={
                                insight.type === "bullish"
                                  ? "bg-green-500/10 text-green-500"
                                  : insight.type === "bearish"
                                    ? "bg-red-500/10 text-red-500"
                                    : "bg-yellow-500/10 text-yellow-500"
                              }
                            >
                              {insight.probability}% Probability
                            </Badge>
                            <Badge variant="outline" className="bg-blue-500/10 text-blue-500">
                              {insight.timeframe}
                            </Badge>
                          </div>
                          {renderChart(insight.chart)}
                        </div>
                      </div>
                    </div>
                  </Card>
                ))}
              </div>
            </ScrollArea>
          </TabsContent>
          {/* Add content for other tabs */}
        </Tabs>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-ui/trade-suggestions.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { useCompletion } from "ai/react"
import { TrendingUp, TrendingDown, RefreshCw, ArrowUpRight, Target, Shield } from "lucide-react"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Progress } from "@/components/ui/progress"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
interface TradeSuggestion {
  id: string
  ticker: string
  type: "long" | "short"
  entry: number
  target: number
  stopLoss: number
  timeframe: string
  confidence: number
  reasoning: string
  signals: {
    technical: number
    sentiment: number
    fundamental: number
  }
  riskLevel: "low" | "medium" | "high"
  expectedReturn: number
  timestamp: Date
}
export function GenerativeTradeSuggestions() {
  const [suggestions, setSuggestions] = useState<TradeSuggestion[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const { complete } = useCompletion({
    api: "/api/generate-trades",
  })
  const generateMockSuggestions = useCallback((): TradeSuggestion[] => {
    return [
      {
        id: "mock1",
        ticker: "AAPL",
        type: "long",
        entry: 150,
        target: 165,
        stopLoss: 145,
        timeframe: "2 weeks",
        confidence: 75,
        reasoning: "Strong technical setup with bullish divergence on RSI",
        signals: {
          technical: 80,
          sentiment: 65,
          fundamental: 70,
        },
        riskLevel: "medium",
        expectedReturn: 10,
        timestamp: new Date(),
      },
      {
        id: "mock2",
        ticker: "TSLA",
        type: "short",
        entry: 200,
        target: 180,
        stopLoss: 210,
        timeframe: "1 week",
        confidence: 65,
        reasoning: "Bearish trend and negative sentiment due to recent news",
        signals: {
          technical: 70,
          sentiment: 60,
          fundamental: 55,
        },
        riskLevel: "high",
        expectedReturn: 8,
        timestamp: new Date(),
      },
    ]
  }, [])
  const generateSuggestions = useCallback(async () => {
    setIsGenerating(true)
    setError(null)
    try {
      const prompt = `Generate trade suggestions for the current market conditions. Consider technical analysis, market sentiment, and fundamental factors. Format the response as a JSON array of trade suggestions with the following structure:
      {
        "id": "string",
        "ticker": "string",
        "type": "long" | "short",
        "entry": number,
        "target": number,
        "stopLoss": number,
        "timeframe": "string",
        "confidence": number,
        "reasoning": "string",
        "signals": {
          "technical": number,
          "sentiment": number,
          "fundamental": number
        },
        "riskLevel": "low" | "medium" | "high",
        "expectedReturn": number
      }`
      const response = await complete(prompt)
      console.log("Raw AI response:", response)
      if (!response) {
        console.log("No response from AI model, using mock data")
        setSuggestions(generateMockSuggestions())
        return
      }
      // Try to find a JSON array in the response
      const jsonMatch = response.match(/\[[\s\S]*\]/)
      if (!jsonMatch) {
        console.log("No JSON array found in response, using mock data")
        setSuggestions(generateMockSuggestions())
        return
      }
      try {
        const parsedSuggestions = JSON.parse(jsonMatch[0])
        if (!Array.isArray(parsedSuggestions)) {
          console.error("Parsed response is not an array:", parsedSuggestions)
          setSuggestions(generateMockSuggestions())
          return
        }
        // Validate and transform each suggestion
        const validSuggestions = parsedSuggestions.map(suggestion => ({
          ...suggestion,
          id: suggestion.id || Math.random().toString(36).substr(2, 9),
          timestamp: new Date(),
          entry: Number(suggestion.entry),
          target: Number(suggestion.target),
          stopLoss: Number(suggestion.stopLoss),
          confidence: Number(suggestion.confidence),
          expectedReturn: Number(suggestion.expectedReturn),
          signals: {
            technical: Number(suggestion.signals?.technical || 0),
            sentiment: Number(suggestion.signals?.sentiment || 0),
            fundamental: Number(suggestion.signals?.fundamental || 0)
          }
        }))
        setSuggestions(validSuggestions)
      } catch (parseError) {
        console.error("Error parsing AI response:", parseError)
        setSuggestions(generateMockSuggestions())
      }
    } catch (error) {
      console.error("Error generating suggestions:", error)
      setError(`Error generating suggestions: ${error instanceof Error ? error.message : String(error)}`)
      setSuggestions(generateMockSuggestions())
    } finally {
      setIsGenerating(false)
    }
  }, [complete, generateMockSuggestions])
  useEffect(() => {
    generateSuggestions()
  }, [generateSuggestions])
  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 80) return "text-green-500"
    if (confidence >= 60) return "text-yellow-500"
    return "text-red-500"
  }
  const getRiskBadge = (risk: string) => {
    switch (risk) {
      case "low":
        return (
          <Badge variant="outline" className="bg-green-500/10 text-green-500">
            Low Risk
          </Badge>
        )
      case "medium":
        return (
          <Badge variant="outline" className="bg-yellow-500/10 text-yellow-500">
            Medium Risk
          </Badge>
        )
      case "high":
        return (
          <Badge variant="outline" className="bg-red-500/10 text-red-500">
            High Risk
          </Badge>
        )
      default:
        return null
    }
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>AI Trade Suggestions</CardTitle>
            <CardDescription>Generated trading opportunities based on market analysis</CardDescription>
          </div>
          <Button onClick={generateSuggestions} disabled={isGenerating}>
            {isGenerating ? (
              <RefreshCw className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {isGenerating && (
          <div className="flex items-center justify-center p-4">
            <RefreshCw className="h-6 w-6 animate-spin mr-2" />
            <p>Generating trade suggestions...</p>
          </div>
        )}
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertTitle>Error</AlertTitle>
            <AlertDescription>
              {error}
              <p className="mt-2 text-sm">Please try refreshing or contact support if the problem persists.</p>
            </AlertDescription>
          </Alert>
        )}
        <ScrollArea className="h-[600px]">
          <div className="space-y-4">
            {suggestions.length === 0 && !isGenerating && !error && (
              <div className="text-center text-muted-foreground">
                No trade suggestions available. Click 'Refresh' to generate new suggestions.
              </div>
            )}
            {suggestions.map((suggestion) => (
              <Card key={suggestion.id} className="p-4">
                <div className="flex items-start justify-between mb-4">
                  <div className="flex items-center space-x-2">
                    {suggestion.type === "long" ? (
                      <TrendingUp className="h-5 w-5 text-green-500" />
                    ) : (
                      <TrendingDown className="h-5 w-5 text-red-500" />
                    )}
                    <div>
                      <h3 className="font-semibold text-lg">${suggestion.ticker}</h3>
                      <p className="text-sm text-muted-foreground">
                        {suggestion.type.toUpperCase()} • {suggestion.timeframe}
                      </p>
                    </div>
                  </div>
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger>
                        <Badge variant="outline" className={`${getConfidenceColor(suggestion.confidence)}`}>
                          {suggestion.confidence}% Confidence
                        </Badge>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>AI-generated confidence score based on multiple factors</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </div>
                <div className="grid grid-cols-3 gap-4 mb-4">
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <Target className="h-4 w-4" />
                      <span className="text-sm text-muted-foreground">Entry</span>
                    </div>
                    <p className="font-semibold">${suggestion.entry.toFixed(2)}</p>
                  </div>
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <ArrowUpRight className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-muted-foreground">Target</span>
                    </div>
                    <p className="font-semibold text-green-500">${suggestion.target.toFixed(2)}</p>
                  </div>
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <Shield className="h-4 w-4 text-red-500" />
                      <span className="text-sm text-muted-foreground">Stop Loss</span>
                    </div>
                    <p className="font-semibold text-red-500">${suggestion.stopLoss.toFixed(2)}</p>
                  </div>
                </div>
                <div className="space-y-2 mb-4">
                  <p className="text-sm">{suggestion.reasoning}</p>
                </div>
                <div className="space-y-3">
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Technical Analysis</span>
                      <span className="text-sm font-medium">{suggestion.signals.technical}%</span>
                    </div>
                    <Progress value={suggestion.signals.technical} className="h-2" />
                  </div>
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Sentiment Analysis</span>
                      <span className="text-sm font-medium">{suggestion.signals.sentiment}%</span>
                    </div>
                    <Progress value={suggestion.signals.sentiment} className="h-2" />
                  </div>
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Fundamental Analysis</span>
                      <span className="text-sm font-medium">{suggestion.signals.fundamental}%</span>
                    </div>
                    <Progress value={suggestion.signals.fundamental} className="h-2" />
                  </div>
                </div>
                <div className="flex justify-between items-center mt-4 pt-4 border-t">
                  <div className="flex items-center space-x-2">
                    {getRiskBadge(suggestion.riskLevel)}
                    <Badge variant="outline" className="bg-blue-500/10 text-blue-500">
                      {suggestion.expectedReturn}% Expected Return
                    </Badge>
                  </div>
                  <span className="text-xs text-muted-foreground">
                    Generated {new Date(suggestion.timestamp).toLocaleTimeString()}
                  </span>
                </div>
              </Card>
            ))}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/market/MarketDataCard.tsx">
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useMarketData } from '@/lib/hooks/use-market-data';
interface MarketDataCardProps {
  symbol: string;
  refreshInterval?: number;
}
export function MarketDataCard({ symbol, refreshInterval }: MarketDataCardProps) {
  const { data, error, isLoading } = useMarketData([symbol], {
    refreshInterval,
    useWebSocket: true,
  });
  const marketData = data[symbol];
  if (error) {
    return (
      <Card className="min-w-[300px]">
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            {symbol}
            <Badge variant="destructive">Error</Badge>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-destructive">{error.message}</p>
        </CardContent>
      </Card>
    );
  }
  if (isLoading || !marketData) {
    return (
      <Card className="min-w-[300px]">
        <CardHeader>
          <CardTitle>{symbol}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse space-y-2">
            <div className="h-4 w-24 bg-muted rounded" />
            <div className="h-4 w-16 bg-muted rounded" />
          </div>
        </CardContent>
      </Card>
    );
  }
  const changeColor = marketData.change >= 0 ? 'text-green-500' : 'text-red-500';
  const dataSource = marketData.metadata.source === 'websocket' ? 'Real-time' : 'Delayed';
  const reliability = Math.round(marketData.metadata.reliability * 100);
  return (
    <Card className="min-w-[300px]">
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          {symbol}
          <Badge
            variant={marketData.metadata.source === 'websocket' ? 'success' : 'warning'}
          >
            {dataSource} ({reliability}%)
          </Badge>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-2">
        <div className="flex justify-between items-center">
          <span className="text-sm font-medium">Price</span>
          <span className="text-2xl font-bold">
            ${marketData.price.toFixed(2)}
          </span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm font-medium">Change</span>
          <div className="space-x-2">
            <span className={`text-sm font-medium ${changeColor}`}>
              ${marketData.change.toFixed(2)}
            </span>
            <span className={`text-sm font-medium ${changeColor}`}>
              ({marketData.changePercent.toFixed(2)}%)
            </span>
          </div>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm font-medium">Volume</span>
          <span className="text-sm">
            {marketData.volume.toLocaleString()}
          </span>
        </div>
        <div className="text-xs text-muted-foreground text-right">
          Last updated: {new Date(marketData.lastUpdated).toLocaleTimeString()}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/market/MarketDataGrid.tsx">
import React from 'react';
import { MarketDataCard } from './MarketDataCard';
interface MarketDataGridProps {
  symbols: string[];
  refreshInterval?: number;
  className?: string;
}
export function MarketDataGrid({
  symbols,
  refreshInterval,
  className = '',
}: MarketDataGridProps) {
  return (
    <div
      className={`grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 ${className}`}
    >
      {symbols.map((symbol) => (
        <MarketDataCard
          key={symbol}
          symbol={symbol}
          refreshInterval={refreshInterval}
        />
      ))}
    </div>
  );
}
</file>

<file path="components/market-status-header/charts-and-news.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts"
import { GenerativeNewsUpdates } from "@/components/generative-news-updates"
interface ChartData {
  time: number
  value: number
}
interface SectorPerformance {
  name: string
  value: number
}
const mockChartData: ChartData[] = Array.from({ length: 20 }, (_, i) => ({
  time: i,
  value: 1000 + Math.random() * 200,
}))
const mockSectorPerformance: SectorPerformance[] = [
  { name: "Technology", value: 2.31 },
  { name: "Healthcare", value: -0.54 },
  { name: "Financials", value: 1.12 },
  { name: "Energy", value: -1.87 },
  { name: "Consumer", value: 0.76 },
]
export function ChartsAndNews() {
  return (
    <div className="grid grid-cols-2 gap-2">
      <Card className="col-span-1">
        <CardContent className="p-2">
          <Tabs defaultValue="chart" className="w-full">
            <TabsList className="w-full">
              <TabsTrigger value="chart" className="text-xs">
                Market Overview
              </TabsTrigger>
              <TabsTrigger value="sectors" className="text-xs">
                Sector Performance
              </TabsTrigger>
            </TabsList>
            <TabsContent value="chart" className="mt-2">
              <ResponsiveContainer width="100%" height={200}>
                <AreaChart data={mockChartData}>
                  <XAxis dataKey="time" hide />
                  <YAxis hide />
                  <Tooltip />
                  <Area type="monotone" dataKey="value" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} />
                </AreaChart>
              </ResponsiveContainer>
            </TabsContent>
            <TabsContent value="sectors" className="mt-2">
              <div className="space-y-1">
                {mockSectorPerformance.map((sector) => (
                  <div key={sector.name} className="flex justify-between items-center">
                    <span className="text-xs">{sector.name}</span>
                    <Badge variant={sector.value >= 0 ? "success" : "destructive"} className="text-xs">
                      {sector.value > 0 ? "+" : ""}
                      {sector.value.toFixed(2)}%
                    </Badge>
                  </div>
                ))}
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
      <Card className="col-span-1">
        <CardContent className="p-2">
          <h4 className="text-xs font-semibold mb-2">Latest Market News</h4>
          <ScrollArea className="h-[200px]">
            <GenerativeNewsUpdates />
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/market-status-header/index.tsx">
"use client"
import { useState, useEffect } from "react"
import { useTheme } from "next-themes"
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Globe2, Moon, Sun, Clock } from "lucide-react"
import { useMarketHours } from "@/lib/hooks/use-market-hours"
import { LiveTickerBar } from "@/components/live-ticker-bar"
import { TickerConfig } from "./ticker-config-dialog"
export function MarketStatusHeader() {
  const [currentTime, setCurrentTime] = useState<Date | null>(null)
  const { marketHours, isLoading: isLoadingHours, isError: isErrorHours } = useMarketHours()
  const { setTheme, theme } = useTheme()
  const [mounted, setMounted] = useState(false)
  const [tickerConfig, setTickerConfig] = useState<TickerConfig>({
    preset: 'trending',
    sector: undefined,
    customTickers: [],
    maxTickers: 20
  })
  // Handle hydration
  useEffect(() => {
    setMounted(true)
  }, [])
  // Only start the timer after hydration
  useEffect(() => {
    if (!mounted) return
    setCurrentTime(new Date())
    const timer = setInterval(() => setCurrentTime(new Date()), 1000)
    return () => clearInterval(timer)
  }, [mounted])
  const getMarketStatusIcon = (status: string) => {
    switch (status) {
      case "during":
        return <Globe2 className="h-4 w-4 text-green-500" />
      case "after":
        return <Moon className="h-4 w-4 text-gray-500" />
      case "pre":
        return <Sun className="h-4 w-4 text-yellow-500" />
      default:
        return <Globe2 className="h-4 w-4 text-muted-foreground" />
    }
  }
  const formattedTime = mounted && currentTime
    ? currentTime.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
    : "Loading..."
  return (
    <Card className="rounded-none border-x-0">
      <CardContent className="p-2">
        <div className="flex items-center justify-between bg-muted/50 p-2 rounded-md">
          <div className="flex items-center space-x-2">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
              className="h-6 w-6"
              disabled={!mounted}
            >
              {mounted && (theme === "dark" ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />)}
            </Button>
            {!isLoadingHours && !isErrorHours && marketHours && (
              <Badge
                variant={marketHours === "during" ? "default" : marketHours === "after" ? "secondary" : "outline"}
                className="text-xs px-2 py-0.5 flex items-center"
              >
                {getMarketStatusIcon(marketHours)}
                <span className="ml-1">
                  {marketHours === "during" ? "Market Open" : marketHours === "after" ? "After Hours" : "Pre-Market"}
                </span>
              </Badge>
            )}
          </div>
          <div className="flex items-center space-x-2">
            <Clock className="h-4 w-4 text-muted-foreground" />
            <span className="text-xs font-medium">
              {formattedTime}
            </span>
          </div>
        </div>
        <LiveTickerBar config={tickerConfig} onConfigUpdate={setTickerConfig} />
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/market-status-header/live-ticker-wrapper.tsx">
import { LiveTickerBar } from "@/components/live-ticker-bar"
import { useEffect, useState, useCallback } from "react"
import { TickerConfig, DEFAULT_CONFIG } from "./ticker-config-dialog"
const STORAGE_KEY = "tickerConfig"
export function LiveTickerWrapper() {
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [config, setConfig] = useState<TickerConfig>(DEFAULT_CONFIG)
  // Load config from localStorage
  useEffect(() => {
    try {
      const savedConfig = localStorage.getItem(STORAGE_KEY)
      if (savedConfig) {
        const parsedConfig = JSON.parse(savedConfig)
        if (isValidConfig(parsedConfig)) {
          setConfig(parsedConfig)
        }
      }
    } catch (error) {
      console.error('Error loading ticker config:', error)
    } finally {
      setIsLoading(false)
    }
  }, [])
  const isValidConfig = (config: any): config is TickerConfig => {
    return (
      config &&
      typeof config === 'object' &&
      typeof config.preset === 'string' &&
      Array.isArray(config.customTickers) &&
      (typeof config.maxTickers === 'number' || config.maxTickers === undefined) &&
      (typeof config.sector === 'string' || config.sector === undefined)
    )
  }
  const handleConfigUpdate = useCallback((newConfig: TickerConfig) => {
    try {
      if (!isValidConfig(newConfig)) {
        throw new Error('Invalid configuration format')
      }
      // Validate preset-specific requirements
      if (newConfig.preset === 'sector' && !newConfig.sector) {
        throw new Error('Sector must be selected for sector preset')
      }
      if (newConfig.preset === 'custom' && (!Array.isArray(newConfig.customTickers) || newConfig.customTickers.length === 0)) {
        throw new Error('Custom tickers must be provided for custom preset')
      }
      // Create a clean config object
      const validConfig: TickerConfig = {
        preset: newConfig.preset,
        customTickers: Array.isArray(newConfig.customTickers) ? newConfig.customTickers : [],
        maxTickers: newConfig.maxTickers || 20,
        sector: newConfig.preset === 'sector' ? newConfig.sector : undefined
      }
      // Update state
      setConfig(validConfig)
      // Save to localStorage
      localStorage.setItem(STORAGE_KEY, JSON.stringify(validConfig))
      // Clear any existing errors
      setError(null)
    } catch (error) {
      console.error('Error updating ticker config:', error)
      setError(error instanceof Error ? error.message : 'Failed to save configuration')
    }
  }, [])
  return (
    <div className="w-full">
      <LiveTickerBar
        config={config}
        onConfigUpdate={handleConfigUpdate}
        isLoading={isLoading}
      />
      {error && (
        <div className="text-sm text-red-500 mt-1">
          {error}
        </div>
      )}
    </div>
  )
}
</file>

<file path="components/market-status-header/market-overview.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Badge } from "@/components/ui/badge"
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer } from "recharts"
import { useState, useEffect } from "react"
import { Skeleton } from "@/components/ui/skeleton"
import { useMarketIndices } from "@/lib/hooks/use-market-indices"
interface ChartData {
  time: number
  value: number
}
interface IndexData {
  name: string
  value: number
  change: number
}
interface SectorPerformance {
  name: string
  value: number
}
const mockIndices: IndexData[] = [
  { name: "S&P 500", value: 4185.81, change: 0.45 },
  { name: "NASDAQ", value: 12888.28, change: 0.73 },
  { name: "DOW", value: 33875.4, change: -0.23 },
  { name: "VIX", value: 15.65, change: -5.21 },
]
const mockChartData: ChartData[] = Array.from({ length: 20 }, (_, i) => ({
  time: i,
  value: 1000 + Math.random() * 200,
}))
const mockSectorPerformance: SectorPerformance[] = [
  { name: "Technology", value: 2.31 },
  { name: "Healthcare", value: -0.54 },
  { name: "Financials", value: 1.12 },
  { name: "Energy", value: -1.87 },
  { name: "Consumer", value: 0.76 },
]
export const DEFAULT_CONFIG: TickerConfig = {
  preset: "trending" as TickerPreset,
  customTickers: [],
  maxTickers: 20,
  sector: undefined // Optional field
}
export function MarketOverview() {
  const { indices, isLoading, error } = useMarketIndices()
  if (error) {
    return (
      <div className="text-sm text-red-500 p-4">
        {error}
      </div>
    )
  }
  if (isLoading) {
    return (
      <Card>
        <CardContent className="p-4">
          <div className="flex justify-between items-center">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="text-center">
                <Skeleton className="h-4 w-20 mb-2" />
                <Skeleton className="h-6 w-24 mb-2" />
                <Skeleton className="h-5 w-16" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    )
  }
  return (
    <Card>
      <CardContent className="p-4">
        <div className="flex justify-between items-center">
          {indices.map((index) => (
            <div key={index.symbol} className="text-center">
              <div className="text-sm font-medium">{index.name}</div>
              <div className="text-lg font-bold">{index.value.toFixed(2)}</div>
              <Badge variant={index.changePercent >= 0 ? "default" : "destructive"}>
                {index.changePercent >= 0 ? "+" : ""}
                {index.changePercent.toFixed(2)}%
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
export function LiveTickerWrapper() {
  // Initialize with DEFAULT_CONFIG immediately
  const [config, setConfig] = useState<TickerConfig>(DEFAULT_CONFIG)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  // Load config from localStorage
  useEffect(() => {
    try {
      const savedConfig = localStorage.getItem(STORAGE_KEY)
      if (savedConfig) {
        const parsedConfig = JSON.parse(savedConfig)
        // Validate the config structure
        if (
          parsedConfig &&
          typeof parsedConfig === 'object' &&
          'preset' in parsedConfig &&
          'customTickers' in parsedConfig &&
          'maxTickers' in parsedConfig &&
          Array.isArray(parsedConfig.customTickers)
        ) {
          setConfig(parsedConfig)
        }
      }
    } catch (error) {
      console.error('Error loading ticker config:', error)
      // Keep using DEFAULT_CONFIG if there's an error
    } finally {
      setIsLoading(false)
    }
  }, [])
  // Rest of the component remains the same...
}
export function TickerConfigDialog({ 
  open, 
  onOpenChange, 
  onSave,
  currentConfig = DEFAULT_CONFIG // Provide default value
}: TickerConfigDialogProps) {
  const [config, setConfig] = useState<TickerConfig>(currentConfig)
  // Update local state when currentConfig changes
  useEffect(() => {
    if (currentConfig) {
      setConfig(currentConfig)
    }
  }, [currentConfig])
  // Rest of the component remains the same...
}
</file>

<file path="components/market-status-header/news-panel.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { ScrollArea } from "@/components/ui/scroll-area"
import { GenerativeNewsUpdates } from "@/components/generative-news-updates"
export function NewsPanel() {
  return (
    <Card>
      <CardContent className="p-4">
        <h4 className="text-sm font-semibold mb-2">Latest Market News</h4>
        <ScrollArea className="h-[200px]">
          <GenerativeNewsUpdates />
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/market-status-header/right-sidebar.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Badge } from "@/components/ui/badge"
import { TrendingUp, AlertTriangle, Zap } from "lucide-react"
import type React from "react" // Import React
interface AIInsight {
  type: string
  content: string
  icon: React.ElementType
}
interface EconomicEvent {
  time: string
  event: string
  impact: "high" | "medium" | "low"
}
const mockAIInsights: AIInsight[] = [
  { type: "trend", content: "Tech sector showing bullish momentum", icon: TrendingUp },
  { type: "alert", content: "Potential market volatility due to upcoming Fed announcement", icon: AlertTriangle },
  { type: "prediction", content: "AI predicts 70% chance of S&P 500 closing higher", icon: Zap },
]
const mockEconomicEvents: EconomicEvent[] = [
  { time: "10:00", event: "US Consumer Confidence", impact: "high" },
  { time: "14:00", event: "Fed Interest Rate Decision", impact: "high" },
  { time: "16:30", event: "EIA Crude Oil Stocks Change", impact: "medium" },
]
export function RightSidebar() {
  return (
    <div className="col-span-3 space-y-2">
      <Card>
        <CardContent className="p-2">
          <h4 className="text-xs font-semibold mb-2">AI Market Insights</h4>
          <ScrollArea className="h-[120px]">
            {mockAIInsights.map((insight, index) => (
              <div key={index} className="flex items-start space-x-2 mb-2">
                <insight.icon className="h-4 w-4 mt-0.5 text-primary" />
                <p className="text-xs">{insight.content}</p>
              </div>
            ))}
          </ScrollArea>
        </CardContent>
      </Card>
      <Card>
        <CardContent className="p-2">
          <h4 className="text-xs font-semibold mb-2">Economic Calendar</h4>
          <ScrollArea className="h-[120px]">
            <div className="space-y-2">
              {mockEconomicEvents.map((item, index) => (
                <div key={index} className="flex items-center justify-between">
                  <span className="text-xs">{item.time}</span>
                  <span className="text-xs flex-1 mx-2">{item.event}</span>
                  <Badge variant={item.impact === "high" ? "destructive" : "secondary"} className="text-[10px]">
                    {item.impact}
                  </Badge>
                </div>
              ))}
            </div>
          </ScrollArea>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/market-status-header/ticker-config-dialog.tsx">
import { useState, useEffect } from "react"
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { X } from "lucide-react"
export type TickerPreset = 
  | "trending"
  | "gainers"
  | "losers"
  | "mixed"
  | "sp500"
  | "weighted"
  | "marketCap"
  | "sector"
  | "indices"
  | "custom";
interface TickerConfigDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  onSave: (config: TickerConfig) => void
  currentConfig: TickerConfig
}
export interface TickerConfig {
  preset: TickerPreset
  customTickers: string[]
  sector?: string
  maxTickers: number
}
export const DEFAULT_CONFIG: TickerConfig = {
  preset: "trending",
  customTickers: [],
  maxTickers: 20,
}
const PRESET_OPTIONS = [
  { value: "trending", label: "Top Trending" },
  { value: "gainers", label: "Biggest Gainers" },
  { value: "losers", label: "Biggest Losers" },
  { value: "mixed", label: "Mixed Performance" },
  { value: "sp500", label: "S&P 500 Components" },
  { value: "weighted", label: "Top Weighted" },
  { value: "marketCap", label: "Largest Market Cap" },
  { value: "sector", label: "By Sector" },
  { value: "indices", label: "Major Indices" },
  { value: "custom", label: "Custom Selection" },
] as const
const SECTORS = [
  "Technology",
  "Healthcare",
  "Financials",
  "Consumer Discretionary",
  "Consumer Staples",
  "Industrials",
  "Energy",
  "Materials",
  "Utilities",
  "Real Estate",
  "Communication Services",
] as const
export function TickerConfigDialog({ 
  open, 
  onOpenChange, 
  onSave,
  currentConfig = DEFAULT_CONFIG
}: TickerConfigDialogProps) {
  const [config, setConfig] = useState<TickerConfig>(currentConfig)
  const [activeTab, setActiveTab] = useState<string>("presets")
  const [newTicker, setNewTicker] = useState("")
  // Update local state when currentConfig changes
  useEffect(() => {
    if (currentConfig) {
      setConfig(currentConfig)
    }
  }, [currentConfig])
  const handleSave = () => {
    // Validate config before saving
    const validConfig: TickerConfig = {
      preset: config.preset,
      customTickers: config.customTickers || [],
      maxTickers: config.maxTickers || 20,
      sector: config.preset === 'sector' ? config.sector : undefined
    }
    // Only save if we have a valid preset
    if (validConfig.preset === 'sector' && !validConfig.sector) {
      return // Don't save if sector preset is selected but no sector is chosen
    }
    if (validConfig.preset === 'custom' && validConfig.customTickers.length === 0) {
      return // Don't save if custom preset is selected but no tickers are added
    }
    onSave(validConfig)
    onOpenChange(false)
  }
  const addCustomTicker = () => {
    if (newTicker && !config.customTickers.includes(newTicker.toUpperCase())) {
      setConfig(prev => ({
        ...prev,
        customTickers: [...prev.customTickers, newTicker.toUpperCase()],
      }))
      setNewTicker("")
    }
  }
  const removeCustomTicker = (ticker: string) => {
    setConfig(prev => ({
      ...prev,
      customTickers: prev.customTickers.filter(t => t !== ticker),
    }))
  }
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Configure Ticker Display</DialogTitle>
        </DialogHeader>
        <Tabs 
          defaultValue={activeTab}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <TabsList className="grid grid-cols-2 mb-4">
            <TabsTrigger value="presets">Presets</TabsTrigger>
            <TabsTrigger value="custom">Custom</TabsTrigger>
          </TabsList>
          <TabsContent value="presets">
            <div className="grid grid-cols-2 gap-4 mb-8">
              {PRESET_OPTIONS.map(preset => (
                <Button
                  key={preset.value}
                  variant={config.preset === preset.value ? "default" : "outline"}
                  onClick={() => setConfig(prev => ({ 
                    ...prev, 
                    preset: preset.value as TickerPreset,
                    // Clear sector when switching to non-sector preset
                    sector: preset.value === "sector" ? prev.sector : undefined 
                  }))}
                  className="justify-start"
                >
                  {preset.label}
                </Button>
              ))}
            </div>
            {config.preset === "sector" && (
              <div className="mt-4">
                <h4 className="mb-2 font-medium">Select Sector</h4>
                <div className="grid grid-cols-2 gap-2">
                  {SECTORS.map(sector => (
                    <Button
                      key={sector}
                      variant={config.sector === sector ? "default" : "outline"}
                      onClick={() => setConfig(prev => ({ ...prev, sector }))}
                      className="justify-start"
                    >
                      {sector}
                    </Button>
                  ))}
                </div>
              </div>
            )}
          </TabsContent>
          <TabsContent value="custom">
            <div className="space-y-4">
              <div className="flex gap-2">
                <Input
                  placeholder="Enter ticker symbol (e.g., AAPL)"
                  value={newTicker}
                  onChange={(e) => setNewTicker(e.target.value.toUpperCase())}
                  onKeyDown={(e) => e.key === "Enter" && addCustomTicker()}
                />
                <Button onClick={addCustomTicker}>Add</Button>
              </div>
              <ScrollArea className="h-[200px] border rounded-md p-4">
                <div className="flex flex-wrap gap-2">
                  {config.customTickers.map(ticker => (
                    <Badge key={ticker} variant="secondary">
                      {ticker}
                      <button
                        onClick={() => removeCustomTicker(ticker)}
                        className="ml-1 hover:text-destructive"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              </ScrollArea>
            </div>
          </TabsContent>
        </Tabs>
        <div className="mt-4 flex justify-end space-x-2">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleSave}>Save Changes</Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="components/market-status-header/top-bar.tsx">
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Clock, Globe2, Moon, Sun, Sunrise } from "lucide-react"
interface TopBarProps {
  currentTime: Date
  marketHours: string | null
  isLoadingHours: boolean
  isErrorHours: boolean
  theme: string | undefined
  toggleTheme: () => void
  mounted: boolean
}
export function TopBar({
  currentTime,
  marketHours,
  isLoadingHours,
  isErrorHours,
  theme,
  toggleTheme,
  mounted,
}: TopBarProps) {
  const getMarketStatusIcon = (status: string) => {
    switch (status) {
      case "during":
        return <Globe2 className="h-4 w-4 text-green-500" />
      case "after":
        return <Moon className="h-4 w-4 text-gray-500" />
      case "pre":
        return <Sunrise className="h-4 w-4 text-yellow-500" />
      default:
        return <Globe2 className="h-4 w-4 text-muted-foreground" />
    }
  }
  return (
    <div className="flex items-center justify-between bg-muted/50 p-2 rounded-md">
      <div className="flex items-center space-x-4">
        <Button variant="ghost" size="icon" onClick={toggleTheme} className="h-6 w-6" disabled={!mounted}>
          {mounted && (theme === "dark" ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />)}
        </Button>
        {!isLoadingHours && !isErrorHours && marketHours && (
          <Badge
            variant={marketHours === "during" ? "success" : "secondary"}
            className="text-xs px-2 py-0.5 flex items-center"
          >
            {getMarketStatusIcon(marketHours)}
            <span className="ml-1">{marketHours.toUpperCase()}</span>
          </Badge>
        )}
        <div className="flex items-center space-x-2">
          <Clock className="h-4 w-4 text-muted-foreground" />
          <span className="text-xs font-medium">
            {currentTime.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" })}
          </span>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="components/news/NewsCard.tsx">
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useNews } from '@/lib/hooks/use-news';
interface NewsCardProps {
  symbols?: string[];
  limit?: number;
  useStream?: boolean;
}
export function NewsCard({ symbols, limit = 5, useStream = true }: NewsCardProps) {
  const { news, error, isLoading, hasMore, loadMore } = useNews(symbols, {
    limit,
    useStream,
  });
  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>News</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-destructive">{error.message}</p>
        </CardContent>
      </Card>
    );
  }
  if (isLoading && !news.length) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>News</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse space-y-4">
            {Array.from({ length: limit }).map((_, i) => (
              <div key={i} className="space-y-2">
                <div className="h-4 w-3/4 bg-muted rounded" />
                <div className="h-3 w-1/2 bg-muted rounded" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          News
          {useStream && (
            <Badge variant="success" className="animate-pulse">
              Live
            </Badge>
          )}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {news.map((item) => (
          <article key={item.id} className="space-y-2">
            <h3 className="font-medium hover:text-primary cursor-pointer">
              <a href={item.url} target="_blank" rel="noopener noreferrer">
                {item.title}
              </a>
            </h3>
            <p className="text-sm text-muted-foreground line-clamp-2">
              {item.summary}
            </p>
            <div className="flex items-center justify-between text-xs text-muted-foreground">
              <span>{item.source}</span>
              <span>
                {new Date(item.publishedAt).toLocaleString()}
              </span>
            </div>
            <div className="flex flex-wrap gap-1">
              {item.symbols.map((symbol) => (
                <Badge key={symbol} variant="secondary">
                  {symbol}
                </Badge>
              ))}
            </div>
          </article>
        ))}
        {hasMore && (
          <button
            onClick={loadMore}
            className="w-full py-2 text-sm text-muted-foreground hover:text-primary"
            disabled={isLoading}
          >
            {isLoading ? 'Loading...' : 'Load More'}
          </button>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/portfolio-analytics/ai-recommendations.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { AlertTriangle, TrendingUp, TrendingDown } from "lucide-react"
import { executeRecommendation } from "@/lib/api/portfolio-analytics"
import { toast } from "@/components/ui/use-toast"
export function AIRecommendations({ data }) {
  const handleExecuteRecommendation = async (recommendation) => {
    try {
      await executeRecommendation(recommendation)
      toast({
        title: "Recommendation Executed",
        description: `Successfully executed: ${recommendation.action} ${recommendation.asset}`,
      })
    } catch (error) {
      console.error("Error executing recommendation:", error)
      toast({
        title: "Error",
        description: "Failed to execute recommendation. Please try again.",
        variant: "destructive",
      })
    }
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle>AI-Generated Recommendations</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {data.recommendations.map((recommendation, index) => (
            <Card key={index}>
              <CardContent className="flex items-center justify-between p-4">
                <div className="flex items-center space-x-4">
                  {recommendation.type === "buy" && <TrendingUp className="text-green-500" />}
                  {recommendation.type === "sell" && <TrendingDown className="text-red-500" />}
                  {recommendation.type === "rebalance" && <AlertTriangle className="text-yellow-500" />}
                  <div>
                    <h3 className="font-semibold">{recommendation.asset}</h3>
                    <p className="text-sm text-muted-foreground">{recommendation.reason}</p>
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <Badge>{recommendation.type.toUpperCase()}</Badge>
                  <Button size="sm" onClick={() => handleExecuteRecommendation(recommendation)}>
                    Execute
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-analytics/benchmark-comparison.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { ArrowUpRight, ArrowDownRight } from "lucide-react"
interface BenchmarkData {
  comparisons: Array<{
    benchmark: string
    performance: number
    correlation: number
  }>
  historicalPerformance: Array<{
    date: string
    portfolio: number
    [key: string]: number | string // For benchmark values
  }>
}
interface BenchmarkComparisonProps {
  data: BenchmarkData
}
export function BenchmarkComparison({ data }: BenchmarkComparisonProps) {
  const benchmarkColors = {
    portfolio: "#8884d8",
    "S&P 500": "#82ca9d",
    "NASDAQ": "#ffc658",
    "DJIA": "#ff7300"
  }
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Performance vs Benchmarks</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.historicalPerformance}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                {Object.entries(benchmarkColors).map(([key, color]) => (
                  <Line
                    key={key}
                    type="monotone"
                    dataKey={key.toLowerCase()}
                    stroke={color}
                    strokeWidth={key === "portfolio" ? 2 : 1}
                    dot={false}
                    name={key === "portfolio" ? "Portfolio" : key}
                  />
                ))}
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Benchmark Analysis</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Benchmark</TableHead>
                <TableHead>Relative Performance</TableHead>
                <TableHead>Correlation</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.comparisons.map((comparison) => (
                <TableRow key={comparison.benchmark}>
                  <TableCell className="font-medium">{comparison.benchmark}</TableCell>
                  <TableCell>
                    <div className="flex items-center">
                      <Badge variant={comparison.performance >= 0 ? "default" : "destructive"} className="mr-2">
                        {comparison.performance >= 0 ? (
                          <ArrowUpRight className="h-4 w-4 mr-1" />
                        ) : (
                          <ArrowDownRight className="h-4 w-4 mr-1" />
                        )}
                        {Math.abs(comparison.performance).toFixed(2)}%
                      </Badge>
                      <span className="text-sm text-muted-foreground">
                        vs {comparison.benchmark}
                      </span>
                    </div>
                  </TableCell>
                  <TableCell>
                    <Badge 
                      variant="outline" 
                      className={
                        comparison.correlation > 0.7 
                          ? "bg-yellow-500/10 text-yellow-500"
                          : comparison.correlation > 0.3
                          ? "bg-blue-500/10 text-blue-500"
                          : "bg-green-500/10 text-green-500"
                      }
                    >
                      {(comparison.correlation * 100).toFixed(1)}%
                    </Badge>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/benchmarking.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
export function Benchmarking({ data }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Performance vs Benchmarks</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={data.benchmarkComparison}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Bar dataKey="portfolio" fill="#8884d8" />
                <Bar dataKey="benchmark" fill="#82ca9d" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Hedge Fund Strategy Comparison</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Strategy</TableHead>
                <TableHead>Your Performance</TableHead>
                <TableHead>Strategy Average</TableHead>
                <TableHead>Difference</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.hedgeFundComparison.map((strategy, index) => (
                <TableRow key={index}>
                  <TableCell>{strategy.name}</TableCell>
                  <TableCell>{strategy.portfolioPerformance.toFixed(2)}%</TableCell>
                  <TableCell>{strategy.strategyAverage.toFixed(2)}%</TableCell>
                  <TableCell className={strategy.difference > 0 ? "text-green-600" : "text-red-600"}>
                    {strategy.difference > 0 ? "+" : ""}
                    {strategy.difference.toFixed(2)}%
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/esg-scorecard.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, ResponsiveContainer } from "recharts"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
export function ESGScorecard({ data }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>ESG Score Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <RadarChart cx="50%" cy="50%" outerRadius="80%" data={data.esgScores}>
                <PolarGrid />
                <PolarAngleAxis dataKey="category" />
                <PolarRadiusAxis angle={30} domain={[0, 100]} />
                <Radar name="Portfolio" dataKey="score" stroke="#8884d8" fill="#8884d8" fillOpacity={0.6} />
              </RadarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>ESG Breakdown</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Category</TableHead>
                <TableHead>Score</TableHead>
                <TableHead>Industry Average</TableHead>
                <TableHead>Percentile</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.esgBreakdown.map((item, index) => (
                <TableRow key={index}>
                  <TableCell>{item.category}</TableCell>
                  <TableCell>{item.score}</TableCell>
                  <TableCell>{item.industryAverage}</TableCell>
                  <TableCell>{item.percentile}%</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Top ESG Contributors</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Company</TableHead>
                <TableHead>ESG Score</TableHead>
                <TableHead>Contribution to Portfolio Score</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.topContributors.map((company, index) => (
                <TableRow key={index}>
                  <TableCell>{company.name}</TableCell>
                  <TableCell>{company.esgScore}</TableCell>
                  <TableCell>{company.contribution}%</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/performance-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Badge } from "@/components/ui/badge"
import { ArrowUpRight, ArrowDownRight } from "lucide-react"
interface PerformanceData {
  returns: Array<{ date: string; value: number }>
  volatility: number
  sharpeRatio: number
  maxDrawdown: number
}
interface PerformanceAnalysisProps {
  data: PerformanceData
}
export function PerformanceAnalysis({ data }: PerformanceAnalysisProps) {
  const renderMetricCard = (title: string, value: number, isPercentage: boolean = true) => (
    <Card>
      <CardContent className="p-6">
        <div className="flex items-center justify-between">
          <p className="text-sm font-medium text-muted-foreground">{title}</p>
          <Badge variant={value >= 0 ? "default" : "destructive"} className="ml-2">
            {value >= 0 ? <ArrowUpRight className="h-4 w-4 mr-1" /> : <ArrowDownRight className="h-4 w-4 mr-1" />}
            {Math.abs(value).toFixed(2)}{isPercentage ? "%" : ""}
          </Badge>
        </div>
      </CardContent>
    </Card>
  )
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Portfolio Performance</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.returns}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line
                  type="monotone"
                  dataKey="value"
                  stroke="#8884d8"
                  strokeWidth={2}
                  dot={false}
                  name="Portfolio Value"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <div className="grid gap-4 md:grid-cols-3">
        {renderMetricCard("Volatility", data.volatility)}
        {renderMetricCard("Sharpe Ratio", data.sharpeRatio, false)}
        {renderMetricCard("Maximum Drawdown", data.maxDrawdown)}
      </div>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/performance-monitor.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
export function PerformanceMonitor({ data }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Performance Over Time</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.performanceHistory}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="value" stroke="#8884d8" />
                <Line type="monotone" dataKey="benchmark" stroke="#82ca9d" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Asset Class Performance</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Asset Class</TableHead>
                <TableHead>Current Value</TableHead>
                <TableHead>Daily Change</TableHead>
                <TableHead>Total Return</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.assetClassPerformance.map((asset, index) => (
                <TableRow key={index}>
                  <TableCell>{asset.name}</TableCell>
                  <TableCell>${asset.currentValue.toLocaleString()}</TableCell>
                  <TableCell className={asset.dailyChange > 0 ? "text-green-600" : "text-red-600"}>
                    {asset.dailyChange > 0 ? "+" : ""}
                    {asset.dailyChange.toFixed(2)}%
                  </TableCell>
                  <TableCell className={asset.totalReturn > 0 ? "text-green-600" : "text-red-600"}>
                    {asset.totalReturn > 0 ? "+" : ""}
                    {asset.totalReturn.toFixed(2)}%
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/portfolio-analytics-dashboard.tsx">
"use client"
import { useState, useEffect } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { PortfolioOverview } from "./portfolio-overview"
import { PerformanceAnalysis } from "./performance-analysis"
import { BenchmarkComparison } from "./benchmark-comparison"
import { AIRecommendations } from "./ai-recommendations"
import { TaxOptimization } from "./tax-optimization"
import { RiskAnalysis } from "./risk-analysis"
import { ESGScorecard } from "./esg-scorecard"
import { getPortfolioAnalytics } from "@/lib/api/portfolio-analytics"
import { toast } from "@/components/ui/use-toast"
import { Loader2 } from "lucide-react"
interface PortfolioData {
  overview: {
    totalValue: number
    returns: number
    riskScore: number
    diversificationScore: number
  }
  performance: {
    returns: Array<{ date: string; value: number }>
    volatility: number
    sharpeRatio: number
    maxDrawdown: number
  }
  benchmarking: {
    comparisons: Array<{
      benchmark: string
      performance: number
      correlation: number
    }>
  }
  recommendations: Array<{
    type: string
    description: string
    impact: string
    confidence: number
  }>
  taxOptimization: {
    harvestingOpportunities: Array<{
      security: string
      potentialSavings: number
      daysUntilQualified: number
    }>
    taxEfficiency: number
  }
  riskAnalysis: {
    factorExposures: Record<string, number>
    stressTests: Array<{
      scenario: string
      impact: number
    }>
  }
  esgScorecard: {
    overall: number
    environmental: number
    social: number
    governance: number
    controversies: string[]
  }
}
export function PortfolioAnalyticsDashboard() {
  const [portfolioData, setPortfolioData] = useState<PortfolioData | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  useEffect(() => {
    const fetchPortfolioAnalytics = async () => {
      try {
        const data = await getPortfolioAnalytics()
        setPortfolioData(data as PortfolioData)
      } catch (error) {
        console.error("Error fetching portfolio analytics:", error)
        toast({
          title: "Error",
          description: "Failed to fetch portfolio analytics. Please try again.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }
    fetchPortfolioAnalytics()
  }, [])
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-4rem)]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }
  if (!portfolioData) {
    return <div>No portfolio data available.</div>
  }
  return (
    <div className="container mx-auto p-4 space-y-6">
      <h1 className="text-2xl font-bold mb-4">Portfolio Analytics</h1>
      <PortfolioOverview data={portfolioData.overview} />
      <Tabs defaultValue="performance">
        <TabsList>
          <TabsTrigger value="performance">Performance</TabsTrigger>
          <TabsTrigger value="benchmarking">Benchmarking</TabsTrigger>
          <TabsTrigger value="recommendations">AI Recommendations</TabsTrigger>
          <TabsTrigger value="tax-optimization">Tax Optimization</TabsTrigger>
          <TabsTrigger value="risk-analysis">Risk Analysis</TabsTrigger>
          <TabsTrigger value="esg-scorecard">ESG Scorecard</TabsTrigger>
        </TabsList>
        <TabsContent value="performance">
          <PerformanceAnalysis data={portfolioData.performance} />
        </TabsContent>
        <TabsContent value="benchmarking">
          <BenchmarkComparison data={portfolioData.benchmarking} />
        </TabsContent>
        <TabsContent value="recommendations">
          <AIRecommendations data={portfolioData.recommendations} />
        </TabsContent>
        <TabsContent value="tax-optimization">
          <TaxOptimization data={portfolioData.taxOptimization} />
        </TabsContent>
        <TabsContent value="risk-analysis">
          <RiskAnalysis data={portfolioData.riskAnalysis} />
        </TabsContent>
        <TabsContent value="esg-scorecard">
          <ESGScorecard data={portfolioData.esgScorecard} />
        </TabsContent>
      </Tabs>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/portfolio-overview.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from "recharts"
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8", "#82ca9d"]
export function PortfolioOverview({ data }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Portfolio Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="text-lg font-semibold mb-2">Asset Allocation</h3>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={data.assetAllocation}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  >
                    {data.assetAllocation.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Key Metrics</h3>
            <ul className="space-y-2">
              <li>Total Value: ${data.totalValue.toLocaleString()}</li>
              <li>
                Daily Change: {data.dailyChange > 0 ? "+" : ""}
                {data.dailyChange.toFixed(2)}%
              </li>
              <li>
                Total Return: {data.totalReturn > 0 ? "+" : ""}
                {data.totalReturn.toFixed(2)}%
              </li>
              <li>Risk Level: {data.riskLevel}</li>
            </ul>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-analytics/risk-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
export function RiskAnalysis({ data }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Portfolio Risk Metrics</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Metric</TableHead>
                <TableHead>Value</TableHead>
                <TableHead>Interpretation</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.riskMetrics.map((metric, index) => (
                <TableRow key={index}>
                  <TableCell>{metric.name}</TableCell>
                  <TableCell>{metric.value}</TableCell>
                  <TableCell>{metric.interpretation}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Value at Risk (VaR) Analysis</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={data.valueAtRisk}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="confidence" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Bar dataKey="value" fill="#8884d8" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Stress Test Scenarios</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Scenario</TableHead>
                <TableHead>Impact</TableHead>
                <TableHead>Recommended Action</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.stressTests.map((test, index) => (
                <TableRow key={index}>
                  <TableCell>{test.scenario}</TableCell>
                  <TableCell className={test.impact < 0 ? "text-red-500" : "text-green-500"}>
                    {test.impact > 0 ? "+" : ""}
                    {test.impact}%
                  </TableCell>
                  <TableCell>{test.recommendedAction}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-analytics/tax-optimization.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Progress } from "@/components/ui/progress"
export function TaxOptimization({ data }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Tax Optimization Opportunities</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Strategy</TableHead>
                <TableHead>Potential Savings</TableHead>
                <TableHead>Impact</TableHead>
                <TableHead>Action</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.opportunities.map((opportunity, index) => (
                <TableRow key={index}>
                  <TableCell>{opportunity.strategy}</TableCell>
                  <TableCell>${opportunity.potentialSavings.toLocaleString()}</TableCell>
                  <TableCell>
                    <Progress value={opportunity.impact} className="w-[60px]" />
                  </TableCell>
                  <TableCell>{opportunity.action}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Tax-Loss Harvesting</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Asset</TableHead>
                <TableHead>Current Loss</TableHead>
                <TableHead>Potential Tax Benefit</TableHead>
                <TableHead>Recommended Action</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.taxLossHarvesting.map((item, index) => (
                <TableRow key={index}>
                  <TableCell>{item.asset}</TableCell>
                  <TableCell>${item.currentLoss.toLocaleString()}</TableCell>
                  <TableCell>${item.potentialTaxBenefit.toLocaleString()}</TableCell>
                  <TableCell>{item.recommendedAction}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Annual Tax Savings Projection</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-3xl font-bold">${data.annualTaxSavings.toLocaleString()}</div>
          <p className="text-sm text-muted-foreground mt-2">
            Estimated annual tax savings based on current portfolio and optimization strategies.
          </p>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-optimizer/correlation-matrix.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import type { CorrelationData } from "@/types/portfolio-optimizer"
interface CorrelationMatrixProps {
  data: CorrelationData
}
export function CorrelationMatrix({ data }: CorrelationMatrixProps) {
  const assets = Object.keys(data)
  const getCorrelationValue = (asset: string, correlatedAsset: string): number => {
    return data[asset]?.[correlatedAsset] || 0
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Correlation Matrix</CardTitle>
      </CardHeader>
      <CardContent className="overflow-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Asset</TableHead>
              {assets.map((asset) => (
                <TableHead key={asset}>{asset}</TableHead>
              ))}
            </TableRow>
          </TableHeader>
          <TableBody>
            {assets.map((asset) => (
              <TableRow key={asset}>
                <TableCell className="font-medium">{asset}</TableCell>
                {assets.map((correlatedAsset) => {
                  const value = getCorrelationValue(asset, correlatedAsset)
                  return (
                    <TableCell 
                      key={correlatedAsset}
                      className={value === 1 ? "font-medium" : value > 0.5 ? "text-yellow-500" : value < -0.5 ? "text-red-500" : ""}
                    >
                      {value.toFixed(2)}
                    </TableCell>
                  )
                })}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-optimizer/performance-metrics.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import type { PortfolioData } from "@/types/portfolio-optimizer"
interface PerformanceMetricsProps {
  data: PortfolioData["performance"]
}
export function PerformanceMetrics({ data }: PerformanceMetricsProps) {
  const { returns, riskAdjustedReturns, drawdowns } = data
  return (
    <div className="space-y-6 h-full overflow-y-auto">
      <Card>
        <CardHeader>
          <CardTitle>Portfolio Returns</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={returns}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="value" stroke="#8884d8" strokeWidth={2} dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Risk-Adjusted Returns</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={riskAdjustedReturns}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="value" stroke="#82ca9d" strokeWidth={2} dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Drawdowns</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={drawdowns}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="value" stroke="#ff7300" strokeWidth={2} dot={false} />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/portfolio-optimizer/portfolio-allocation.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from "recharts"
import { useEffect, useState, useCallback } from "react"
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8", "#FF6B6B", "#6B8E23", "#483D8B"]
interface AllocationData {
  name: string
  value: number
}
interface PortfolioAllocationProps {
  data: AllocationData[]
}
export function PortfolioAllocation({ data }: PortfolioAllocationProps) {
  const [chartDimensions, setChartDimensions] = useState({ width: 0, height: 0 })
  const updateDimensions = useCallback(() => {
    const container = document.getElementById('portfolio-allocation-container')
    if (container) {
      const { width, height } = container.getBoundingClientRect()
      setChartDimensions({
        width: width,
        height: Math.min(height, width * 0.75) // Keep aspect ratio reasonable
      })
    }
  }, [])
  useEffect(() => {
    updateDimensions()
    window.addEventListener('resize', updateDimensions)
    return () => window.removeEventListener('resize', updateDimensions)
  }, [updateDimensions])
  const calculateRadius = () => {
    const minDimension = Math.min(chartDimensions.width, chartDimensions.height)
    return Math.min(minDimension * 0.4, 150) // Cap at 150px
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Portfolio Allocation</CardTitle>
      </CardHeader>
      <CardContent>
        <div id="portfolio-allocation-container" className="w-full h-[calc(100vh-20rem)] min-h-[400px]">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={data}
                cx="50%"
                cy="50%"
                labelLine={false}
                outerRadius={calculateRadius()}
                fill="#8884d8"
                dataKey="value"
                label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              >
                {data.map((entry: AllocationData, index: number) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-optimizer/portfolio-optimizer-dashboard.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Slider } from "@/components/ui/slider"
import { PortfolioAllocation } from "./portfolio-allocation"
import { CorrelationMatrix } from "./correlation-matrix"
import { PerformanceMetrics } from "./performance-metrics"
import { TradeSuggestions } from "./trade-suggestions"
import { optimizePortfolio, getPortfolioData } from "@/lib/api/portfolio-optimizer"
import { toast } from "@/components/ui/use-toast"
import { Loader2 } from "lucide-react"
import type { PortfolioData, OptimizationSettings } from "@/types/portfolio-optimizer"
export function PortfolioOptimizerDashboard() {
  const [portfolioData, setPortfolioData] = useState<PortfolioData | null>(null)
  const [riskTolerance, setRiskTolerance] = useState(5)
  const [rebalanceFrequency, setRebalanceFrequency] = useState<OptimizationSettings["rebalanceFrequency"]>("daily")
  const [isOptimizing, setIsOptimizing] = useState(false)
  useEffect(() => {
    const fetchPortfolioData = async () => {
      try {
        const data = await getPortfolioData()
        setPortfolioData(data)
      } catch (error) {
        console.error("Error fetching portfolio data:", error)
        toast({
          title: "Error",
          description: "Failed to fetch portfolio data. Please try again.",
          variant: "destructive",
        })
      }
    }
    fetchPortfolioData()
  }, [])
  const handleOptimize = async () => {
    setIsOptimizing(true)
    try {
      const optimizedData = await optimizePortfolio(riskTolerance, rebalanceFrequency)
      setPortfolioData(optimizedData)
      toast({
        title: "Portfolio Optimized",
        description: "Your portfolio has been successfully optimized.",
      })
    } catch (error) {
      console.error("Error optimizing portfolio:", error)
      toast({
        title: "Optimization Error",
        description: "Failed to optimize portfolio. Please try again.",
        variant: "destructive",
      })
    } finally {
      setIsOptimizing(false)
    }
  }
  if (!portfolioData) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-4rem)]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }
  return (
    <div className="container mx-auto p-4 space-y-6 h-[calc(100vh-4rem)] overflow-y-auto">
      <h1 className="text-2xl font-bold mb-4">AI-Driven Portfolio Allocation Optimizer</h1>
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Optimization Settings</CardTitle>
        </CardHeader>
        <CardContent className="flex flex-col md:flex-row md:items-center space-y-4 md:space-y-0 md:space-x-4">
          <div className="flex-1">
            <label className="text-sm font-medium">Risk Tolerance</label>
            <Slider
              value={[riskTolerance]}
              onValueChange={(value) => setRiskTolerance(value[0])}
              min={1}
              max={10}
              step={1}
            />
            <div className="flex justify-between text-sm text-muted-foreground">
              <span>Conservative</span>
              <span>Aggressive</span>
            </div>
          </div>
          <div className="w-full md:w-48">
            <label className="text-sm font-medium">Rebalance Frequency</label>
            <Select value={rebalanceFrequency} onValueChange={setRebalanceFrequency}>
              <SelectTrigger>
                <SelectValue placeholder="Select frequency" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="daily">Daily</SelectItem>
                <SelectItem value="weekly">Weekly</SelectItem>
                <SelectItem value="monthly">Monthly</SelectItem>
                <SelectItem value="quarterly">Quarterly</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <Button onClick={handleOptimize} disabled={isOptimizing} className="w-full md:w-auto">
            {isOptimizing ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null}
            Optimize Portfolio
          </Button>
        </CardContent>
      </Card>
      <div className="h-[calc(100vh-20rem)] min-h-[500px]">
        <Tabs defaultValue="allocation" className="h-full">
          <TabsList className="mb-4">
            <TabsTrigger value="allocation">Allocation</TabsTrigger>
            <TabsTrigger value="correlation">Correlation</TabsTrigger>
            <TabsTrigger value="performance">Performance</TabsTrigger>
            <TabsTrigger value="trades">Trade Suggestions</TabsTrigger>
          </TabsList>
          <div className="h-[calc(100%-3rem)]">
            <TabsContent value="allocation" className="h-full mt-0">
              <PortfolioAllocation data={portfolioData.allocation} />
            </TabsContent>
            <TabsContent value="correlation" className="h-full mt-0">
              <CorrelationMatrix data={portfolioData.correlation} />
            </TabsContent>
            <TabsContent value="performance" className="h-full mt-0">
              <PerformanceMetrics data={portfolioData.performance} />
            </TabsContent>
            <TabsContent value="trades" className="h-full mt-0">
              <TradeSuggestions data={portfolioData.tradeSuggestions} />
            </TabsContent>
          </div>
        </Tabs>
      </div>
    </div>
  )
}
</file>

<file path="components/portfolio-optimizer/trade-suggestions.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { executeTradeOrder } from "@/lib/api/portfolio-optimizer"
import { toast } from "@/components/ui/use-toast"
import type { TradeOrder } from "@/types/portfolio-optimizer"
interface TradeSuggestionsProps {
  data: TradeOrder[]
}
export function TradeSuggestions({ data }: TradeSuggestionsProps) {
  const handleExecuteTrade = async (trade: TradeOrder) => {
    try {
      await executeTradeOrder(trade)
      toast({
        title: "Trade Executed",
        description: `Successfully executed ${trade.action} order for ${trade.asset}`,
      })
    } catch (error) {
      console.error("Error executing trade:", error)
      toast({
        title: "Trade Execution Failed",
        description: "Failed to execute trade. Please try again.",
        variant: "destructive",
      })
    }
  }
  const getBadgeVariant = (action: TradeOrder["action"]) => {
    switch (action) {
      case "Buy":
        return "default"
      case "Sell":
        return "destructive"
      default:
        return "secondary"
    }
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Trade Suggestions</CardTitle>
      </CardHeader>
      <CardContent className="overflow-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Asset</TableHead>
              <TableHead>Action</TableHead>
              <TableHead>Quantity</TableHead>
              <TableHead>Price</TableHead>
              <TableHead>Total Value</TableHead>
              <TableHead>Reason</TableHead>
              <TableHead>Action</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {data.map((trade, index) => (
              <TableRow key={index}>
                <TableCell className="font-medium">{trade.asset}</TableCell>
                <TableCell>
                  <Badge variant={getBadgeVariant(trade.action)}>{trade.action}</Badge>
                </TableCell>
                <TableCell>{trade.quantity}</TableCell>
                <TableCell>${trade.price.toFixed(2)}</TableCell>
                <TableCell>${(trade.quantity * trade.price).toFixed(2)}</TableCell>
                <TableCell className="max-w-[300px] truncate" title={trade.reason}>
                  {trade.reason}
                </TableCell>
                <TableCell>
                  <Button 
                    onClick={() => handleExecuteTrade(trade)}
                    variant={trade.action === "Buy" ? "default" : "destructive"}
                    size="sm"
                  >
                    Execute
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/search/SearchBar.tsx">
import React from 'react';
import { useSearch } from '@/lib/hooks/use-search';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
interface SearchBarProps {
  onSelect?: (result: any) => void;
  placeholder?: string;
  className?: string;
}
export function SearchBar({
  onSelect,
  placeholder = 'Search for stocks, crypto, or forex...',
  className = '',
}: SearchBarProps) {
  const { query, setQuery, results, isLoading } = useSearch({
    debounceMs: 300,
    limit: 5,
  });
  return (
    <div className={`relative ${className}`}>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder={placeholder}
        className="w-full px-4 py-2 rounded-md border border-input bg-background"
      />
      {(isLoading || results.length > 0) && (
        <Card className="absolute w-full mt-1 z-50">
          <CardContent className="p-2">
            {isLoading ? (
              <div className="animate-pulse space-y-2">
                {Array.from({ length: 3 }).map((_, i) => (
                  <div key={i} className="h-8 bg-muted rounded" />
                ))}
              </div>
            ) : (
              <ul className="space-y-1">
                {results.map((result) => (
                  <li
                    key={result.ticker}
                    className="p-2 hover:bg-muted rounded-md cursor-pointer"
                    onClick={() => onSelect?.(result)}
                  >
                    <div className="flex items-center justify-between">
                      <div>
                        <span className="font-medium">{result.ticker}</span>
                        <span className="ml-2 text-sm text-muted-foreground">
                          {result.name}
                        </span>
                      </div>
                      <div className="flex gap-1">
                        <Badge variant="secondary">{result.type}</Badge>
                        <Badge variant="outline">{result.market}</Badge>
                      </div>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="components/technical/TechnicalChart.tsx">
import React from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { useTechnicalIndicators } from '@/lib/hooks/use-technical-indicators';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
interface TechnicalChartProps {
  symbol: string;
  indicator: 'SMA' | 'EMA' | 'RSI' | 'MACD';
  period: number;
  timeRange: {
    startDate: string;
    endDate: string;
  };
  refreshInterval?: number;
}
export function TechnicalChart({
  symbol,
  indicator,
  period,
  timeRange,
  refreshInterval,
}: TechnicalChartProps) {
  const { data, error, isLoading } = useTechnicalIndicators(
    symbol,
    indicator,
    period,
    timeRange,
    { refreshInterval }
  );
  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>
            {symbol} - {indicator}({period})
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-destructive">{error.message}</p>
        </CardContent>
      </Card>
    );
  }
  if (isLoading || !data.length) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>
            {symbol} - {indicator}({period})
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse space-y-2">
            <div className="h-[300px] bg-muted rounded" />
          </div>
        </CardContent>
      </Card>
    );
  }
  const formattedData = data.map((item) => ({
    timestamp: new Date(item.timestamp).toLocaleDateString(),
    value: item.value,
  }));
  return (
    <Card>
      <CardHeader>
        <CardTitle>
          {symbol} - {indicator}({period})
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={formattedData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tick={{ fontSize: 12 }}
                tickFormatter={(value) => value.split(',')[0]}
              />
              <YAxis tick={{ fontSize: 12 }} />
              <Tooltip
                labelFormatter={(label) => new Date(label).toLocaleDateString()}
                formatter={(value: number) => [value.toFixed(2), indicator]}
              />
              <Legend />
              <Line
                type="monotone"
                dataKey="value"
                stroke="#8884d8"
                name={`${indicator}(${period})`}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/technical-analysis/brokerage-integration.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { executeOrder } from "@/lib/api/brokerage"
type BrokerageIntegrationProps = {}
export function BrokerageIntegration({}: BrokerageIntegrationProps) {
  const [orderType, setOrderType] = useState("market")
  const [quantity, setQuantity] = useState("")
  const [limitPrice, setLimitPrice] = useState("")
  const [symbol, setSymbol] = useState("")
  const handleExecuteOrder = async () => {
    try {
      const success = await executeOrder({
        type: orderType as "market" | "limit",
        quantity: Number.parseInt(quantity),
        limitPrice: orderType === "limit" ? Number.parseFloat(limitPrice) : undefined,
        symbol: symbol,
      })
      if (success) {
        // Order executed successfully, you can add additional logic here if needed
      }
    } catch (error) {
      console.error("Error executing order:", error)
    }
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle>Execute Trade</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <Input
            type="text"
            placeholder="Symbol (e.g., AAPL)"
            value={symbol}
            onChange={(e) => setSymbol(e.target.value)}
          />
          <Select value={orderType} onValueChange={setOrderType}>
            <SelectTrigger>
              <SelectValue placeholder="Order Type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="market">Market Order</SelectItem>
              <SelectItem value="limit">Limit Order</SelectItem>
            </SelectContent>
          </Select>
          <Input type="number" placeholder="Quantity" value={quantity} onChange={(e) => setQuantity(e.target.value)} />
          {orderType === "limit" && (
            <Input
              type="number"
              placeholder="Limit Price"
              value={limitPrice}
              onChange={(e) => setLimitPrice(e.target.value)}
            />
          )}
          <Button onClick={handleExecuteOrder}>Execute Order</Button>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/technical-analysis/chart-patterns.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
interface ChartPatternsProps {
  patterns: {
    name: string
    description: string
    confidence: number
  }[]
  selectedPatterns: string[]
  setSelectedPatterns: (patterns: string[]) => void
}
export function ChartPatterns({ patterns, selectedPatterns, setSelectedPatterns }: ChartPatternsProps) {
  const handlePatternToggle = (patternName: string) => {
    if (selectedPatterns.includes(patternName)) {
      setSelectedPatterns(selectedPatterns.filter((p) => p !== patternName))
    } else {
      setSelectedPatterns([...selectedPatterns, patternName])
    }
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle>AI-Detected Chart Patterns</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {patterns.map((pattern, index) => (
            <div key={index} className="flex items-center space-x-2">
              <Checkbox
                id={`pattern-${index}`}
                checked={selectedPatterns.includes(pattern.name)}
                onCheckedChange={() => handlePatternToggle(pattern.name)}
              />
              <label
                htmlFor={`pattern-${index}`}
                className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
              >
                {pattern.name} (Confidence: {pattern.confidence}%)
              </label>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/technical-analysis/fibonacci-retracement.tsx">
import { ReferenceLine } from "recharts"
interface FibonacciRetracementProps {
  data: {
    level: number
    value: number
  }[]
}
export function FibonacciRetracement({ data }: FibonacciRetracementProps) {
  return (
    <>
      {data.map((level, index) => (
        <ReferenceLine
          key={index}
          y={level.value}
          stroke="#8884d8"
          strokeDasharray="3 3"
          label={`${level.level * 100}%`}
        />
      ))}
    </>
  )
}
</file>

<file path="components/technical-analysis/market-sentiment-overlay.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
interface MarketSentimentOverlayProps {
  data: {
    bullishPercentage: number
    bearishPercentage: number
    neutralPercentage: number
  }
}
export function MarketSentimentOverlay({ data }: MarketSentimentOverlayProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Market Sentiment</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div>
            <div className="flex justify-between mb-1">
              <span className="text-sm font-medium">Bullish</span>
              <span className="text-sm font-medium">{data.bullishPercentage}%</span>
            </div>
            <Progress value={data.bullishPercentage} className="bg-red-200">
              <div className="bg-green-500 h-full" style={{ width: `${data.bullishPercentage}%` }} />
            </Progress>
          </div>
          <div>
            <div className="flex justify-between mb-1">
              <span className="text-sm font-medium">Bearish</span>
              <span className="text-sm font-medium">{data.bearishPercentage}%</span>
            </div>
            <Progress value={data.bearishPercentage} className="bg-green-200">
              <div className="bg-red-500 h-full" style={{ width: `${data.bearishPercentage}%` }} />
            </Progress>
          </div>
          <div>
            <div className="flex justify-between mb-1">
              <span className="text-sm font-medium">Neutral</span>
              <span className="text-sm font-medium">{data.neutralPercentage}%</span>
            </div>
            <Progress value={data.neutralPercentage} className="bg-gray-200">
              <div className="bg-gray-500 h-full" style={{ width: `${data.neutralPercentage}%` }} />
            </Progress>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/technical-analysis/trade-signal-generator.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { TrendingUp, TrendingDown } from "lucide-react"
interface TradeSignal {
  type: "buy" | "sell"
  symbol: string
  price: number
  confidence: number
  timestamp: string
}
interface TradeSignalGeneratorProps {
  signals: TradeSignal[]
}
export function TradeSignalGenerator({ signals }: TradeSignalGeneratorProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>AI-Generated Trade Signals</CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[300px]">
          {signals.map((signal, index) => (
            <div key={index} className="flex items-center justify-between py-2 border-b last:border-b-0">
              <div className="flex items-center space-x-2">
                {signal.type === "buy" ? (
                  <TrendingUp className="text-green-500" />
                ) : (
                  <TrendingDown className="text-red-500" />
                )}
                <span className="font-medium">{signal.symbol}</span>
              </div>
              <div className="text-right">
                <div>${signal.price.toFixed(2)}</div>
                <Badge variant={signal.confidence > 75 ? "success" : "secondary"}>
                  {signal.confidence}% confidence
                </Badge>
              </div>
            </div>
          ))}
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/technical-analysis/trendline-overlay.tsx">
import { Line } from "recharts"
interface TrendlineOverlayProps {
  data: {
    startDate: string
    endDate: string
    startValue: number
    endValue: number
  }[]
}
export function TrendlineOverlay({ data }: TrendlineOverlayProps) {
  return (
    <>
      {data.map((trendline, index) => (
        <Line
          key={index}
          type="linear"
          dataKey="value"
          stroke="#ff7300"
          strokeWidth={2}
          dot={false}
          activeDot={false}
          isAnimationActive={false}
          data={[
            { date: trendline.startDate, value: trendline.startValue },
            { date: trendline.endDate, value: trendline.endValue },
          ]}
        />
      ))}
    </>
  )
}
</file>

<file path="components/trading-journal/behavior-analysis.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
export function BehaviorAnalysis({ behaviorData }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Behavior Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {Object.entries(behaviorData).map(([behavior, { score, description }]) => (
            <div key={behavior}>
              <div className="flex justify-between mb-1">
                <span className="text-sm font-medium">{behavior}</span>
                <span className="text-sm font-medium">{score}%</span>
              </div>
              <Progress value={score} className="h-2" />
              <p className="text-sm text-muted-foreground mt-1">{description}</p>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trading-journal/performance-review.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
export function PerformanceReview({ performanceData }) {
  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Performance Metrics</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {Object.entries(performanceData.metrics).map(([metric, value]) => (
              <div key={metric} className="bg-muted p-4 rounded-lg">
                <h3 className="text-sm font-medium text-muted-foreground">{metric}</h3>
                <p className="text-2xl font-bold">{typeof value === "number" ? value.toFixed(2) : value}</p>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Equity Curve</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={performanceData.equityCurve}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="equity" stroke="#8884d8" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Improvement Strategies</CardTitle>
        </CardHeader>
        <CardContent>
          <ul className="list-disc pl-5 space-y-2">
            {performanceData.improvementStrategies.map((strategy, index) => (
              <li key={index}>{strategy}</li>
            ))}
          </ul>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/trading-journal/realtime-feedback.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Badge } from "@/components/ui/badge"
import { AlertTriangle, CheckCircle, Info } from "lucide-react"
export function RealtimeFeedback({ feedbackData }) {
  const getAlertIcon = (type) => {
    switch (type) {
      case "warning":
        return <AlertTriangle className="h-4 w-4" />
      case "success":
        return <CheckCircle className="h-4 w-4" />
      default:
        return <Info className="h-4 w-4" />
    }
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle>Real-time Feedback</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {feedbackData.map((feedback, index) => (
            <Alert key={index} variant={feedback.type}>
              {getAlertIcon(feedback.type)}
              <AlertTitle className="flex items-center">
                {feedback.title}
                <Badge variant={feedback.type} className="ml-2">
                  {feedback.category}
                </Badge>
              </AlertTitle>
              <AlertDescription>{feedback.description}</AlertDescription>
            </Alert>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trading-journal/trade-log.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
export function TradeLog({ trades }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Trade Log</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Symbol</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Entry Price</TableHead>
              <TableHead>Exit Price</TableHead>
              <TableHead>Quantity</TableHead>
              <TableHead>P/L</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {trades.map((trade, index) => (
              <TableRow key={index}>
                <TableCell>{new Date(trade.date).toLocaleString()}</TableCell>
                <TableCell>{trade.symbol}</TableCell>
                <TableCell>
                  <Badge variant={trade.type === "Buy" ? "success" : "destructive"}>{trade.type}</Badge>
                </TableCell>
                <TableCell>${trade.entryPrice.toFixed(2)}</TableCell>
                <TableCell>${trade.exitPrice.toFixed(2)}</TableCell>
                <TableCell>{trade.quantity}</TableCell>
                <TableCell>
                  <Badge variant={trade.profitLoss >= 0 ? "success" : "destructive"}>
                    ${trade.profitLoss.toFixed(2)}
                  </Badge>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trading-journal/trading-journal-dashboard.tsx">
"use client"
import { useState, useEffect } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { TradeLog } from "./trade-log"
import { BehaviorAnalysis } from "./behavior-analysis"
import { PerformanceReview } from "./performance-review"
import { RealtimeFeedback } from "./realtime-feedback"
import { getTradeData } from "@/lib/api/trading-journal"
import { toast } from "@/components/ui/use-toast"
import { Loader2 } from "lucide-react"
interface TradeData {
  trades: any[]
  behaviorAnalysis: any
  performanceReview: any
  realtimeFeedback: any
}
export function TradingJournalDashboard() {
  const [tradeData, setTradeData] = useState<TradeData | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  useEffect(() => {
    const fetchTradeData = async () => {
      try {
        const data = await getTradeData()
        setTradeData(data as TradeData)
      } catch (error) {
        console.error("Error fetching trade data:", error)
        toast({
          title: "Error",
          description: "Failed to fetch trade data. Please try again.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }
    fetchTradeData()
  }, [])
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-4rem)]">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    )
  }
  if (!tradeData) {
    return <div>No trade data available.</div>
  }
  return (
    <div className="container mx-auto p-4 space-y-6">
      <h1 className="text-2xl font-bold mb-4">AI-Enhanced Trading Journal</h1>
      <Tabs defaultValue="trade-log">
        <TabsList>
          <TabsTrigger value="trade-log">Trade Log</TabsTrigger>
          <TabsTrigger value="behavior-analysis">Behavior Analysis</TabsTrigger>
          <TabsTrigger value="performance-review">Performance Review</TabsTrigger>
          <TabsTrigger value="realtime-feedback">Real-time Feedback</TabsTrigger>
        </TabsList>
        <TabsContent value="trade-log">
          <TradeLog trades={tradeData.trades} />
        </TabsContent>
        <TabsContent value="behavior-analysis">
          <BehaviorAnalysis behaviorData={tradeData.behaviorAnalysis} />
        </TabsContent>
        <TabsContent value="performance-review">
          <PerformanceReview performanceData={tradeData.performanceReview} />
        </TabsContent>
        <TabsContent value="realtime-feedback">
          <RealtimeFeedback feedbackData={tradeData.realtimeFeedback} />
        </TabsContent>
      </Tabs>
    </div>
  )
}
</file>

<file path="components/ui/accordion.tsx">
"use client"
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
const Accordion = AccordionPrimitive.Root
const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"
const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName
const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName
export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="components/ui/alert-dialog.tsx">
"use client"
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
const AlertDialog = AlertDialogPrimitive.Root
const AlertDialogTrigger = AlertDialogPrimitive.Trigger
const AlertDialogPortal = AlertDialogPrimitive.Portal
const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName
const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName
const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"
const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"
const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName
const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName
const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName
const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName
export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"
const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"
const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"
export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/ui/aspect-ratio.tsx">
"use client"
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"
const AspectRatio = AspectRatioPrimitive.Root
export { AspectRatio }
</file>

<file path="components/ui/avatar.tsx">
"use client"
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import { cn } from "@/lib/utils"
const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName
const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName
const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName
export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/badge.tsx">
import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';
const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
        success: 'border-transparent bg-green-500 text-white hover:bg-green-600',
        warning: 'border-transparent bg-yellow-500 text-white hover:bg-yellow-600',
        info: 'border-transparent bg-blue-500 text-white hover:bg-blue-600',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);
export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}
function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}
export { Badge, badgeVariants };
</file>

<file path="components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"
import { cn } from "@/lib/utils"
const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"
const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"
const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"
const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"
const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"
const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"
const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"
export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="components/ui/button.tsx">
import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';
const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'underline-offset-4 hover:underline text-primary',
      },
      size: {
        default: 'h-10 py-2 px-4',
        sm: 'h-9 px-3',
        lg: 'h-11 px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';
export { Button, buttonVariants };
</file>

<file path="components/ui/calendar.tsx">
"use client"
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
export type CalendarProps = React.ComponentProps<typeof DayPicker>
function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"
export { Calendar }
</file>

<file path="components/ui/card.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}
    {...props}
  />
));
Card.displayName = 'Card';
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));
CardHeader.displayName = 'CardHeader';
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
CardTitle.displayName = 'CardTitle';
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
CardDescription.displayName = 'CardDescription';
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));
CardFooter.displayName = 'CardFooter';
export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
</file>

<file path="components/ui/carousel.tsx">
"use client"
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]
type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}
type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps
const CarouselContext = React.createContext<CarouselContextProps | null>(null)
function useCarousel() {
  const context = React.useContext(CarouselContext)
  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }
  return context
}
const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)
    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }
      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])
    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])
    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])
    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )
    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }
      setApi(api)
    }, [api, setApi])
    React.useEffect(() => {
      if (!api) {
        return
      }
      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)
      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])
    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"
const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()
  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"
const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()
  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"
const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()
  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"
const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()
  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"
export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="components/ui/chart.tsx">
"use client"
import * as React from "react"
import * as RechartsPrimitive from "recharts"
import { cn } from "@/lib/utils"
// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const
export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}
type ChartContextProps = {
  config: ChartConfig
}
const ChartContext = React.createContext<ChartContextProps | null>(null)
function useChart() {
  const context = React.useContext(ChartContext)
  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }
  return context
}
const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`
  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"
const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )
  if (!colorConfig.length) {
    return null
  }
  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}
const ChartTooltip = RechartsPrimitive.Tooltip
const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()
    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }
      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label
      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }
      if (!value) {
        return null
      }
      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])
    if (!active || !payload?.length) {
      return null
    }
    const nestLabel = payload.length === 1 && indicator !== "dot"
    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color
            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"
const ChartLegend = RechartsPrimitive.Legend
const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()
    if (!payload?.length) {
      return null
    }
    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"
// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }
  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined
  let configLabelKey: string = key
  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }
  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}
export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="components/ui/checkbox.tsx">
"use client"
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"
import { cn } from "@/lib/utils"
const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName
export { Checkbox }
</file>

<file path="components/ui/collapsible.tsx">
"use client"
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"
const Collapsible = CollapsiblePrimitive.Root
const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger
const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent
export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="components/ui/command.tsx">
"use client"
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"
import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"
const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName
const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}
const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))
CommandInput.displayName = CommandPrimitive.Input.displayName
const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))
CommandList.displayName = CommandPrimitive.List.displayName
const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))
CommandEmpty.displayName = CommandPrimitive.Empty.displayName
const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))
CommandGroup.displayName = CommandPrimitive.Group.displayName
const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName
const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))
CommandItem.displayName = CommandPrimitive.Item.displayName
const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"
export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="components/ui/context-menu.tsx">
"use client"
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const ContextMenu = ContextMenuPrimitive.Root
const ContextMenuTrigger = ContextMenuPrimitive.Trigger
const ContextMenuGroup = ContextMenuPrimitive.Group
const ContextMenuPortal = ContextMenuPrimitive.Portal
const ContextMenuSub = ContextMenuPrimitive.Sub
const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup
const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName
const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName
const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName
const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName
const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName
const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName
const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName
const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName
const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"
export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="components/ui/date-picker-with-range.tsx">
"use client"
import { format } from "date-fns"
import { CalendarIcon } from "lucide-react"
import type { DateRange } from "react-day-picker"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
interface DatePickerWithRangeProps {
  className?: string
  date: DateRange | undefined
  setDate: (date: DateRange | undefined) => void
}
export function DatePickerWithRange({ className, date, setDate }: DatePickerWithRangeProps) {
  return (
    <div className={cn("grid gap-2", className)}>
      <Popover>
        <PopoverTrigger asChild>
          <Button
            id="date"
            variant={"outline"}
            className={cn("w-[300px] justify-start text-left font-normal", !date && "text-muted-foreground")}
          >
            <CalendarIcon className="mr-2 h-4 w-4" />
            {date?.from ? (
              date.to ? (
                <>
                  {format(date.from, "LLL dd, y")} - {format(date.to, "LLL dd, y")}
                </>
              ) : (
                format(date.from, "LLL dd, y")
              )
            ) : (
              <span>Pick a date</span>
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="start">
          <Calendar
            initialFocus
            mode="range"
            defaultMonth={date?.from}
            selected={date}
            onSelect={setDate}
            numberOfMonths={2}
          />
        </PopoverContent>
      </Popover>
    </div>
  )
}
</file>

<file path="components/ui/date-range-picker.tsx">
"use client"
import * as React from "react"
import { format } from "date-fns"
import { Calendar as CalendarIcon } from "lucide-react"
import { DateRange } from "react-day-picker"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
interface DatePickerWithRangeProps {
  className?: string
  date?: DateRange
  onSelect?: (date: DateRange | undefined) => void
}
export function DatePickerWithRange({
  className,
  date,
  onSelect,
}: DatePickerWithRangeProps) {
  return (
    <div className={cn("grid gap-2", className)}>
      <Popover>
        <PopoverTrigger asChild>
          <Button
            id="date"
            variant={"outline"}
            className={cn(
              "w-[300px] justify-start text-left font-normal",
              !date && "text-muted-foreground"
            )}
          >
            <CalendarIcon className="mr-2 h-4 w-4" />
            {date?.from ? (
              date.to ? (
                <>
                  {format(date.from, "LLL dd, y")} -{" "}
                  {format(date.to, "LLL dd, y")}
                </>
              ) : (
                format(date.from, "LLL dd, y")
              )
            ) : (
              <span>Pick a date range</span>
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="start">
          <Calendar
            initialFocus
            mode="range"
            defaultMonth={date?.from}
            selected={date}
            onSelect={onSelect}
            numberOfMonths={2}
          />
        </PopoverContent>
      </Popover>
    </div>
  )
}
</file>

<file path="components/ui/dialog.tsx">
"use client"
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
const DialogPortal = DialogPrimitive.Portal
const DialogClose = DialogPrimitive.Close
const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName
const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"
const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"
const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName
const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName
export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="components/ui/drawer.tsx">
"use client"
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"
import { cn } from "@/lib/utils"
const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"
const DrawerTrigger = DrawerPrimitive.Trigger
const DrawerPortal = DrawerPrimitive.Portal
const DrawerClose = DrawerPrimitive.Close
const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName
const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"
const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"
const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"
const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName
const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName
export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client"
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup
const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName
const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName
const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName
const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName
const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName
const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName
const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName
const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName
const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"
export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="components/ui/form.tsx">
"use client"
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"
import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"
const Form = FormProvider
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}
const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}
const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()
  const fieldState = getFieldState(fieldContext.name, formState)
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }
  const { id } = itemContext
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}
type FormItemContextValue = {
  id: string
}
const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)
const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()
  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"
const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()
  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"
const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()
  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"
const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()
  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"
const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children
  if (!body) {
    return null
  }
  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"
export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="components/ui/hover-card.tsx">
"use client"
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"
import { cn } from "@/lib/utils"
const HoverCard = HoverCardPrimitive.Root
const HoverCardTrigger = HoverCardPrimitive.Trigger
const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName
export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="components/ui/input-otp.tsx">
"use client"
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"
import { cn } from "@/lib/utils"
const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"
const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"
const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]
  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"
const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"
export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"
export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)
const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName
export { Label }
</file>

<file path="components/ui/logo.tsx">
import { BarChart3 } from "lucide-react"
import { cn } from "@/lib/utils"
export function Logo({ className, size = "default" }: { className?: string; size?: "default" | "small" }) {
  return (
    <div className="flex items-center gap-2">
      <div
        className={cn(
          "flex items-center justify-center rounded-lg bg-[#4768FD]",
          size === "default" ? "w-7 h-7" : "w-6 h-6",
        )}
      >
        <BarChart3 className={cn("text-white", size === "default" ? "h-4 w-4" : "h-3.5 w-3.5")} />
      </div>
    </div>
  )
}
</file>

<file path="components/ui/menubar.tsx">
"use client"
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const MenubarMenu = MenubarPrimitive.Menu
const MenubarGroup = MenubarPrimitive.Group
const MenubarPortal = MenubarPrimitive.Portal
const MenubarSub = MenubarPrimitive.Sub
const MenubarRadioGroup = MenubarPrimitive.RadioGroup
const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName
const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName
const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName
const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName
const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName
const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName
const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName
const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName
const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName
const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName
const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"
export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName
const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName
const NavigationMenuItem = NavigationMenuPrimitive.Item
const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)
const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName
const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName
const NavigationMenuLink = NavigationMenuPrimitive.Link
const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName
const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName
export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"
import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"
const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"
const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"
const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"
type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">
const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"
const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"
const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"
const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"
export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="components/ui/popover.tsx">
"use client"
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"
const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName
export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="components/ui/progress.tsx">
"use client"
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cn } from "@/lib/utils"
const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName
export { Progress }
</file>

<file path="components/ui/radio-group.tsx">
"use client"
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName
const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName
export { RadioGroup, RadioGroupItem }
</file>

<file path="components/ui/resizable.tsx">
"use client"
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"
import { cn } from "@/lib/utils"
const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)
const ResizablePanel = ResizablePrimitive.Panel
const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)
export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="components/ui/scroll-area.tsx">
"use client"
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
import { cn } from "@/lib/utils"
const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName
const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName
export { ScrollArea, ScrollBar }
</file>

<file path="components/ui/select.tsx">
"use client"
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "@/lib/utils"
const Select = SelectPrimitive.Root
const SelectGroup = SelectPrimitive.Group
const SelectValue = SelectPrimitive.Value
const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName
const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName
const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName
const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName
const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName
const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName
const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName
export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="components/ui/separator.tsx">
"use client"
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"
import { cn } from "@/lib/utils"
const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName
export { Separator }
</file>

<file path="components/ui/sheet.tsx">
"use client"
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const Sheet = SheetPrimitive.Root
const SheetTrigger = SheetPrimitive.Trigger
const SheetClose = SheetPrimitive.Close
const SheetPortal = SheetPrimitive.Portal
const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName
const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)
interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}
const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName
const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"
const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"
const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName
const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName
export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="components/ui/sidebar.tsx">
"use client"
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"
import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"
type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}
const SidebarContext = React.createContext<SidebarContext | null>(null)
function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }
  return context
}
const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)
    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }
        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )
    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])
    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }
      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])
    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"
    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )
    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"
const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()
    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }
    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }
    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"
const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()
  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"
const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()
  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"
const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"
const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"
const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"
const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"
const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"
const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"
const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"
const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"
  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"
const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"
const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"
const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"
const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"
const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()
    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )
    if (!tooltip) {
      return button
    }
    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }
    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"
const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"
const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"
const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])
  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"
const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"
const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"
const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"
function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}
export { Skeleton }
</file>

<file path="components/ui/slider.tsx">
"use client"
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"
import { cn } from "@/lib/utils"
const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName
export { Slider }
</file>

<file path="components/ui/sonner.tsx">
"use client"
import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"
type ToasterProps = React.ComponentProps<typeof Sonner>
const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()
  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}
export { Toaster }
</file>

<file path="components/ui/switch.tsx">
"use client"
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"
const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName
export { Switch }
</file>

<file path="components/ui/table.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn('w-full caption-bottom text-sm', className)}
      {...props}
    />
  </div>
));
Table.displayName = 'Table';
const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';
const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn('[&_tr:last-child]:border-0', className)}
    {...props}
  />
));
TableBody.displayName = 'TableBody';
const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',
      className
    )}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';
const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
      className
    )}
    {...props}
  />
));
TableRow.displayName = 'TableRow';
const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
      className
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';
const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';
const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn('mt-4 text-sm text-muted-foreground', className)}
    {...props}
  />
));
TableCaption.displayName = 'TableCaption';
export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
</file>

<file path="components/ui/tabs.tsx">
"use client"
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"
const Tabs = TabsPrimitive.Root
const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName
const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName
const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName
export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"
export { Textarea }
</file>

<file path="components/ui/toast.tsx">
"use client"
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const ToastProvider = ToastPrimitives.Provider
const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName
const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName
const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName
const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName
const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName
type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>
type ToastActionElement = React.ReactElement<typeof ToastAction>
export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="components/ui/toaster.tsx">
"use client"
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
export function Toaster() {
  const { toasts } = useToast()
  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="components/ui/toggle-group.tsx">
"use client"
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})
const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))
ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName
const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)
  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})
ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName
export { ToggleGroup, ToggleGroupItem }
</file>

<file path="components/ui/toggle.tsx">
"use client"
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))
Toggle.displayName = TogglePrimitive.Root.displayName
export { Toggle, toggleVariants }
</file>

<file path="components/ui/tooltip.tsx">
"use client"
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "@/lib/utils"
const TooltipProvider = TooltipPrimitive.Provider
const Tooltip = TooltipPrimitive.Root
const TooltipTrigger = TooltipPrimitive.Trigger
const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName
export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="components/ui/use-mobile.tsx">
import * as React from "react"
const MOBILE_BREAKPOINT = 768
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])
  return !!isMobile
}
</file>

<file path="components/ui/use-toast.ts">
"use client"
// Inspired by react-hot-toast library
import * as React from "react"
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"
const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000
type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const
let count = 0
function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}
type ActionType = typeof actionTypes
type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }
interface State {
  toasts: ToasterToast[]
}
const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()
const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)
  toastTimeouts.set(toastId, timeout)
}
export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }
    case "DISMISS_TOAST": {
      const { toastId } = action
      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}
const listeners: Array<(state: State) => void> = []
let memoryState: State = { toasts: [] }
function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}
type Toast = Omit<ToasterToast, "id">
function toast({ ...props }: Toast) {
  const id = genId()
  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })
  return {
    id: id,
    dismiss,
    update,
  }
}
function useToast() {
  const [state, setState] = React.useState<State>(memoryState)
  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])
  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}
export { useToast, toast }
</file>

<file path="components/ui/widget-skeleton.tsx">
import { Card, CardContent, CardHeader } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"
export function WidgetSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-1/3" />
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-5/6" />
          <Skeleton className="h-4 w-4/6" />
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/valuation/analyst-estimates.tsx">
"use client"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
interface PriceTarget {
  date: string
  price: number
  actual?: number
}
interface RevenueEstimate {
  year: string
  actual?: number
  estimate: number
  miss?: number
}
interface AnalystEstimatesProps {
  companyName: string
  companyLogo?: string
  priceTargets: PriceTarget[]
  revenueEstimates: RevenueEstimate[]
}
export function AnalystEstimates({ companyName, companyLogo, priceTargets, revenueEstimates }: AnalystEstimatesProps) {
  return (
    <div className="grid gap-4 md:grid-cols-2">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <CardTitle className="text-xl font-bold">Price Targets</CardTitle>
          {companyLogo && (
            <img src={companyLogo || "/placeholder.svg"} alt={`${companyName} logo`} className="h-8 w-8" />
          )}
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={priceTargets}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="actual" stroke="#8884d8" strokeWidth={2} dot={false} />
                <Line type="monotone" dataKey="price" stroke="#82ca9d" strokeDasharray="3 3" />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0">
          <CardTitle className="text-xl font-bold">Revenue Forecast</CardTitle>
          {companyLogo && (
            <img src={companyLogo || "/placeholder.svg"} alt={`${companyName} logo`} className="h-8 w-8" />
          )}
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={revenueEstimates}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="year" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="actual" fill="#8884d8" name="Actual" />
                <Bar dataKey="estimate" fill="#82ca9d" name="Estimate" />
              </BarChart>
            </ResponsiveContainer>
          </div>
          <div className="mt-4 flex flex-wrap gap-2">
            {revenueEstimates
              .filter((estimate) => estimate.miss !== undefined)
              .map((estimate) => (
                <Badge key={estimate.year} variant="secondary" className="bg-red-500/10 text-red-500">
                  {estimate.year}: Miss {estimate.miss}%
                </Badge>
              ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/valuation/company-health-metrics.tsx">
"use client"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Check } from "lucide-react"
interface HealthMetric {
  label: string
  value: boolean
}
interface CompanyHealthProps {
  profitabilityScore: number
  solvencyScore: number
  profitabilityMetrics: HealthMetric[]
  solvencyMetrics: HealthMetric[]
  companyLogo?: string
}
export function CompanyHealthMetrics({
  profitabilityScore,
  solvencyScore,
  profitabilityMetrics,
  solvencyMetrics,
  companyLogo,
}: CompanyHealthProps) {
  return (
    <div className="grid gap-4 md:grid-cols-2">
      <Card className="overflow-hidden">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-xl font-bold">Profitability Score</CardTitle>
          {companyLogo && <img src={companyLogo || "/placeholder.svg"} alt="Company logo" className="h-8 w-8" />}
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <span className="text-7xl font-bold text-green-500">{profitabilityScore}</span>
            <span className="text-sm text-muted-foreground">
              PROFITABILITY
              <br />
              SCORE
            </span>
          </div>
          <div className="space-y-2">
            {profitabilityMetrics.map((metric, index) => (
              <div key={index} className="flex items-center space-x-2">
                <Check className="h-5 w-5 text-green-500" />
                <span className="text-sm text-muted-foreground">{metric.label}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
      <Card className="overflow-hidden">
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-xl font-bold">Solvency Score</CardTitle>
          {companyLogo && <img src={companyLogo || "/placeholder.svg"} alt="Company logo" className="h-8 w-8" />}
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <span className="text-7xl font-bold text-blue-500">{solvencyScore}</span>
            <span className="text-sm text-muted-foreground">
              SOLVENCY
              <br />
              SCORE
            </span>
          </div>
          <div className="space-y-2">
            {solvencyMetrics.map((metric, index) => (
              <div key={index} className="flex items-center space-x-2">
                <Check className="h-5 w-5 text-blue-500" />
                <span className="text-sm text-muted-foreground">{metric.label}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/valuation/dcf-analysis.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Slider } from "@/components/ui/slider"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { Info } from "lucide-react"
import { Tooltip as UITooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
interface DCFInputs {
  revenueGrowth: number
  ebitdaMargin: number
  taxRate: number
  discountRate: number
  perpetualGrowth: number
  yearsToProject: number
}
interface CashFlow {
  year: number
  revenue: number
  ebitda: number
  freeCashFlow: number
  presentValue: number
}
export function DCFAnalysis() {
  const [inputs, setInputs] = useState<DCFInputs>({
    revenueGrowth: 10,
    ebitdaMargin: 25,
    taxRate: 21,
    discountRate: 10,
    perpetualGrowth: 3,
    yearsToProject: 5,
  })
  const [cashFlows, setCashFlows] = useState<CashFlow[]>([])
  const [enterpriseValue, setEnterpriseValue] = useState<number>(0)
  useEffect(() => {
    calculateDCF()
  }, [
    inputs.revenueGrowth,
    inputs.ebitdaMargin,
    inputs.taxRate,
    inputs.discountRate,
    inputs.perpetualGrowth,
    inputs.yearsToProject,
  ])
  const calculateDCF = () => {
    const initialRevenue = 1000 // Example starting revenue
    const flows: CashFlow[] = []
    let totalPV = 0
    for (let year = 1; year <= inputs.yearsToProject; year++) {
      const revenue = initialRevenue * Math.pow(1 + inputs.revenueGrowth / 100, year)
      const ebitda = revenue * (inputs.ebitdaMargin / 100)
      const freeCashFlow = ebitda * (1 - inputs.taxRate / 100)
      const presentValue = freeCashFlow / Math.pow(1 + inputs.discountRate / 100, year)
      totalPV += presentValue
      flows.push({ year, revenue, ebitda, freeCashFlow, presentValue })
    }
    // Terminal value calculation
    const terminalValue =
      (flows[flows.length - 1].freeCashFlow * (1 + inputs.perpetualGrowth / 100)) /
      (inputs.discountRate / 100 - inputs.perpetualGrowth / 100)
    const presentTerminalValue = terminalValue / Math.pow(1 + inputs.discountRate / 100, inputs.yearsToProject)
    setEnterpriseValue(totalPV + presentTerminalValue)
    setCashFlows(flows)
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>DCF Analysis</CardTitle>
        <CardDescription>Discounted Cash Flow valuation model</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Revenue Growth (%)</label>
                <TooltipProvider>
                  <UITooltip>
                    <TooltipTrigger>
                      <Info className="h-4 w-4 text-muted-foreground" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Expected annual revenue growth rate</p>
                    </TooltipContent>
                  </UITooltip>
                </TooltipProvider>
              </div>
              <Slider
                value={[inputs.revenueGrowth]}
                onValueChange={(value) => setInputs({ ...inputs, revenueGrowth: value[0] })}
                min={-20}
                max={50}
                step={0.5}
              />
              <div className="text-right text-sm text-muted-foreground">{inputs.revenueGrowth}%</div>
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">EBITDA Margin (%)</label>
                <TooltipProvider>
                  <UITooltip>
                    <TooltipTrigger>
                      <Info className="h-4 w-4 text-muted-foreground" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Expected EBITDA as percentage of revenue</p>
                    </TooltipContent>
                  </UITooltip>
                </TooltipProvider>
              </div>
              <Slider
                value={[inputs.ebitdaMargin]}
                onValueChange={(value) => setInputs({ ...inputs, ebitdaMargin: value[0] })}
                min={0}
                max={50}
                step={0.5}
              />
              <div className="text-right text-sm text-muted-foreground">{inputs.ebitdaMargin}%</div>
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Discount Rate (%)</label>
                <TooltipProvider>
                  <UITooltip>
                    <TooltipTrigger>
                      <Info className="h-4 w-4 text-muted-foreground" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Required rate of return (WACC)</p>
                    </TooltipContent>
                  </UITooltip>
                </TooltipProvider>
              </div>
              <Slider
                value={[inputs.discountRate]}
                onValueChange={(value) => setInputs({ ...inputs, discountRate: value[0] })}
                min={5}
                max={20}
                step={0.5}
              />
              <div className="text-right text-sm text-muted-foreground">{inputs.discountRate}%</div>
            </div>
          </div>
          <div className="space-y-4">
            <Card>
              <CardContent className="pt-6">
                <div className="text-center">
                  <div className="text-2xl font-bold">
                    ${enterpriseValue.toLocaleString(undefined, { maximumFractionDigits: 2 })}
                  </div>
                  <div className="text-sm text-muted-foreground">Enterprise Value</div>
                </div>
              </CardContent>
            </Card>
            <div className="h-[200px]">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={cashFlows}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="year" />
                  <YAxis />
                  <Tooltip />
                  <Line type="monotone" dataKey="presentValue" stroke="#8884d8" strokeWidth={2} dot={false} />
                </LineChart>
              </ResponsiveContainer>
            </div>
          </div>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Year</TableHead>
              <TableHead className="text-right">Revenue</TableHead>
              <TableHead className="text-right">EBITDA</TableHead>
              <TableHead className="text-right">Free Cash Flow</TableHead>
              <TableHead className="text-right">Present Value</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cashFlows.map((flow) => (
              <TableRow key={flow.year}>
                <TableCell>{flow.year}</TableCell>
                <TableCell className="text-right">
                  ${flow.revenue.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                </TableCell>
                <TableCell className="text-right">
                  ${flow.ebitda.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                </TableCell>
                <TableCell className="text-right">
                  ${flow.freeCashFlow.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                </TableCell>
                <TableCell className="text-right">
                  ${flow.presentValue.toLocaleString(undefined, { maximumFractionDigits: 0 })}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/valuation/monte-carlo.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Slider } from "@/components/ui/slider"
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { Info } from "lucide-react"
import { Tooltip as UITooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
interface SimulationResult {
  value: number
  frequency: number
  percentile: number
}
export function MonteCarloSimulation() {
  const [baseValue, setBaseValue] = useState(100)
  const [volatility, setVolatility] = useState(20)
  const [simulations, setSimulations] = useState<SimulationResult[]>([])
  const [confidenceInterval, setConfidenceInterval] = useState<{
    lower: number
    upper: number
  }>({ lower: 0, upper: 0 })
  useEffect(() => {
    runSimulation()
  }, []) // Only run simulation when the component mounts or when the dependency array changes.  In this case, no dependencies are needed.
  const runSimulation = () => {
    const numSimulations = 10000
    const results: number[] = []
    for (let i = 0; i < numSimulations; i++) {
      // Box-Muller transform to generate normally distributed random numbers
      const u1 = Math.random()
      const u2 = Math.random()
      const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2)
      // Calculate simulated value using geometric Brownian motion
      const simulatedValue = baseValue * Math.exp((volatility / 100) * z)
      results.push(simulatedValue)
    }
    // Sort results for percentile calculations
    results.sort((a, b) => a - b)
    // Create histogram
    const min = Math.min(...results)
    const max = Math.max(...results)
    const bins = 50
    const binWidth = (max - min) / bins
    const histogram: SimulationResult[] = []
    for (let i = 0; i < bins; i++) {
      const binStart = min + i * binWidth
      const binEnd = binStart + binWidth
      const count = results.filter((v) => v >= binStart && v < binEnd).length
      histogram.push({
        value: (binStart + binEnd) / 2,
        frequency: count,
        percentile: ((i + 0.5) / bins) * 100,
      })
    }
    setSimulations(histogram)
    setConfidenceInterval({
      lower: results[Math.floor(numSimulations * 0.05)],
      upper: results[Math.floor(numSimulations * 0.95)],
    })
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Monte Carlo Simulation</CardTitle>
        <CardDescription>Simulate possible valuation outcomes using probability distribution</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Base Value</label>
              <Input
                type="number"
                value={baseValue}
                onChange={(e) => setBaseValue(Number(e.target.value))}
                className="w-full"
              />
              <TooltipProvider>
                <UITooltip>
                  <TooltipTrigger>
                    <Info className="h-4 w-4 text-muted-foreground" />
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>The current or expected value of the asset</p>
                  </TooltipContent>
                </UITooltip>
              </TooltipProvider>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Volatility (%): {volatility}</label>
              <Slider
                value={[volatility]}
                onValueChange={(value) => setVolatility(value[0])}
                min={5}
                max={50}
                step={1}
              />
              <TooltipProvider>
                <UITooltip>
                  <TooltipTrigger>
                    <Info className="h-4 w-4 text-muted-foreground" />
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>The expected annual volatility of the asset's returns</p>
                  </TooltipContent>
                </UITooltip>
              </TooltipProvider>
            </div>
          </div>
          <div className="space-y-4">
            {confidenceInterval.upper > 0 && (
              <>
                <div className="text-center">
                  <div className="text-sm font-medium text-muted-foreground">90% Confidence Interval</div>
                  <div className="text-lg font-bold">
                    ${confidenceInterval.lower.toFixed(2)} - ${confidenceInterval.upper.toFixed(2)}
                  </div>
                </div>
                <div className="h-[200px]">
                  <ResponsiveContainer width="100%" height="100%">
                    <AreaChart data={simulations}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis
                        dataKey="value"
                        tickFormatter={(value) => value.toFixed(0)}
                        label={{ value: "Simulated Value", position: "insideBottom", offset: -5 }}
                      />
                      <YAxis label={{ value: "Frequency", angle: -90, position: "insideLeft" }} />
                      <Tooltip
                        formatter={(value: number, name: string) =>
                          name === "frequency" ? [value, "Frequency"] : [value.toFixed(2), name]
                        }
                      />
                      <Area type="monotone" dataKey="frequency" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} />
                    </AreaChart>
                  </ResponsiveContainer>
                </div>
              </>
            )}
          </div>
        </div>
        <div className="text-sm text-muted-foreground">
          <p>
            This simulation uses Monte Carlo methods to estimate the range of possible valuation outcomes. The chart
            shows the distribution of simulated values, with the 90% confidence interval indicating the range where the
            true value is likely to fall.
          </p>
          <ul className="list-disc list-inside mt-2">
            <li>The x-axis represents the simulated asset values</li>
            <li>The y-axis shows the frequency of each simulated value</li>
            <li>The confidence interval provides a range for the likely asset value</li>
          </ul>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/valuation/relative-valuation.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { Info } from "lucide-react"
import { Tooltip as UITooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
interface CompanyMetrics {
  symbol: string
  name: string
  peRatio: number
  evEbitda: number
  priceToBook: number
  priceToSales: number
  dividendYield: number
  marketCap: number
}
const mockPeers: CompanyMetrics[] = [
  {
    symbol: "AAPL",
    name: "Apple Inc.",
    peRatio: 28.5,
    evEbitda: 21.3,
    priceToBook: 35.9,
    priceToSales: 7.8,
    dividendYield: 0.5,
    marketCap: 2900,
  },
  {
    symbol: "MSFT",
    name: "Microsoft Corporation",
    peRatio: 32.1,
    evEbitda: 24.5,
    priceToBook: 15.7,
    priceToSales: 12.4,
    dividendYield: 0.8,
    marketCap: 2800,
  },
  {
    symbol: "GOOGL",
    name: "Alphabet Inc.",
    peRatio: 25.4,
    evEbitda: 15.8,
    priceToBook: 6.2,
    priceToSales: 5.9,
    dividendYield: 0,
    marketCap: 1900,
  },
  {
    symbol: "AMZN",
    name: "Amazon.com Inc.",
    peRatio: 60.3,
    evEbitda: 22.7,
    priceToBook: 8.4,
    priceToSales: 2.7,
    dividendYield: 0,
    marketCap: 1750,
  },
  {
    symbol: "META",
    name: "Meta Platforms Inc.",
    peRatio: 34.2,
    evEbitda: 13.6,
    priceToBook: 6.8,
    priceToSales: 6.5,
    dividendYield: 0,
    marketCap: 1000,
  },
]
export function RelativeValuation() {
  const [selectedMetric, setSelectedMetric] = useState("peRatio")
  const [selectedCompany, setSelectedCompany] = useState("AAPL")
  const getMetricName = (metric: string) => {
    switch (metric) {
      case "peRatio":
        return "P/E Ratio"
      case "evEbitda":
        return "EV/EBITDA"
      case "priceToBook":
        return "Price/Book"
      case "priceToSales":
        return "Price/Sales"
      case "dividendYield":
        return "Dividend Yield"
      default:
        return metric
    }
  }
  const getMetricValue = (company: CompanyMetrics, metric: string) => {
    return company[metric as keyof CompanyMetrics]
  }
  const getComparisonData = () => {
    return mockPeers.map((company) => ({
      name: company.symbol,
      value: getMetricValue(company, selectedMetric),
    }))
  }
  const getPercentileDifference = (company: CompanyMetrics) => {
    const values = mockPeers.map((peer) => getMetricValue(peer, selectedMetric))
    const avg = values.reduce((a, b) => a + b) / values.length
    const diff = ((getMetricValue(company, selectedMetric) - avg) / avg) * 100
    return diff
  }
  const getMetricTooltip = (metric: string) => {
    switch (metric) {
      case "peRatio":
        return "Price-to-Earnings Ratio: Measures the company's current share price relative to its earnings per share."
      case "evEbitda":
        return "Enterprise Value to EBITDA: Compares the value of a company, debt included, to the company's cash earnings less non-cash expenses."
      case "priceToBook":
        return "Price-to-Book Ratio: Compares a company's market value to its book value."
      case "priceToSales":
        return "Price-to-Sales Ratio: Compares a company's stock price to its revenues."
      case "dividendYield":
        return "Dividend Yield: Shows how much a company pays out in dividends each year relative to its stock price."
      default:
        return ""
    }
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Relative Valuation</CardTitle>
            <CardDescription>Compare valuation metrics across peers</CardDescription>
          </div>
          <div className="flex space-x-2">
            <Select value={selectedCompany} onValueChange={setSelectedCompany}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Select company" />
              </SelectTrigger>
              <SelectContent>
                {mockPeers.map((company) => (
                  <SelectItem key={company.symbol} value={company.symbol}>
                    {company.symbol}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select value={selectedMetric} onValueChange={setSelectedMetric}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Select metric" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="peRatio">P/E Ratio</SelectItem>
                <SelectItem value="evEbitda">EV/EBITDA</SelectItem>
                <SelectItem value="priceToBook">Price/Book</SelectItem>
                <SelectItem value="priceToSales">Price/Sales</SelectItem>
                <SelectItem value="dividendYield">Dividend Yield</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={getComparisonData()}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip />
              <Bar dataKey="value" fill="#8884d8" />
            </BarChart>
          </ResponsiveContainer>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Company</TableHead>
              <TableHead className="text-right">Market Cap ($B)</TableHead>
              <TableHead className="text-right">
                <div className="flex items-center justify-end">
                  {getMetricName(selectedMetric)}
                  <TooltipProvider>
                    <UITooltip>
                      <TooltipTrigger>
                        <Info className="h-4 w-4 ml-1 text-muted-foreground" />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>{getMetricTooltip(selectedMetric)}</p>
                      </TooltipContent>
                    </UITooltip>
                  </TooltipProvider>
                </div>
              </TableHead>
              <TableHead className="text-right">vs. Peers</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {mockPeers.map((company) => (
              <TableRow key={company.symbol}>
                <TableCell className="font-medium">{company.name}</TableCell>
                <TableCell className="text-right">{company.marketCap.toFixed(1)}</TableCell>
                <TableCell className="text-right">{getMetricValue(company, selectedMetric).toFixed(2)}</TableCell>
                <TableCell className="text-right">
                  <Badge variant={getPercentileDifference(company) > 0 ? "destructive" : "success"}>
                    {getPercentileDifference(company) > 0 ? "+" : ""}
                    {getPercentileDifference(company).toFixed(1)}%
                  </Badge>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/valuation/sensitivity-analysis.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Slider } from "@/components/ui/slider"
import { Info } from "lucide-react"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
interface SensitivityMatrix {
  growthRates: number[]
  discountRates: number[]
  values: number[][]
}
export function SensitivityAnalysis() {
  const [baseValue, setBaseValue] = useState(100)
  const [growthRateRange, setGrowthRateRange] = useState([-2, 2])
  const [discountRateRange, setDiscountRateRange] = useState([-2, 2])
  const [matrix, setMatrix] = useState<SensitivityMatrix>({
    growthRates: [],
    discountRates: [],
    values: [],
  })
  useEffect(() => {
    calculateMatrix()
  }, [baseValue, growthRateRange, discountRateRange]) //This line was already correct
  const calculateMatrix = () => {
    const growthRates = Array.from({ length: 5 }, (_, i) => i + growthRateRange[0]).map((x) => x + 3) // Center around 3%
    const discountRates = Array.from({ length: 5 }, (_, i) => i + discountRateRange[0]).map((x) => x + 10) // Center around 10%
    const values: number[][] = []
    for (let i = 0; i < growthRates.length; i++) {
      values[i] = []
      for (let j = 0; j < discountRates.length; j++) {
        const growth = growthRates[i] / 100
        const discount = discountRates[j] / 100
        // Simple perpetuity formula with growth
        const value = (baseValue * (1 + growth)) / (discount - growth)
        values[i][j] = value
      }
    }
    setMatrix({ growthRates, discountRates, values })
  }
  const getValueColor = (value: number) => {
    const baseCase = matrix.values[2][2] // Center value
    const percentDiff = ((value - baseCase) / baseCase) * 100
    if (percentDiff > 20) return "bg-green-500/10 text-green-500"
    if (percentDiff > 10) return "bg-green-400/10 text-green-400"
    if (percentDiff < -20) return "bg-red-500/10 text-red-500"
    if (percentDiff < -10) return "bg-red-400/10 text-red-400"
    return "bg-yellow-500/10 text-yellow-500"
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Sensitivity Analysis</CardTitle>
        <CardDescription>Analyze how growth and discount rates affect valuation</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Base FCF Value</label>
              <Input
                type="number"
                value={baseValue}
                onChange={(e) => setBaseValue(Number(e.target.value))}
                className="w-full"
              />
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Growth Rate Range</label>
              <Slider
                value={growthRateRange}
                onValueChange={setGrowthRateRange}
                min={-5}
                max={5}
                step={1}
                className="w-full"
              />
              <div className="flex justify-between text-sm text-muted-foreground">
                <span>{growthRateRange[0]}%</span>
                <span>{growthRateRange[1]}%</span>
              </div>
            </div>
            <div className="space-y-2">
              <label className="text-sm font-medium">Discount Rate Range</label>
              <Slider
                value={discountRateRange}
                onValueChange={setDiscountRateRange}
                min={-5}
                max={5}
                step={1}
                className="w-full"
              />
              <div className="flex justify-between text-sm text-muted-foreground">
                <span>{discountRateRange[0]}%</span>
                <span>{discountRateRange[1]}%</span>
              </div>
            </div>
          </div>
          <div className="space-y-4">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Info className="h-5 w-5 text-muted-foreground" />
                </TooltipTrigger>
                <TooltipContent>
                  <p>
                    This matrix shows how the valuation changes with different combinations of growth and discount
                    rates. The center value represents the base case scenario.
                  </p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
        {matrix.values.length > 0 && (
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="text-center">Growth Rate ↓ Discount Rate →</TableHead>
                  {matrix.discountRates.map((rate) => (
                    <TableHead key={rate} className="text-center">
                      {rate}%
                    </TableHead>
                  ))}
                </TableRow>
              </TableHeader>
              <TableBody>
                {matrix.growthRates.map((growth, i) => (
                  <TableRow key={growth}>
                    <TableCell className="font-medium text-center">{growth}%</TableCell>
                    {matrix.values[i].map((value, j) => (
                      <TableCell key={j} className="text-center">
                        <Badge variant="outline" className={getValueColor(value)}>
                          {value.toFixed(1)}
                        </Badge>
                      </TableCell>
                    ))}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        )}
        <div className="text-sm text-muted-foreground">
          <p>
            This matrix shows how the valuation changes with different combinations of growth and discount rates. The
            center value represents the base case scenario.
          </p>
          <ul className="list-disc list-inside mt-2">
            <li>Green values indicate potential upside scenarios</li>
            <li>Red values indicate potential downside scenarios</li>
            <li>Yellow values are close to the base case</li>
          </ul>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/valuation/stock-selector.tsx">
"use client"
import { useState } from "react"
import { Search, TrendingUp } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
interface StockResult {
  symbol: string
  name: string
  price: number
  change: number
  marketCap: string
  sector: string
}
const popularStocks: StockResult[] = [
  {
    symbol: "AAPL",
    name: "Apple Inc.",
    price: 185.92,
    change: 1.25,
    marketCap: "3.02T",
    sector: "Technology",
  },
  {
    symbol: "MSFT",
    name: "Microsoft Corporation",
    price: 420.55,
    change: 2.15,
    marketCap: "2.95T",
    sector: "Technology",
  },
  {
    symbol: "GOOGL",
    name: "Alphabet Inc.",
    price: 142.65,
    change: -0.45,
    marketCap: "1.85T",
    sector: "Technology",
  },
  {
    symbol: "AMZN",
    name: "Amazon.com Inc.",
    price: 172.35,
    change: 1.75,
    marketCap: "1.78T",
    sector: "Consumer Cyclical",
  },
  {
    symbol: "META",
    name: "Meta Platforms Inc.",
    price: 485.12,
    change: 3.25,
    marketCap: "1.25T",
    sector: "Technology",
  },
]
interface StockSelectorProps {
  onSelectStock: (symbol: string) => void
}
export function StockSelector({ onSelectStock }: StockSelectorProps) {
  const [searchQuery, setSearchQuery] = useState("")
  const [searchResults, setSearchResults] = useState<StockResult[]>([])
  const handleSearch = (query: string) => {
    setSearchQuery(query)
    if (query.trim() === "") {
      setSearchResults([])
      return
    }
    const results = popularStocks.filter(
      (stock) =>
        stock.symbol.toLowerCase().includes(query.toLowerCase()) ||
        stock.name.toLowerCase().includes(query.toLowerCase()),
    )
    setSearchResults(results)
  }
  const displayStocks = searchQuery ? searchResults : popularStocks
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Search by company name or symbol..."
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            className="pl-9"
          />
        </div>
        <Button variant="outline" className="gap-2">
          <TrendingUp className="h-4 w-4" />
          Popular Stocks
        </Button>
      </div>
      <div className="rounded-lg border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Symbol</TableHead>
              <TableHead>Name</TableHead>
              <TableHead className="text-right">Price</TableHead>
              <TableHead className="text-right">Change</TableHead>
              <TableHead>Market Cap</TableHead>
              <TableHead>Sector</TableHead>
              <TableHead className="text-right"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {displayStocks.map((stock) => (
              <TableRow key={stock.symbol}>
                <TableCell className="font-medium">{stock.symbol}</TableCell>
                <TableCell>{stock.name}</TableCell>
                <TableCell className="text-right">${stock.price.toFixed(2)}</TableCell>
                <TableCell className="text-right">
                  <Badge variant={stock.change >= 0 ? "success" : "destructive"}>
                    {stock.change >= 0 ? "+" : ""}
                    {stock.change}%
                  </Badge>
                </TableCell>
                <TableCell>${stock.marketCap}</TableCell>
                <TableCell>{stock.sector}</TableCell>
                <TableCell className="text-right">
                  <Button variant="secondary" size="sm" onClick={() => onSelectStock(stock.symbol)}>
                    Analyze
                  </Button>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  )
}
</file>

<file path="components/advanced-charts.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts"
const data = [
  { name: "Jan", value: 400 },
  { name: "Feb", value: 300 },
  { name: "Mar", value: 600 },
  { name: "Apr", value: 800 },
  { name: "May", value: 500 },
  { name: "Jun", value: 700 },
]
export function AdvancedCharts() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Advanced Charts</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="line">
          <TabsList>
            <TabsTrigger value="line">Line</TabsTrigger>
            <TabsTrigger value="bar">Bar</TabsTrigger>
            <TabsTrigger value="area">Area</TabsTrigger>
          </TabsList>
          <TabsContent value="line">
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Line type="monotone" dataKey="value" stroke="#8884d8" />
              </LineChart>
            </ResponsiveContainer>
          </TabsContent>
          <TabsContent value="bar">
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Bar dataKey="value" fill="#8884d8" />
              </BarChart>
            </ResponsiveContainer>
          </TabsContent>
          <TabsContent value="area">
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Legend />
                <Area type="monotone" dataKey="value" stroke="#8884d8" fill="#8884d8" />
              </AreaChart>
            </ResponsiveContainer>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/ai-insights.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { TrendingUp, TrendingDown, AlertTriangle, Loader2 } from "lucide-react"
interface Insight {
  type: "bullish" | "bearish" | "neutral"
  content: string
}
const mockInsights: Insight[] = [
  { type: "bullish", content: "Tech sector showing strong momentum" },
  { type: "bearish", content: "Energy stocks face headwinds due to policy changes" },
  { type: "neutral", content: "Market awaits Fed's decision on interest rates" },
  { type: "bullish", content: "Positive earnings surprises in healthcare sector" },
  { type: "bearish", content: "Inflation concerns weigh on consumer discretionary stocks" },
]
export function AIInsights() {
  const [insights, setInsights] = useState<Insight[]>([])
  const [isLoading, setIsLoading] = useState(true)
  useEffect(() => {
    const loadInsights = async () => {
      try {
        setIsLoading(true)
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000))
        setInsights(mockInsights)
      } finally {
        setIsLoading(false)
      }
    }
    loadInsights()
  }, [])
  const getBadgeVariant = (type: Insight["type"]) => {
    switch (type) {
      case "bullish":
        return "default"
      case "bearish":
        return "destructive"
      case "neutral":
        return "secondary"
    }
  }
  if (isLoading) {
    return (
      <Card className="h-full">
        <CardHeader>
          <CardTitle>AI-Generated Market Insights</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[300px]">
          <Loader2 className="h-8 w-8 animate-spin" />
        </CardContent>
      </Card>
    )
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>AI-Generated Market Insights</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-4">
          {insights.map((insight, index) => (
            <li key={index} className="flex items-start space-x-2">
              {insight.type === "bullish" && <TrendingUp className="h-5 w-5 text-green-500 mt-0.5 shrink-0" />}
              {insight.type === "bearish" && <TrendingDown className="h-5 w-5 text-red-500 mt-0.5 shrink-0" />}
              {insight.type === "neutral" && <AlertTriangle className="h-5 w-5 text-yellow-500 mt-0.5 shrink-0" />}
              <div>
                <Badge variant={getBadgeVariant(insight.type)} className="mb-1">
                  {insight.type.toUpperCase()}
                </Badge>
                <p className="text-sm text-muted-foreground">{insight.content}</p>
              </div>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/bond-screener.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
const mockBonds = [
  { name: "US Treasury 10Y", yield: 1.45, rating: "AAA", maturity: "10Y", price: 98.5 },
  { name: "Corporate Bond A", yield: 3.2, rating: "A", maturity: "5Y", price: 101.2 },
  { name: "Municipal Bond B", yield: 2.1, rating: "AA", maturity: "7Y", price: 99.8 },
]
export function BondScreener() {
  const [searchTerm, setSearchTerm] = useState("")
  const [sortBy, setSortBy] = useState("name")
  const filteredBonds = mockBonds
    .filter((bond) => bond.name.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1))
  return (
    <Card>
      <CardHeader>
        <CardTitle>Bond Screener</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex space-x-2 mb-4">
          <Input
            placeholder="Search by name"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="max-w-sm"
          />
          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Sort by" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="name">Name</SelectItem>
              <SelectItem value="yield">Yield</SelectItem>
              <SelectItem value="rating">Rating</SelectItem>
              <SelectItem value="maturity">Maturity</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Name</TableHead>
              <TableHead>Yield</TableHead>
              <TableHead>Rating</TableHead>
              <TableHead>Maturity</TableHead>
              <TableHead>Price</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredBonds.map((bond, index) => (
              <TableRow key={index}>
                <TableCell>{bond.name}</TableCell>
                <TableCell>{bond.yield.toFixed(2)}%</TableCell>
                <TableCell>{bond.rating}</TableCell>
                <TableCell>{bond.maturity}</TableCell>
                <TableCell>${bond.price.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/c-suite-overview.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
const executives = [
  { name: "John Doe", position: "CEO", image: "/placeholder.svg" },
  { name: "Jane Smith", position: "CFO", image: "/placeholder.svg" },
  { name: "Mike Johnson", position: "CTO", image: "/placeholder.svg" },
  { name: "Sarah Brown", position: "COO", image: "/placeholder.svg" },
]
export function CSuiteOverview() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>C-Suite Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4">
          {executives.map((exec) => (
            <div key={exec.name} className="flex items-center space-x-4">
              <Avatar>
                <AvatarImage src={exec.image} alt={exec.name} />
                <AvatarFallback>
                  {exec.name
                    .split(" ")
                    .map((n) => n[0])
                    .join("")}
                </AvatarFallback>
              </Avatar>
              <div>
                <p className="font-medium">{exec.name}</p>
                <p className="text-sm text-muted-foreground">{exec.position}</p>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/context-aware-chart.tsx">
"use client"
import { useState, useCallback } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  BarChart,
  Bar,
  AreaChart,
  Area,
} from "recharts"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Loader2 } from "lucide-react"
interface ChartData {
  date: string
  [key: string]: number | string
}
export function ContextAwareChart() {
  const [chartData, setChartData] = useState<ChartData[]>([])
  const [userQuery, setUserQuery] = useState("")
  const [chartTitle, setChartTitle] = useState("Custom Chart")
  const [chartDescription, setChartDescription] = useState("Generated based on your query")
  const [error, setError] = useState<string | null>(null)
  const [chartType, setChartType] = useState<"line" | "area" | "bar">("line")
  const [isLoading, setIsLoading] = useState(false)
  const generateChartData = useCallback(async () => {
    if (!userQuery) return
    setIsLoading(true)
    setError(null)
    try {
      const response = await fetch('/api/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ prompt: `Generate chart data for the query: ${userQuery}` }),
      })
      if (!response.ok) {
        throw new Error('Failed to generate chart data')
      }
      const responseText = await response.text()
      let parsedData
      try {
        parsedData = JSON.parse(responseText)
      } catch (parseError) {
        console.error("Error parsing AI response:", parseError)
        setError("Failed to parse AI response. Please try again.")
        return
      }
      if (parsedData && parsedData.data && Array.isArray(parsedData.data)) {
        setChartData(parsedData.data)
        setChartTitle(parsedData.title || "Custom Chart")
        setChartDescription(parsedData.description || "Generated based on your query")
      } else {
        setError("Invalid data format received. Please try a different query.")
      }
    } catch (error) {
      console.error("Error generating chart data:", error)
      setError("Failed to generate chart data. Please try again.")
    } finally {
      setIsLoading(false)
    }
  }, [userQuery])
  const renderChart = () => {
    if (!chartData.length) return null
    const dataKeys = Object.keys(chartData[0]).filter((key) => key !== "date")
    const getRandomColor = () => `#${Math.floor(Math.random() * 16777215).toString(16)}`
    if (chartType === "line") {
      return (
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Legend />
            {dataKeys.map((key) => (
              <Line key={key} type="monotone" dataKey={key} stroke={getRandomColor()} />
            ))}
          </LineChart>
        </ResponsiveContainer>
      )
    }
    if (chartType === "area") {
      return (
        <ResponsiveContainer width="100%" height={400}>
          <AreaChart data={chartData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Legend />
            {dataKeys.map((key) => {
              const color = getRandomColor()
              return <Area key={key} type="monotone" dataKey={key} stroke={color} fill={color} />
            })}
          </AreaChart>
        </ResponsiveContainer>
      )
    }
    return (
      <ResponsiveContainer width="100%" height={400}>
        <BarChart data={chartData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          {dataKeys.map((key) => (
            <Bar key={key} dataKey={key} fill={getRandomColor()} />
          ))}
        </BarChart>
      </ResponsiveContainer>
    )
  }
  return (
    <Card>
      <CardHeader>
        <CardTitle>{chartTitle}</CardTitle>
        <CardDescription>{chartDescription}</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex space-x-2 mb-4">
          <Input
            placeholder="Enter your chart query (e.g., 'Show SPX vs VIX last month')"
            value={userQuery}
            onChange={(e) => setUserQuery(e.target.value)}
            className="flex-1"
          />
          <Select value={chartType} onValueChange={(value: "line" | "area" | "bar") => setChartType(value)}>
            <SelectTrigger className="w-[120px]">
              <SelectValue placeholder="Chart Type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="line">Line</SelectItem>
              <SelectItem value="area">Area</SelectItem>
              <SelectItem value="bar">Bar</SelectItem>
            </SelectContent>
          </Select>
          <Button onClick={generateChartData} disabled={isLoading}>
            {isLoading ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : "Generate"}
          </Button>
        </div>
        {error && <div className="mb-4 p-2 bg-red-100 border border-red-400 text-red-700 rounded">{error}</div>}
        {chartData.length > 0 ? (
          renderChart()
        ) : (
          <div className="flex items-center justify-center h-[400px] border rounded-lg bg-muted/5">
            <p className="text-muted-foreground">Describe what you want to visualize and click Generate</p>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/crypto-heatmap.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, Treemap, Tooltip } from "recharts"
const COLORS = ["#8884d8", "#82ca9d", "#ffc658", "#ff8042", "#0088FE", "#00C49F"]
const data = [
  { name: "Bitcoin", size: 400, color: "#F7931A" },
  { name: "Ethereum", size: 300, color: "#627EEA" },
  { name: "Binance Coin", size: 200, color: "#F3BA2F" },
  { name: "Cardano", size: 100, color: "#0D1E30" },
  { name: "Solana", size: 100, color: "#00FFA3" },
]
export function CryptoHeatmap() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Crypto Market Heatmap</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={400}>
          <Treemap
            data={data}
            dataKey="size"
            ratio={4 / 3}
            stroke="#fff"
            fill="#8884d8"
            content={({ root, depth, x, y, width, height, index, payload, name }) => (
              <g>
                <rect
                  x={x}
                  y={y}
                  width={width}
                  height={height}
                  style={{
                    fill: depth < 2 ? COLORS[Math.floor((index / root.children.length) * COLORS.length)] : "#ffffff00",
                    stroke: "#fff",
                    strokeWidth: 2 / (depth + 1e-10),
                    strokeOpacity: 1 / (depth + 1e-10),
                  }}
                />
                {depth === 1 ? (
                  <text x={x + width / 2} y={y + height / 2 + 7} textAnchor="middle" fill="#fff" fontSize={14}>
                    {name}
                  </text>
                ) : null}
              </g>
            )}
          >
            <Tooltip content={<CustomTooltip />} />
          </Treemap>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
const CustomTooltip = ({ active, payload }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-background p-2 border rounded shadow">
        <p>{`${payload[0].payload.name} : ${payload[0].value}`}</p>
      </div>
    )
  }
  return null
}
</file>

<file path="components/crypto-screener.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
const mockCryptos = [
  { symbol: "BTC", name: "Bitcoin", price: 45000, marketCap: "850B", volume24h: "30B" },
  { symbol: "ETH", name: "Ethereum", price: 3000, marketCap: "350B", volume24h: "20B" },
  { symbol: "ADA", name: "Cardano", price: 2.1, marketCap: "70B", volume24h: "5B" },
]
export function CryptoScreener() {
  const [searchTerm, setSearchTerm] = useState("")
  const [sortBy, setSortBy] = useState("symbol")
  const filteredCryptos = mockCryptos
    .filter((crypto) => crypto.symbol.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1))
  return (
    <Card>
      <CardHeader>
        <CardTitle>Crypto Screener</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex space-x-2 mb-4">
          <Input
            placeholder="Search by symbol"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="max-w-sm"
          />
          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Sort by" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="symbol">Symbol</SelectItem>
              <SelectItem value="price">Price</SelectItem>
              <SelectItem value="marketCap">Market Cap</SelectItem>
              <SelectItem value="volume24h">24h Volume</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Symbol</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Price</TableHead>
              <TableHead>Market Cap</TableHead>
              <TableHead>24h Volume</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredCryptos.map((crypto) => (
              <TableRow key={crypto.symbol}>
                <TableCell>{crypto.symbol}</TableCell>
                <TableCell>{crypto.name}</TableCell>
                <TableCell>${crypto.price.toFixed(2)}</TableCell>
                <TableCell>{crypto.marketCap}</TableCell>
                <TableCell>{crypto.volume24h}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/dashboard-layout.tsx">
"use client"
import { useState, useCallback } from "react"
import { Responsive, WidthProvider, Layout } from "react-grid-layout"
import "react-grid-layout/css/styles.css"
import "react-resizable/css/styles.css"
import { TradingVolume } from "@/components/trading-volume"
import { AIInsights } from "@/components/ai-insights"
import { GenerativeTradingIdeas } from "@/components/generative-trading-ideas"
import { OptionChain } from "@/components/option-chain"
import { SmartMoneyFlow } from "@/components/smart-money-flow"
import { SupportResistanceLevels } from "@/components/support-resistance-levels"
import { MarketBreadth } from "@/components/market-breadth"
import { LiveMarketData } from "@/components/live-market-data"
import { TechnicalAnalysis } from "@/components/technical-analysis"
import { GenerativeMarketInsights } from "@/components/generative-ui/market-insights"
import { GenerativeTradeSuggestions } from "@/components/generative-ui/trade-suggestions"
import { GenerativeDataVisualization } from "@/components/generative-ui/data-visualization"
import { OrderBookVisualization } from "@/components/order-book-visualization"
import { ContextAwareChart } from "@/components/context-aware-chart"
import { GenerativeNewsPanel } from "@/components/generative-news-panel"
import { GenerativeChat } from "@/components/generative-chat"
import { PortfolioOverview } from "@/components/portfolio-overview"
import { useUserPreferences } from "@/lib/hooks/use-user-preferences"
const defaultLayout: Layout[] = [
  { i: "live-market-data", x: 0, y: 0, w: 12, h: 4, minH: 4, isDraggable: false },
  { i: "trading-volume", x: 0, y: 4, w: 6, h: 4, minH: 4 },
  { i: "ai-insights", x: 6, y: 4, w: 6, h: 4, minH: 4 },
  { i: "trading-ideas", x: 0, y: 8, w: 6, h: 4, minH: 4 },
  { i: "option-chain", x: 6, y: 8, w: 6, h: 4, minH: 4 },
  { i: "smart-money", x: 0, y: 12, w: 6, h: 4, minH: 4 },
  { i: "support-resistance", x: 6, y: 12, w: 6, h: 4, minH: 4 },
  { i: "market-breadth", x: 0, y: 16, w: 6, h: 4, minH: 4 },
  { i: "technical-analysis", x: 6, y: 16, w: 6, h: 4, minH: 4 },
  { i: "generative-market-insights", x: 0, y: 20, w: 6, h: 4, minH: 4 },
  { i: "generative-trade-suggestions", x: 6, y: 20, w: 6, h: 4, minH: 4 },
  { i: "generative-data-visualization", x: 0, y: 24, w: 12, h: 6, minH: 6 },
  { i: "order-book-visualization", x: 0, y: 30, w: 6, h: 4, minH: 4 },
  { i: "context-aware-chart", x: 6, y: 30, w: 6, h: 4, minH: 4 },
  { i: "generative-news-panel", x: 0, y: 34, w: 6, h: 4, minH: 4 },
  { i: "generative-chat", x: 6, y: 34, w: 6, h: 4, minH: 4 },
  { i: "portfolio-overview", x: 0, y: 38, w: 12, h: 4, minH: 4 },
]
const ResponsiveGridLayout = WidthProvider(Responsive)
export function DashboardLayout() {
  const { preferences, updateLayout } = useUserPreferences()
  const [layout, setLayout] = useState<Layout[]>(() => {
    if (Array.isArray(preferences.layout) && preferences.layout.length > 0) {
      return preferences.layout.map(item => ({
        ...defaultLayout.find(d => d.i === item.i) || item,
        isDraggable: item.i !== "live-market-data"
      }))
    }
    return defaultLayout
  })
  const handleLayoutChange = useCallback(
    (currentLayout: Layout[]) => {
      const updatedLayout = currentLayout.map(item => ({
        ...item,
        isDraggable: item.i !== "live-market-data",
        minH: defaultLayout.find(d => d.i === item.i)?.minH || item.minH
      }))
      setLayout(updatedLayout)
      updateLayout(updatedLayout)
    },
    [updateLayout],
  )
  return (
    <div className="h-full w-full bg-background overflow-x-hidden">
      <div className="w-full h-full px-4">
        <ResponsiveGridLayout
          className="layout"
          layouts={{ lg: layout }}
          breakpoints={{ lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 }}
          cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 }}
          rowHeight={100}
          onLayoutChange={handleLayoutChange}
          isDraggable
          isResizable
          margin={[16, 16]}
          containerPadding={[0, 0]}
        >
          <div key="live-market-data" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <LiveMarketData />
          </div>
          <div key="trading-volume" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <TradingVolume />
          </div>
          <div key="ai-insights" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <AIInsights />
          </div>
          <div key="trading-ideas" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeTradingIdeas />
          </div>
          <div key="option-chain" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <OptionChain />
          </div>
          <div key="smart-money" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <SmartMoneyFlow />
          </div>
          <div key="support-resistance" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <SupportResistanceLevels />
          </div>
          <div key="market-breadth" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <MarketBreadth />
          </div>
          <div key="technical-analysis" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <TechnicalAnalysis />
          </div>
          <div key="generative-market-insights" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeMarketInsights />
          </div>
          <div key="generative-trade-suggestions" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeTradeSuggestions />
          </div>
          <div key="generative-data-visualization" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeDataVisualization />
          </div>
          <div key="order-book-visualization" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <OrderBookVisualization />
          </div>
          <div key="context-aware-chart" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <ContextAwareChart />
          </div>
          <div key="generative-news-panel" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeNewsPanel />
          </div>
          <div key="generative-chat" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <GenerativeChat />
          </div>
          <div key="portfolio-overview" className="w-full h-full overflow-hidden rounded-lg border bg-card p-4 shadow-sm">
            <PortfolioOverview />
          </div>
        </ResponsiveGridLayout>
      </div>
    </div>
  )
}
</file>

<file path="components/Dashboard.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { dashboardService } from '../lib/services/dashboard-service';
import type { WidgetConfig, ChartConfig } from '../lib/types/market-data';
interface DashboardProps {
  defaultLayout?: 'grid' | 'flex' | 'custom';
  defaultTheme?: 'light' | 'dark';
  refreshInterval?: number;
}
const Dashboard: React.FC<DashboardProps> = ({
  defaultLayout = 'grid',
  defaultTheme = 'light',
  refreshInterval = 5000,
}) => {
  const [widgets, setWidgets] = useState<WidgetConfig[]>([]);
  const [layout, setLayout] = useState(defaultLayout);
  const [theme, setTheme] = useState(defaultTheme);
  const [widgetData, setWidgetData] = useState<Record<string, any>>({});
  useEffect(() => {
    // Initialize dashboard
    dashboardService.initialize({
      layout: defaultLayout,
      theme: defaultTheme,
      refreshInterval,
    });
    // Set up event listeners
    const handleWidgetData = ({ widgetId, data }: { widgetId: string; data: any }) => {
      setWidgetData(prev => ({ ...prev, [widgetId]: data }));
    };
    const handleWidgetAdded = (widget: WidgetConfig) => {
      setWidgets(prev => [...prev, widget]);
    };
    const handleWidgetRemoved = (widgetId: string) => {
      setWidgets(prev => prev.filter(w => w.id !== widgetId));
      setWidgetData(prev => {
        const { [widgetId]: removed, ...rest } = prev;
        return rest;
      });
    };
    const handleWidgetUpdated = (widget: WidgetConfig) => {
      setWidgets(prev => prev.map(w => w.id === widget.id ? widget : w));
    };
    const handleThemeChanged = (newTheme: 'light' | 'dark') => {
      setTheme(newTheme);
    };
    const handleLayoutChanged = (newLayout: 'grid' | 'flex' | 'custom') => {
      setLayout(newLayout);
    };
    dashboardService.on('widgetData', handleWidgetData);
    dashboardService.on('widgetAdded', handleWidgetAdded);
    dashboardService.on('widgetRemoved', handleWidgetRemoved);
    dashboardService.on('widgetUpdated', handleWidgetUpdated);
    dashboardService.on('themeChanged', handleThemeChanged);
    dashboardService.on('layoutChanged', handleLayoutChanged);
    // Load initial widgets
    setWidgets(dashboardService.getAllWidgets());
    return () => {
      // Clean up event listeners
      dashboardService.removeListener('widgetData', handleWidgetData);
      dashboardService.removeListener('widgetAdded', handleWidgetAdded);
      dashboardService.removeListener('widgetRemoved', handleWidgetRemoved);
      dashboardService.removeListener('widgetUpdated', handleWidgetUpdated);
      dashboardService.removeListener('themeChanged', handleThemeChanged);
      dashboardService.removeListener('layoutChanged', handleLayoutChanged);
    };
  }, [defaultLayout, defaultTheme, refreshInterval]);
  const handleAddWidget = useCallback(async (config: WidgetConfig) => {
    try {
      await dashboardService.addWidget(config);
    } catch (error) {
      console.error('Error adding widget:', error);
    }
  }, []);
  const handleRemoveWidget = useCallback(async (widgetId: string) => {
    try {
      await dashboardService.removeWidget(widgetId);
    } catch (error) {
      console.error('Error removing widget:', error);
    }
  }, []);
  const handleUpdateWidget = useCallback(async (
    widgetId: string,
    updates: Partial<WidgetConfig>
  ) => {
    try {
      await dashboardService.updateWidget(widgetId, updates);
    } catch (error) {
      console.error('Error updating widget:', error);
    }
  }, []);
  const handleThemeToggle = useCallback(() => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    dashboardService.setTheme(newTheme);
  }, [theme]);
  const handleLayoutChange = useCallback((newLayout: 'grid' | 'flex' | 'custom') => {
    dashboardService.setLayout(newLayout);
  }, []);
  return (
    <div className={`dashboard ${theme} ${layout}`}>
      <div className="dashboard-header">
        <h1>Trading Dashboard</h1>
        <div className="dashboard-controls">
          <button onClick={handleThemeToggle}>
            Toggle {theme === 'light' ? 'Dark' : 'Light'} Mode
          </button>
          <select
            value={layout}
            onChange={(e) => handleLayoutChange(e.target.value as any)}
          >
            <option value="grid">Grid Layout</option>
            <option value="flex">Flex Layout</option>
            <option value="custom">Custom Layout</option>
          </select>
          <button onClick={() => handleAddWidget({
            id: `widget-${Date.now()}`,
            type: 'chart',
            position: { x: 0, y: 0, width: 2, height: 2 },
            settings: {
              symbol: 'AAPL',
              chartConfig: {
                type: 'line',
                timeframe: '1m',
              } as ChartConfig,
            },
          })}>
            Add Chart Widget
          </button>
        </div>
      </div>
      <div className={`dashboard-grid ${layout}`}>
        {widgets.map(widget => (
          <div
            key={widget.id}
            className={`widget ${widget.type}`}
            style={{
              gridColumn: `span ${widget.position.width}`,
              gridRow: `span ${widget.position.height}`,
            }}
          >
            <div className="widget-header">
              <h3>{widget.settings.symbol}</h3>
              <div className="widget-controls">
                <button onClick={() => handleUpdateWidget(widget.id, {
                  position: {
                    ...widget.position,
                    width: widget.position.width + 1,
                  },
                })}>
                  Expand
                </button>
                <button onClick={() => handleRemoveWidget(widget.id)}>
                  Remove
                </button>
              </div>
            </div>
            <div className="widget-content">
              {widgetData[widget.id] ? (
                <pre>{JSON.stringify(widgetData[widget.id], null, 2)}</pre>
              ) : (
                <div className="widget-loading">Loading...</div>
              )}
            </div>
          </div>
        ))}
      </div>
      <style jsx>{`
        .dashboard {
          padding: 20px;
          min-height: 100vh;
          background: ${theme === 'light' ? '#f5f5f5' : '#1a1a1a'};
          color: ${theme === 'light' ? '#000' : '#fff'};
        }
        .dashboard-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
        }
        .dashboard-controls {
          display: flex;
          gap: 10px;
        }
        .dashboard-grid {
          display: grid;
          gap: 20px;
          padding: 20px;
        }
        .dashboard-grid.grid {
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }
        .dashboard-grid.flex {
          display: flex;
          flex-wrap: wrap;
        }
        .widget {
          background: ${theme === 'light' ? '#fff' : '#2a2a2a'};
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          padding: 15px;
        }
        .widget-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 10px;
        }
        .widget-controls {
          display: flex;
          gap: 5px;
        }
        .widget-content {
          min-height: 200px;
        }
        .widget-loading {
          display: flex;
          align-items: center;
          justify-content: center;
          height: 200px;
          color: #666;
        }
        button {
          padding: 8px 12px;
          border-radius: 4px;
          border: none;
          background: ${theme === 'light' ? '#007bff' : '#0056b3'};
          color: white;
          cursor: pointer;
        }
        button:hover {
          background: ${theme === 'light' ? '#0056b3' : '#003d80'};
        }
        select {
          padding: 8px;
          border-radius: 4px;
          border: 1px solid #ccc;
          background: ${theme === 'light' ? '#fff' : '#2a2a2a'};
          color: ${theme === 'light' ? '#000' : '#fff'};
        }
      `}</style>
    </div>
  );
};
export default Dashboard;
</file>

<file path="components/draggable-grid.tsx">
"use client"
import { useState, useEffect, useRef } from "react"
import { motion, AnimatePresence } from "framer-motion"
import { Move } from "lucide-react"
import type React from "react"
interface DraggableGridProps {
  children: React.ReactNode[]
  onLayoutChange?: (newLayout: string[]) => void
  editMode: boolean
  freeMovement?: boolean
}
export function DraggableGrid({ children, onLayoutChange, editMode, freeMovement }: DraggableGridProps) {
  const [items, setItems] = useState(children)
  const gridRef = useRef<HTMLDivElement>(null)
  const [positions, setPositions] = useState<{ [key: string]: number }>({})
  const [layout, setLayout] = useState<string[]>([])
  useEffect(() => {
    setItems(children)
    // Initialize positions if they don't exist
    const initialPositions: { [key: string]: number } = {}
    const initialLayout: string[] = []
    children.forEach((child: any, index) => {
      if (child?.key) {
        initialPositions[child.key] = index
        initialLayout.push(child.key)
      }
    })
    setPositions(initialPositions)
    setLayout(initialLayout)
  }, [children])
  const findClosestDropZone = (x: number, y: number) => {
    if (!gridRef.current) return 0
    const gridItems = Array.from(gridRef.current.children)
    let closestIndex = 0
    let closestDistance = Number.POSITIVE_INFINITY
    gridItems.forEach((item, index) => {
      const rect = item.getBoundingClientRect()
      const centerX = rect.left + rect.width / 2
      const centerY = rect.top + rect.height / 2
      const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2))
      if (distance < closestDistance) {
        closestDistance = distance
        closestIndex = index
      }
    })
    return closestIndex
  }
  const onDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: any, itemKey: string) => {
    if (!editMode) return
    const dropIndex = findClosestDropZone(info.point.x, info.point.y)
    const draggedItemIndex = Object.values(positions).indexOf(positions[itemKey])
    if (freeMovement) {
      const newLayout = [...layout]
      const draggedIndex = newLayout.indexOf(itemKey)
      newLayout.splice(draggedIndex, 1)
      newLayout.splice(dropIndex, 0, itemKey)
      if (onLayoutChange) {
        onLayoutChange(newLayout)
      }
    } else {
      if (draggedItemIndex !== dropIndex) {
        const newPositions = { ...positions }
        // Update positions of items between drag start and drop positions
        Object.keys(newPositions).forEach((key) => {
          const currentPos = newPositions[key]
          if (draggedItemIndex < dropIndex) {
            if (currentPos > draggedItemIndex && currentPos <= dropIndex) {
              newPositions[key]--
            }
          } else {
            if (currentPos >= dropIndex && currentPos < draggedItemIndex) {
              newPositions[key]++
            }
          }
        })
        newPositions[itemKey] = dropIndex
        setPositions(newPositions)
        // Update layout
        const newLayout = Object.entries(newPositions)
          .sort(([, a], [, b]) => a - b)
          .map(([key]) => key)
        if (onLayoutChange) {
          onLayoutChange(newLayout)
        }
      }
    }
  }
  const sortedItems = [...items].sort((a: any, b: any) => {
    return (positions[a.key] || 0) - (positions[b.key] || 0)
  })
  return (
    <AnimatePresence>
      <motion.div
        ref={gridRef}
        className={`grid gap-4 p-4 ${
          freeMovement
            ? "grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4"
            : "grid-cols-1 md:grid-cols-2 lg:grid-cols-3"
        }`}
        layout
      >
        {sortedItems.map((item: any) => (
          <motion.div
            key={item.key}
            layout
            drag={editMode}
            dragMomentum={false}
            dragElastic={0.1}
            onDragEnd={(event, info) => onDragEnd(event, info, item.key)}
            className="relative"
            whileHover={editMode ? { scale: 1.02 } : undefined}
            whileDrag={{ scale: 1.05, zIndex: 1 }}
          >
            {editMode && (
              <div className="absolute top-2 right-2 z-10 p-1 rounded-full bg-background/80 backdrop-blur-sm opacity-75">
                <Move className="h-4 w-4" />
              </div>
            )}
            {item}
          </motion.div>
        ))}
      </motion.div>
    </AnimatePresence>
  )
}
</file>

<file path="components/economic-calendar.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface EconomicEvent {
  time: string
  event: string
  impact: "high" | "medium" | "low"
}
const mockEvents: EconomicEvent[] = [
  { time: "08:30", event: "US Nonfarm Payrolls", impact: "high" },
  { time: "10:00", event: "EU Consumer Confidence", impact: "medium" },
  { time: "14:00", event: "Fed Interest Rate Decision", impact: "high" },
  { time: "22:30", event: "AU Unemployment Rate", impact: "medium" },
]
export function EconomicCalendar() {
  return (
    <Card>
      <CardContent className="p-4">
        <ul className="space-y-3">
          {mockEvents.map((event, index) => (
            <li key={index} className="flex items-center justify-between">
              <div>
                <span className="text-sm font-medium mr-2">{event.time}</span>
                <span className="text-sm">{event.event}</span>
              </div>
              <Badge
                variant={event.impact === "high" ? "destructive" : event.impact === "medium" ? "secondary" : "outline"}
              >
                {event.impact.toUpperCase()}
              </Badge>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/economics-earnings-calendar.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
const economicEvents = [
  { date: "2023-06-15", time: "08:30", event: "US Initial Jobless Claims", impact: "high" },
  { date: "2023-06-16", time: "10:00", event: "US Consumer Sentiment", impact: "medium" },
  { date: "2023-06-17", time: "14:00", event: "Fed Interest Rate Decision", impact: "high" },
]
const earningsEvents = [
  { date: "2023-06-15", time: "After Market", company: "Adobe Inc.", symbol: "ADBE", expectedEPS: 3.5 },
  { date: "2023-06-16", time: "Before Market", company: "Kroger Co.", symbol: "KR", expectedEPS: 1.45 },
  { date: "2023-06-17", time: "After Market", company: "FedEx Corporation", symbol: "FDX", expectedEPS: 4.85 },
]
export function EconomicsEarningsCalendar() {
  const [activeTab, setActiveTab] = useState("economic")
  return (
    <Card>
      <CardHeader>
        <CardTitle>Economics & Earnings Calendar</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="economic">Economic Events</TabsTrigger>
            <TabsTrigger value="earnings">Earnings</TabsTrigger>
          </TabsList>
          <TabsContent value="economic">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Date</TableHead>
                  <TableHead>Time</TableHead>
                  <TableHead>Event</TableHead>
                  <TableHead>Impact</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {economicEvents.map((event, index) => (
                  <TableRow key={index}>
                    <TableCell>{event.date}</TableCell>
                    <TableCell>{event.time}</TableCell>
                    <TableCell>{event.event}</TableCell>
                    <TableCell>
                      <Badge
                        variant={
                          event.impact === "high" ? "destructive" : event.impact === "medium" ? "default" : "secondary"
                        }
                      >
                        {event.impact}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TabsContent>
          <TabsContent value="earnings">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Date</TableHead>
                  <TableHead>Time</TableHead>
                  <TableHead>Company</TableHead>
                  <TableHead>Symbol</TableHead>
                  <TableHead>Expected EPS</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {earningsEvents.map((event, index) => (
                  <TableRow key={index}>
                    <TableCell>{event.date}</TableCell>
                    <TableCell>{event.time}</TableCell>
                    <TableCell>{event.company}</TableCell>
                    <TableCell>{event.symbol}</TableCell>
                    <TableCell>${event.expectedEPS.toFixed(2)}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/error-boundary.tsx">
import React, { type ErrorInfo, type ReactNode } from "react"
interface ErrorBoundaryProps {
  children: ReactNode
}
interface ErrorBoundaryState {
  hasError: boolean
}
class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }
  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    // Update state so the next render will show the fallback UI.
    return { hasError: true }
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // You can also log the error to an error reporting service
    console.error("Uncaught error:", error, errorInfo)
  }
  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="flex items-center justify-center h-screen bg-background">
          <div className="text-center">
            <h1 className="text-2xl font-bold mb-4">Oops! Something went wrong.</h1>
            <p className="mb-4">We're sorry for the inconvenience. Please try refreshing the page.</p>
            <button
              className="px-4 py-2 bg-primary text-primary-foreground rounded hover:bg-primary/90"
              onClick={() => this.setState({ hasError: false })}
            >
              Try again
            </button>
          </div>
        </div>
      )
    }
    return this.props.children
  }
}
export default ErrorBoundary
</file>

<file path="components/error-message.tsx">
import { AlertCircle } from "lucide-react"
import { Button } from "@/components/ui/button"
interface ErrorMessageProps {
  message: string
  onRetry?: () => void
}
export function ErrorMessage({ message, onRetry }: ErrorMessageProps) {
  return (
    <div className="flex flex-col items-center justify-center space-y-4 text-center">
      <AlertCircle className="h-8 w-8 text-destructive" />
      <p className="text-sm text-muted-foreground">{message}</p>
      {onRetry && (
        <Button variant="outline" onClick={onRetry}>
          Try Again
        </Button>
      )}
    </div>
  )
}
</file>

<file path="components/esg-scorecard.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
const esgScores = [
  { category: "Environmental", score: 75 },
  { category: "Social", score: 82 },
  { category: "Governance", score: 90 },
]
export function ESGScorecard() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>ESG Scorecard</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {esgScores.map((item) => (
            <div key={item.category}>
              <div className="flex justify-between mb-1">
                <span className="text-sm font-medium">{item.category}</span>
                <span className="text-sm font-medium">{item.score}/100</span>
              </div>
              <Progress value={item.score} className="h-2" />
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/etf-heatmap.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, Treemap, Tooltip } from "recharts"
const COLORS = ["#8884d8", "#82ca9d", "#ffc658", "#ff8042", "#0088FE", "#00C49F"]
const data = [
  { name: "Equity", size: 400, color: "#8884d8" },
  { name: "Fixed Income", size: 300, color: "#82ca9d" },
  { name: "Commodities", size: 200, color: "#ffc658" },
  { name: "Real Estate", size: 100, color: "#ff8042" },
  { name: "Alternatives", size: 100, color: "#0088FE" },
]
export function ETFHeatmap() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>ETF Market Heatmap</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={400}>
          <Treemap
            data={data}
            dataKey="size"
            ratio={4 / 3}
            stroke="#fff"
            fill="#8884d8"
            content={({ root, depth, x, y, width, height, index, payload, name }) => (
              <g>
                <rect
                  x={x}
                  y={y}
                  width={width}
                  height={height}
                  style={{
                    fill: depth < 2 ? COLORS[Math.floor((index / root.children.length) * COLORS.length)] : "#ffffff00",
                    stroke: "#fff",
                    strokeWidth: 2 / (depth + 1e-10),
                    strokeOpacity: 1 / (depth + 1e-10),
                  }}
                />
                {depth === 1 ? (
                  <text x={x + width / 2} y={y + height / 2 + 7} textAnchor="middle" fill="#fff" fontSize={14}>
                    {name}
                  </text>
                ) : null}
              </g>
            )}
          >
            <Tooltip content={<CustomTooltip />} />
          </Treemap>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
const CustomTooltip = ({ active, payload }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-background p-2 border rounded shadow">
        <p>{`${payload[0].payload.name} : ${payload[0].value}`}</p>
      </div>
    )
  }
  return null
}
</file>

<file path="components/etf-screener.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
const mockETFs = [
  { symbol: "SPY", name: "SPDR S&P 500 ETF Trust", expense: 0.09, aum: "374B", yield: 1.52 },
  { symbol: "QQQ", name: "Invesco QQQ Trust", expense: 0.2, aum: "160B", yield: 0.67 },
  { symbol: "VTI", name: "Vanguard Total Stock Market ETF", expense: 0.03, aum: "270B", yield: 1.48 },
]
export function ETFScreener() {
  const [searchTerm, setSearchTerm] = useState("")
  const [sortBy, setSortBy] = useState("symbol")
  const filteredETFs = mockETFs
    .filter((etf) => etf.symbol.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1))
  return (
    <Card>
      <CardHeader>
        <CardTitle>ETF Screener</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex space-x-2 mb-4">
          <Input
            placeholder="Search by symbol"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="max-w-sm"
          />
          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Sort by" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="symbol">Symbol</SelectItem>
              <SelectItem value="expense">Expense Ratio</SelectItem>
              <SelectItem value="aum">AUM</SelectItem>
              <SelectItem value="yield">Yield</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Symbol</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Expense Ratio</TableHead>
              <TableHead>AUM</TableHead>
              <TableHead>Yield</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredETFs.map((etf) => (
              <TableRow key={etf.symbol}>
                <TableCell>{etf.symbol}</TableCell>
                <TableCell>{etf.name}</TableCell>
                <TableCell>{etf.expense.toFixed(2)}%</TableCell>
                <TableCell>{etf.aum}</TableCell>
                <TableCell>{etf.yield.toFixed(2)}%</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-chat.tsx">
"use client"
import { useChat } from "ai/react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card } from "@/components/ui/card"
import { ScrollArea } from "@/components/ui/scroll-area"
import { WeatherDisplay } from "./weather-display"
export function GenerativeChat() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat()
  return (
    <Card className="flex flex-col h-[600px]">
      <ScrollArea className="flex-1 p-4">
        <div className="space-y-4">
          {messages.map((message) => (
            <div key={message.id} className={`flex ${message.role === "user" ? "justify-end" : "justify-start"}`}>
              <div
                className={`rounded-lg px-4 py-2 max-w-[80%] ${
                  message.role === "user" ? "bg-primary text-primary-foreground" : "bg-muted"
                }`}
              >
                <p>{message.content}</p>
                {message.function_call?.name === "getWeather" && message.function_call.response && (
                  <WeatherDisplay {...JSON.parse(message.function_call.response)} />
                )}
              </div>
            </div>
          ))}
        </div>
      </ScrollArea>
      <div className="p-4 border-t">
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            value={input}
            onChange={handleInputChange}
            placeholder="Ask about the weather..."
            disabled={isLoading}
          />
          <Button type="submit" disabled={isLoading}>
            Send
          </Button>
        </form>
      </div>
    </Card>
  )
}
</file>

<file path="components/generative-market-updates.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { ArrowUpRight, TrendingUp, Zap, Globe } from "lucide-react"
interface MarketUpdate {
  id: string
  type: "price" | "news" | "trend" | "alert"
  content: string
  impact: "positive" | "negative" | "neutral"
  timestamp: Date
}
const generateMockUpdates = (): MarketUpdate[] => {
  const types = ["price", "news", "trend", "alert"]
  const impacts = ["positive", "negative", "neutral"]
  return Array.from({ length: 10 }, (_, i) => ({
    id: `update-${i}`,
    type: types[Math.floor(Math.random() * types.length)] as "price" | "news" | "trend" | "alert",
    content: `Generated market update ${i + 1}`,
    impact: impacts[Math.floor(Math.random() * impacts.length)] as "positive" | "negative" | "neutral",
    timestamp: new Date(Date.now() - Math.floor(Math.random() * 3600000)),
  }))
}
export function GenerativeMarketUpdates() {
  const [updates, setUpdates] = useState<MarketUpdate[]>(generateMockUpdates())
  useEffect(() => {
    const interval = setInterval(() => {
      setUpdates((prevUpdates) => {
        const newUpdate = generateMockUpdates()[0]
        return [newUpdate, ...prevUpdates.slice(0, -1)]
      })
    }, 5000) // Generate a new update every 5 seconds
    return () => clearInterval(interval)
  }, [])
  const getUpdateIcon = (type: string) => {
    switch (type) {
      case "price":
        return <TrendingUp className="h-4 w-4" />
      case "news":
        return <Globe className="h-4 w-4" />
      case "trend":
        return <ArrowUpRight className="h-4 w-4" />
      case "alert":
        return <Zap className="h-4 w-4" />
      default:
        return null
    }
  }
  const getImpactColor = (impact: string) => {
    switch (impact) {
      case "positive":
        return "bg-green-500/10 text-green-500"
      case "negative":
        return "bg-red-500/10 text-red-500"
      case "neutral":
        return "bg-yellow-500/10 text-yellow-500"
      default:
        return ""
    }
  }
  return (
    <Card className="h-full overflow-hidden">
      <CardHeader>
        <CardTitle>Real-Time Market Updates</CardTitle>
      </CardHeader>
      <CardContent className="p-0">
        <div className="space-y-0 overflow-y-auto max-h-[400px]">
          {updates.map((update) => (
            <div
              key={update.id}
              className="p-4 border-b last:border-b-0 flex items-center justify-between hover:bg-muted/50 transition-colors"
            >
              <div className="flex items-center space-x-3">
                <div className={`p-2 rounded-full ${getImpactColor(update.impact)}`}>{getUpdateIcon(update.type)}</div>
                <div>
                  <p className="text-sm font-medium">{update.content}</p>
                  <p className="text-xs text-muted-foreground">
                    {update.timestamp.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
                  </p>
                </div>
              </div>
              <Badge variant="outline" className={getImpactColor(update.impact)}>
                {update.type}
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-news-panel.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { AlertTriangle, TrendingUp, TrendingDown, BarChart2, RefreshCcw, ChevronDown, ChevronUp } from 'lucide-react'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { useCompletion } from "ai/react"
interface NewsItem {
  id: string
  title: string
  summary: string
  sentiment: "positive" | "negative" | "neutral"
  importance: "high" | "medium" | "low"
  tickers: string[]
  aiSummary?: string
  timestamp: Date
  source: string
}
const fixedNews: NewsItem[] = [
  {
    id: "1",
    title: "Fed Signals Potential Rate Cuts in 2024",
    summary: "Federal Reserve officials indicated they expect to cut interest rates next year...",
    sentiment: "positive",
    importance: "high",
    tickers: ["SPY", "QQQ", "IWM"],
    timestamp: new Date(),
    source: "Wall Street Journal",
  },
  {
    id: "2",
    title: "Tech Giants Face New Antitrust Scrutiny",
    summary: "Major technology companies are under investigation for potential monopolistic practices...",
    sentiment: "negative",
    importance: "medium",
    tickers: ["AAPL", "GOOGL", "MSFT", "AMZN"],
    timestamp: new Date(Date.now() - 1000 * 60 * 60), // 1 hour ago
    source: "Reuters",
  },
  {
    id: "3",
    title: "Oil Prices Surge Amid Middle East Tensions",
    summary: "Crude oil prices have spiked due to escalating geopolitical tensions...",
    sentiment: "neutral",
    importance: "high",
    tickers: ["USO", "XLE", "CVX", "XOM"],
    timestamp: new Date(Date.now() - 1000 * 60 * 120), // 2 hours ago
    source: "Bloomberg",
  },
]
export function GenerativeNewsPanel() {
  const [news, setNews] = useState<NewsItem[]>(fixedNews)
  const [expandedItem, setExpandedItem] = useState<string | null>(null)
  const [filter, setFilter] = useState<"all" | "high" | "medium" | "low">("all")
  const [sortBy, setSortBy] = useState<"latest" | "importance">("latest")
  const { complete } = useCompletion({
    api: "/api/generate-insights",
  })
  const fetchNews = useCallback(async () => {
    // Simulating API call to fetch new articles
    const newArticle: NewsItem = {
      id: Date.now().toString(),
      title: `Breaking: Major market movement in ${["tech", "finance", "healthcare", "energy"][Math.floor(Math.random() * 4)]} sector`,
      summary: "Lorem ipsum dolor sit amet, consectetur adipiscing elit...",
      sentiment: ["positive", "negative", "neutral"][Math.floor(Math.random() * 3)] as
        | "positive"
        | "negative"
        | "neutral",
      importance: ["high", "medium", "low"][Math.floor(Math.random() * 3)] as "high" | "medium" | "low",
      tickers: ["AAPL", "GOOGL", "MSFT", "AMZN"].slice(0, Math.floor(Math.random() * 3) + 1),
      timestamp: new Date(),
      source: ["Bloomberg", "Reuters", "CNBC", "Wall Street Journal"][Math.floor(Math.random() * 4)],
    }
    setNews((prevNews) => [newArticle, ...prevNews.slice(0, 9)])
    // Generate AI summary for the new article
    const aiSummary = await complete(JSON.stringify(newArticle))
    setNews((prevNews) => prevNews.map((item) => (item.id === newArticle.id ? { ...item, aiSummary } : item)))
  }, [complete])
  useEffect(() => {
    const interval = setInterval(fetchNews, 30000) // Fetch news every 30 seconds
    return () => clearInterval(interval)
  }, [fetchNews])
  const filteredNews = news
    .filter((item) => (filter === "all" ? true : item.importance === filter))
    .sort((a, b) => {
      if (sortBy === "latest") {
        return b.timestamp.getTime() - a.timestamp.getTime()
      } else {
        const importanceOrder = { high: 3, medium: 2, low: 1 }
        return importanceOrder[b.importance] - importanceOrder[a.importance]
      }
    })
  const getSentimentIcon = (sentiment: string) => {
    switch (sentiment) {
      case "positive":
        return <TrendingUp className="h-4 w-4 text-green-500" />
      case "negative":
        return <TrendingDown className="h-4 w-4 text-red-500" />
      default:
        return <BarChart2 className="h-4 w-4 text-yellow-500" />
    }
  }
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Live Market Updates</CardTitle>
            <CardDescription>AI-enhanced news analysis and market impact</CardDescription>
          </div>
          <div className="flex items-center space-x-2">
            <Select value={filter} onValueChange={(value: "all" | "high" | "medium" | "low") => setFilter(value)}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Filter" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All</SelectItem>
                <SelectItem value="high">High</SelectItem>
                <SelectItem value="medium">Medium</SelectItem>
                <SelectItem value="low">Low</SelectItem>
              </SelectContent>
            </Select>
            <Select value={sortBy} onValueChange={(value: "latest" | "importance") => setSortBy(value)}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Sort by" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="latest">Latest</SelectItem>
                <SelectItem value="importance">Importance</SelectItem>
              </SelectContent>
            </Select>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button variant="outline" size="icon" onClick={fetchNews}>
                    <RefreshCcw className="h-4 w-4" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Refresh news</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px]">
          <div className="space-y-4">
            {filteredNews.map((item) => (
              <Card key={item.id} className="p-4">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      {getSentimentIcon(item.sentiment)}
                      <h3 className="font-semibold">{item.title}</h3>
                    </div>
                    <p className="text-sm text-muted-foreground mb-2">{item.summary}</p>
                    <div className="flex flex-wrap gap-2 mb-2">
                      {item.tickers.map((ticker) => (
                        <Badge key={ticker} variant="outline">
                          ${ticker}
                        </Badge>
                      ))}
                      <Badge
                        variant={
                          item.importance === "high"
                            ? "destructive"
                            : item.importance === "medium"
                              ? "secondary"
                              : "outline"
                        }
                      >
                        {item.importance === "high" && <AlertTriangle className="h-3 w-3 mr-1" />}
                        {item.importance.toUpperCase()}
                      </Badge>
                    </div>
                    {expandedItem === item.id && item.aiSummary && (
                      <div className="mt-2 p-2 bg-muted rounded-md">
                        <p className="text-sm">{item.aiSummary}</p>
                      </div>
                    )}
                    <div className="flex items-center justify-between mt-2">
                      <span className="text-xs text-muted-foreground">
                        {item.source} • {item.timestamp.toLocaleTimeString()}
                      </span>
                      {item.aiSummary && (
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => setExpandedItem(expandedItem === item.id ? null : item.id)}
                        >
                          {expandedItem === item.id ? (
                            <>
                              Less <ChevronUp className="ml-1 h-4 w-4" />
                            </>
                          ) : (
                            <>
                              AI Analysis <ChevronDown className="ml-1 h-4 w-4" />
                            </>
                          )}
                        </Button>
                      )}
                    </div>
                  </div>
                </div>
              </Card>
            ))}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/generative-news-updates.tsx">
"use client"
import { useState, useEffect } from "react"
import { useCompletion } from "ai/react"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { ArrowUpRight, ArrowDownRight, TrendingUp } from "lucide-react"
interface NewsUpdate {
  id: string
  content: string
  timestamp: Date
}
interface GenerativeNewsUpdatesProps {
  updateInterval?: number
}
export function GenerativeNewsUpdates({ updateInterval = 30000 }: GenerativeNewsUpdatesProps) {
  const [newsUpdates, setNewsUpdates] = useState<NewsUpdate[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const { complete } = useCompletion({
    api: "/api/generate-news",
  })
  useEffect(() => {
    const fetchUpdates = async () => {
      try {
        setIsLoading(true)
        const update = await complete("Generate a brief market update")
        if (update) {
          setNewsUpdates((prevUpdates) => [
            { id: Date.now().toString(), content: update, timestamp: new Date() },
            ...prevUpdates.slice(0, 9), // Keep only the 10 most recent updates
          ])
        }
      } catch (error) {
        console.error("Failed to fetch market updates:", error)
      } finally {
        setIsLoading(false)
      }
    }
    // Initial fetch
    fetchUpdates()
    // Set up interval for updates
    const interval = setInterval(fetchUpdates, updateInterval)
    return () => clearInterval(interval)
  }, [complete, updateInterval])
  const getMessageIcon = (content: string) => {
    if (content.toLowerCase().includes("up") || content.toLowerCase().includes("gain")) {
      return <ArrowUpRight className="h-4 w-4 text-green-500" />
    }
    if (content.toLowerCase().includes("down") || content.toLowerCase().includes("loss")) {
      return <ArrowDownRight className="h-4 w-4 text-red-500" />
    }
    return <TrendingUp className="h-4 w-4 text-blue-500" />
  }
  return (
    <ScrollArea className="h-[200px]">
      <div className="space-y-2">
        {newsUpdates.map((update) => (
          <div
            key={update.id}
            className="flex items-center space-x-2 p-2 rounded-md hover:bg-muted/50 transition-colors"
          >
            {getMessageIcon(update.content)}
            <div className="flex-1">
              <p className="text-sm">{update.content}</p>
              <p className="text-xs text-muted-foreground">
                {update.timestamp.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
              </p>
            </div>
            <Badge variant="outline" className="bg-blue-500/10 text-blue-500">
              AI Generated
            </Badge>
          </div>
        ))}
        {isLoading && (
          <div className="flex items-center justify-center p-4">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
          </div>
        )}
      </div>
    </ScrollArea>
  )
}
</file>

<file path="components/generative-trading-ideas.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { ArrowUpRight, ArrowDownRight, RefreshCw, Target, Shield } from "lucide-react"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Slider } from "@/components/ui/slider"
import { useCompletion } from "ai/react"
import { Progress } from "@/components/ui/progress"
interface TradingIdea {
  id: string
  ticker: string
  type: "long" | "short"
  entry: number
  target: number
  stopLoss: number
  timeframe: string
  confidence: number
  reasoning: string
  signals: {
    technical: number
    sentiment: number
    fundamental: number
  }
  riskLevel: "low" | "medium" | "high"
  expectedReturn: number
  timestamp: Date
}
const fixedIdeas: TradingIdea[] = [
  {
    id: "1",
    ticker: "AAPL",
    type: "long",
    entry: 150,
    target: 165,
    stopLoss: 145,
    timeframe: "2 weeks",
    confidence: 75,
    reasoning: "Strong technical setup with bullish divergence on RSI",
    signals: {
      technical: 80,
      sentiment: 65,
      fundamental: 70,
    },
    riskLevel: "medium",
    expectedReturn: 10,
    timestamp: new Date(),
  },
  {
    id: "2",
    ticker: "TSLA",
    type: "short",
    entry: 800,
    target: 750,
    stopLoss: 820,
    timeframe: "1 week",
    confidence: 65,
    reasoning: "Bearish trend continuation after breaking key support",
    signals: {
      technical: 75,
      sentiment: 60,
      fundamental: 55,
    },
    riskLevel: "high",
    expectedReturn: 6.25,
    timestamp: new Date(Date.now() - 1000 * 60 * 60), // 1 hour ago
  },
]
export function GenerativeTradingIdeas() {
  const [ideas, setIdeas] = useState<TradingIdea[]>(fixedIdeas)
  const [loading, setLoading] = useState(false)
  const [isGenerating, setIsGenerating] = useState(false)
  const [filter, setFilter] = useState<"all" | "long" | "short">("all")
  const [confidenceThreshold, setConfidenceThreshold] = useState(60)
  const [error, setError] = useState<string | null>(null)
  const { complete } = useCompletion({
    api: "/api/generate-trades",
  })
  const generateIdea = useCallback(async (): Promise<TradingIdea | null> => {
    try {
      const response = await complete("Generate a new trading idea")
      if (response) {
        const newIdea: TradingIdea = JSON.parse(response)
        return newIdea
      }
      return null
    } catch (error: any) {
      console.error("Error generating idea:", error)
      setError("Failed to generate a trading idea. Please try again.")
      return null
    }
  }, [complete])
  const generateNewIdeas = useCallback(async () => {
    setIsGenerating(true)
    setError(null)
    try {
      const newIdea = await generateIdea()
      if (newIdea) {
        setIdeas((prevIdeas) => [newIdea, ...prevIdeas.slice(0, 4)])
      } else {
        setError("Failed to generate a new trading idea. Please try again.")
      }
    } catch (error) {
      console.error("Error generating trading ideas:", error)
      setError("Failed to generate trading ideas. Please try again later.")
    } finally {
      setIsGenerating(false)
    }
  }, [generateIdea])
  useEffect(() => {
    const interval = setInterval(generateNewIdeas, 60000) // Generate a new idea every minute
    return () => clearInterval(interval)
  }, [generateNewIdeas])
  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 80) return "text-green-500"
    if (confidence >= 60) return "text-yellow-500"
    return "text-red-500"
  }
  const getRiskBadge = (risk: string) => {
    switch (risk) {
      case "low":
        return (
          <Badge variant="outline" className="bg-green-500/10 text-green-500">
            Low Risk
          </Badge>
        )
      case "medium":
        return (
          <Badge variant="outline" className="bg-yellow-500/10 text-yellow-500">
            Medium Risk
          </Badge>
        )
      case "high":
        return (
          <Badge variant="outline" className="bg-red-500/10 text-red-500">
            High Risk
          </Badge>
        )
      default:
        return null
    }
  }
  const filteredIdeas = ideas.filter(
    (idea) => (filter === "all" || idea.type === filter) && idea.confidence >= confidenceThreshold,
  )
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>AI Trade Suggestions</CardTitle>
            <p className="text-sm text-muted-foreground">Generated trading opportunities based on market analysis</p>
          </div>
          <div className="flex items-center space-x-2">
            <Select value={filter} onValueChange={(value: "all" | "long" | "short") => setFilter(value)}>
              <SelectTrigger className="w-[100px]">
                <SelectValue placeholder="Filter" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All</SelectItem>
                <SelectItem value="long">Long</SelectItem>
                <SelectItem value="short">Short</SelectItem>
              </SelectContent>
            </Select>
            <Button onClick={generateNewIdeas} disabled={isGenerating}>
              {isGenerating ? (
                <RefreshCw className="h-4 w-4 animate-spin mr-2" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Refresh
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="mb-4">
          <label className="text-sm font-medium">Confidence Threshold: {confidenceThreshold}%</label>
          <Slider
            value={[confidenceThreshold]}
            onValueChange={(value) => setConfidenceThreshold(value[0])}
            min={0}
            max={100}
            step={1}
          />
        </div>
        {error && <div className="mb-4 p-2 bg-red-100 border border-red-400 text-red-700 rounded">{error}</div>}
        <ScrollArea className="h-[600px]">
          <div className="space-y-4">
            {filteredIdeas.map((idea) => (
              <Card key={idea.id} className="p-4">
                <div className="flex items-start justify-between mb-4">
                  <div className="flex items-center space-x-2">
                    {idea.type === "long" ? (
                      <ArrowUpRight className="h-5 w-5 text-green-500" />
                    ) : (
                      <ArrowDownRight className="h-5 w-5 text-red-500" />
                    )}
                    <div>
                      <h3 className="font-semibold text-lg">${idea.ticker}</h3>
                      <p className="text-sm text-muted-foreground">
                        {idea.type.toUpperCase()} • {idea.timeframe}
                      </p>
                    </div>
                  </div>
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger>
                        <Badge variant="outline" className={`${getConfidenceColor(idea.confidence)}`}>
                          {idea.confidence}% Confidence
                        </Badge>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>AI-generated confidence score based on multiple factors</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </div>
                <div className="grid grid-cols-3 gap-4 mb-4">
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <Target className="h-4 w-4" />
                      <span className="text-sm text-muted-foreground">Entry</span>
                    </div>
                    <p className="font-semibold">${idea.entry}</p>
                  </div>
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <ArrowUpRight className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-muted-foreground">Target</span>
                    </div>
                    <p className="font-semibold text-green-500">${idea.target}</p>
                  </div>
                  <div>
                    <div className="flex items-center space-x-2 mb-1">
                      <Shield className="h-4 w-4 text-red-500" />
                      <span className="text-sm text-muted-foreground">Stop Loss</span>
                    </div>
                    <p className="font-semibold text-red-500">${idea.stopLoss}</p>
                  </div>
                </div>
                <div className="space-y-2 mb-4">
                  <p className="text-sm">{idea.reasoning}</p>
                </div>
                <div className="space-y-3">
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Technical Analysis</span>
                      <span className="text-sm font-medium">{idea.signals.technical}%</span>
                    </div>
                    <Progress value={idea.signals.technical} className="h-2" />
                  </div>
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Sentiment Analysis</span>
                      <span className="text-sm font-medium">{idea.signals.sentiment}%</span>
                    </div>
                    <Progress value={idea.signals.sentiment} className="h-2" />
                  </div>
                  <div>
                    <div className="flex justify-between mb-1">
                      <span className="text-sm text-muted-foreground">Fundamental Analysis</span>
                      <span className="text-sm font-medium">{idea.signals.fundamental}%</span>
                    </div>
                    <Progress value={idea.signals.fundamental} className="h-2" />
                  </div>
                </div>
                <div className="flex justify-between items-center mt-4 pt-4 border-t">
                  <div className="flex items-center space-x-2">
                    {getRiskBadge(idea.riskLevel)}
                    <Badge variant="outline" className="bg-blue-500/10 text-blue-500">
                      {idea.expectedReturn}% Expected Return
                    </Badge>
                  </div>
                  <span className="text-xs text-muted-foreground">Generated {idea.timestamp.toLocaleTimeString()}</span>
                </div>
              </Card>
            ))}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/guided-tour.tsx">
"use client"
import { useState } from "react"
import Joyride, { type Step } from "react-joyride"
const steps: Step[] = [
  {
    target: ".settings-button",
    content: "Click here to open the settings panel and customize your dashboard.",
  },
  {
    target: ".theme-toggle",
    content: "Toggle between light and dark mode for your preferred viewing experience.",
  },
  {
    target: ".widget-list",
    content: "Drag and drop widgets to reorder them on your dashboard.",
  },
  // Add more steps as needed
]
export function GuidedTour() {
  const [run, setRun] = useState(true)
  return (
    <Joyride
      steps={steps}
      run={run}
      continuous
      showSkipButton
      styles={{
        options: {
          primaryColor: "#4338ca",
        },
      }}
      callback={(data) => {
        const { status } = data
        if (["finished", "skipped"].includes(status)) {
          setRun(false)
        }
      }}
    />
  )
}
</file>

<file path="components/intrinsic-value-card.tsx">
"use client"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Info } from "lucide-react"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
interface IntrinsicValueData {
  symbol: string
  intrinsicValue: number
  currentPrice: number
  dcfValue?: number
  relativeValue?: number
  overvaluation: number
}
interface IntrinsicValueCardProps {
  data: IntrinsicValueData
  expanded?: boolean
}
export function IntrinsicValueCard({ data, expanded = false }: IntrinsicValueCardProps) {
  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(value)
  }
  return (
    <Card className="relative overflow-hidden">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-xl font-bold">{data.symbol} Intrinsic Value</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex items-baseline space-x-2">
            <span className="text-4xl font-bold text-primary">
              {formatCurrency(data.intrinsicValue).replace("$", "")}
            </span>
            <span className="text-xl text-muted-foreground">USD</span>
          </div>
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Intrinsic Value</span>
              <Badge variant="destructive" className="bg-red-500/10 text-red-500">
                OVERVALUATION {data.overvaluation}%
              </Badge>
            </div>
            <Progress value={70} className="h-2" />
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Current Price</span>
              <span className="text-sm text-muted-foreground">{formatCurrency(data.currentPrice)}</span>
            </div>
          </div>
          {expanded && data.dcfValue && data.relativeValue && (
            <div className="mt-6 space-y-4 pt-4 border-t">
              <div className="grid grid-cols-2 gap-4">
                <Card>
                  <CardContent className="pt-4">
                    <div className="text-center">
                      <div className="text-sm font-medium text-muted-foreground mb-1">DCF Value</div>
                      <div className="text-2xl font-bold text-blue-500">{formatCurrency(data.dcfValue)}</div>
                    </div>
                  </CardContent>
                </Card>
                <Card>
                  <CardContent className="pt-4">
                    <div className="text-center">
                      <div className="text-sm font-medium text-muted-foreground mb-1">Relative Value</div>
                      <div className="text-2xl font-bold text-teal-500">{formatCurrency(data.relativeValue)}</div>
                    </div>
                  </CardContent>
                </Card>
              </div>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="flex items-center justify-center text-sm text-muted-foreground">
                      <Info className="h-4 w-4 mr-1" />
                      How is this calculated?
                    </div>
                  </TooltipTrigger>
                  <TooltipContent className="max-w-[300px]">
                    <p>
                      Intrinsic value is calculated using both DCF (Discounted Cash Flow) and Relative valuation
                      methods. The final value is a weighted average of these two approaches.
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/intrinsic-value-dashboard.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { IntrinsicValueCard } from "@/components/intrinsic-value-card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Search } from "lucide-react"
interface StockValuation {
  symbol: string
  intrinsicValue: number
  currentPrice: number
  dcfValue: number
  relativeValue: number
  overvaluation: number
}
const mockValuations: StockValuation[] = [
  {
    symbol: "AAPL",
    intrinsicValue: 164.29,
    currentPrice: 213.58,
    dcfValue: 126.91,
    relativeValue: 201.66,
    overvaluation: 30,
  },
  {
    symbol: "GOOGL",
    intrinsicValue: 163.94,
    currentPrice: 186.89,
    dcfValue: 145.32,
    relativeValue: 182.56,
    overvaluation: 14,
  },
  {
    symbol: "MSFT",
    intrinsicValue: 333.54,
    currentPrice: 400.25,
    dcfValue: 312.45,
    relativeValue: 354.63,
    overvaluation: 20,
  },
]
export function IntrinsicValueDashboard() {
  const [valuations, setValuations] = useState<StockValuation[]>(mockValuations)
  const [searchTerm, setSearchTerm] = useState("")
  const [sortBy, setSortBy] = useState("overvaluation")
  const filteredAndSortedValuations = valuations
    .filter((val) => val.symbol.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => {
      switch (sortBy) {
        case "overvaluation":
          return b.overvaluation - a.overvaluation
        case "value":
          return b.intrinsicValue - a.intrinsicValue
        case "symbol":
          return a.symbol.localeCompare(b.symbol)
        default:
          return 0
      }
    })
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Intrinsic Value Analysis</CardTitle>
            <CardDescription>Compare stock prices to their intrinsic values</CardDescription>
          </div>
          <div className="flex items-center space-x-2">
            <div className="relative">
              <Search className="absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input
                placeholder="Search symbol..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-8 w-[150px]"
              />
            </div>
            <Select value={sortBy} onValueChange={setSortBy}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Sort by" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="overvaluation">Overvaluation</SelectItem>
                <SelectItem value="value">Intrinsic Value</SelectItem>
                <SelectItem value="symbol">Symbol</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {filteredAndSortedValuations.map((valuation) => (
            <IntrinsicValueCard
              key={valuation.symbol}
              data={valuation}
              expanded={filteredAndSortedValuations.length === 1}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/live-market-data.tsx">
"use client"
import { useState, useEffect, useCallback, useMemo } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Input } from "@/components/ui/input"
import { ArrowUpRight, ArrowDownRight, Search, Loader2 } from "lucide-react"
import { ErrorMessage } from "@/components/error-message"
interface MarketData {
  symbol: string
  price: number
  change: number
  volume: number
  marketCap: number
}
const generateMockData = (): MarketData[] => {
  const symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "FB", "TSLA", "NVDA", "JPM", "V", "JNJ"]
  return symbols.map((symbol) => ({
    symbol,
    price: Number((Math.random() * 1000 + 50).toFixed(2)),
    change: Number((Math.random() * 10 - 5).toFixed(2)),
    volume: Math.floor(Math.random() * 10000000),
    marketCap: Number((Math.random() * 1000 + 100).toFixed(2)),
  }))
}
export function LiveMarketData() {
  const [data, setData] = useState<MarketData[]>([])
  const [searchTerm, setSearchTerm] = useState("")
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  // Load initial data
  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true)
        setError(null)
        // In a real app, this would be an API call
        await new Promise(resolve => setTimeout(resolve, 1000)) // Simulate network delay
        const mockData = generateMockData()
        setData(mockData)
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load market data")
      } finally {
        setIsLoading(false)
      }
    }
    loadData()
    // Simulate real-time updates
    const interval = setInterval(() => {
      setData(generateMockData())
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  const filteredData = useMemo(
    () => data.filter((item) => item.symbol.toLowerCase().includes(searchTerm.toLowerCase())),
    [data, searchTerm],
  )
  const renderBadge = useCallback(
    (change: number) => (
      <Badge variant={change >= 0 ? "default" : "destructive"} className="flex items-center justify-center gap-1">
        {change >= 0 ? <ArrowUpRight className="h-4 w-4" /> : <ArrowDownRight className="h-4 w-4" />}
        {Math.abs(change).toFixed(2)}%
      </Badge>
    ),
    [],
  )
  if (isLoading) {
    return (
      <Card className="h-full">
        <CardHeader>
          <CardTitle>Live Market Data</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[300px]">
          <Loader2 className="h-8 w-8 animate-spin" />
        </CardContent>
      </Card>
    )
  }
  if (error) {
    return (
      <Card className="h-full">
        <CardHeader>
          <CardTitle>Live Market Data</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[300px]">
          <ErrorMessage message={error} onRetry={() => setIsLoading(true)} />
        </CardContent>
      </Card>
    )
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Live Market Data</CardTitle>
            <p className="text-sm text-muted-foreground">Real-time stock prices and market information</p>
          </div>
          <div className="relative">
            <Search className="absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              placeholder="Search symbol..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-8 w-[200px]"
            />
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Symbol</TableHead>
                <TableHead className="text-right">Price</TableHead>
                <TableHead className="text-right">Change</TableHead>
                <TableHead className="text-right">Volume</TableHead>
                <TableHead className="text-right">Market Cap (B)</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredData.map((item) => (
                <TableRow key={item.symbol}>
                  <TableCell className="font-medium">{item.symbol}</TableCell>
                  <TableCell className="text-right">${item.price.toFixed(2)}</TableCell>
                  <TableCell className="text-right">{renderBadge(item.change)}</TableCell>
                  <TableCell className="text-right">{item.volume.toLocaleString()}</TableCell>
                  <TableCell className="text-right">${item.marketCap.toFixed(2)}B</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/live-ticker-bar.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { ArrowUpIcon, ArrowDownIcon } from "lucide-react"
import { Skeleton } from "@/components/ui/skeleton"
import { TickerConfigDialog, TickerConfig } from "./market-status-header/ticker-config-dialog"
import { useStockWebSocket } from "@/lib/hooks/use-stock-websocket"
import { useMarketData, useMarketDataFetcher } from "@/lib/hooks/use-market-data"
import { AggregateMessage } from "@/types/polygon"
interface LiveTickerBarProps {
  config?: TickerConfig
  onConfigUpdate: (config: TickerConfig) => void
  isLoading?: boolean
}
const DEFAULT_CONFIG: TickerConfig = {
  preset: 'trending',
  sector: undefined,
  customTickers: [],
  maxTickers: 20
}
const POLLING_INTERVAL = 30000 // 30 seconds
const calculateScrollSpeed = (itemCount: number, viewportWidth: number) => {
  const baseSpeed = 120 // seconds for one complete scroll
  const speedFactor = Math.max(1, itemCount / 4)
  const viewportFactor = Math.max(1, viewportWidth / 1920)
  return baseSpeed * speedFactor * viewportFactor
}
export function LiveTickerBar({ 
  config = DEFAULT_CONFIG, 
  onConfigUpdate, 
  isLoading = false 
}: LiveTickerBarProps) {
  const [configOpen, setConfigOpen] = useState(false)
  const [tickers, setTickers] = useState<string[]>([])
  const [expandedSymbol, setExpandedSymbol] = useState<string | null>(null)
  const [viewportWidth, setViewportWidth] = useState(0)
  const [mounted, setMounted] = useState(false)
  const [lastClickTime, setLastClickTime] = useState(0)
  const [isClientSide, setIsClientSide] = useState(false)
  const [wsError, setWsError] = useState<string | null>(null)
  const [wsStatus, setWsStatus] = useState<'disconnected' | 'connected' | 'authenticated'>('disconnected')
  const [retryCount, setRetryCount] = useState(0)
  // Use the centralized market data store
  const { data: marketData, isLoading: isDataLoading, error, updateData } = useMarketData(tickers)
  const { fetchData } = useMarketDataFetcher(tickers)
  // Handle client-side mounting
  useEffect(() => {
    setMounted(true)
    setIsClientSide(true)
  }, [])
  // Handle viewport width updates
  useEffect(() => {
    const updateViewportWidth = () => {
      setViewportWidth(window.innerWidth)
    }
    if (isClientSide) {
      window.addEventListener('resize', updateViewportWidth)
      updateViewportWidth()
      return () => window.removeEventListener('resize', updateViewportWidth)
    }
  }, [isClientSide])
  // Fetch tickers based on config
  useEffect(() => {
    if (!config.preset || isLoading || !isClientSide) return;
    const fetchTickers = async () => {
      try {
        let tickersUrl = `/api/stock/tickers/${config.preset}`;
        if (config.preset === 'sector' && config.sector) {
          tickersUrl += `?sector=${encodeURIComponent(config.sector)}`;
        }
        if (config.preset === 'custom' && config.customTickers.length > 0) {
          tickersUrl = `/api/stock/tickers/custom?symbols=${encodeURIComponent(config.customTickers.join(','))}`;
        }
        const response = await fetch(tickersUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch tickers: ${response.status}`);
        }
        const data = await response.json();
        if (!data.tickers || data.tickers.length === 0) {
          throw new Error('No tickers available for the selected configuration');
        }
        const filteredTickers = data.tickers
          .filter((ticker: string) => ticker && ticker.trim())
          .slice(0, config.maxTickers || 20);
        if (filteredTickers.length === 0) {
          throw new Error('No valid tickers found');
        }
        setTickers(filteredTickers);
        // Immediately fetch initial market data
        fetchData(filteredTickers);
      } catch (error) {
        console.error('Error fetching tickers:', error);
        setWsError(error instanceof Error ? error.message : 'Failed to fetch tickers');
      }
    };
    fetchTickers();
  }, [config, isLoading, isClientSide, fetchData]);
  // Set up polling for market data
  useEffect(() => {
    if (isLoading || !tickers.length || !isClientSide) return
    fetchData()
    const pollInterval = setInterval(fetchData, POLLING_INTERVAL)
    return () => clearInterval(pollInterval)
  }, [tickers, isLoading, fetchData, isClientSide])
  // Handle WebSocket updates
  const handleAggregateUpdate = useCallback((agg: AggregateMessage) => {
    if (!marketData[agg.sym]) return
    const updatedData = {
      symbol: agg.sym,
      price: agg.c,
      change: agg.c - agg.o,
      changePercent: ((agg.c - agg.o) / agg.o) * 100,
      volume: marketData[agg.sym].volume,
      lastUpdated: Date.now(),
    }
    updateData(agg.sym, updatedData)
  }, [marketData, updateData])
  // Handle WebSocket status changes
  const handleStatusChange = useCallback((status: string) => {
    setWsStatus(status as 'disconnected' | 'connected' | 'authenticated')
    if (status === 'authenticated') {
      setWsError(null)
      setRetryCount(0)
    }
  }, [])
  // Handle WebSocket errors with retry logic
  const handleWsError = useCallback((error: Error) => {
    console.error('WebSocket error:', error)
    setWsError(error.message)
    if (retryCount < 3) {
      const retryDelay = Math.pow(2, retryCount) * 1000
      setTimeout(() => {
        setRetryCount(prev => prev + 1)
        setWsError(null)
      }, retryDelay)
    }
  }, [retryCount])
  // Set up WebSocket connection
  const { isConnected } = useStockWebSocket({
    symbols: tickers,
    onAggregate: handleAggregateUpdate,
    onError: handleWsError,
    onStatusChange: handleStatusChange
  })
  // Handle ticker click
  const handleTickerClick = useCallback((symbol: string, event: React.MouseEvent) => {
    const currentTime = Date.now()
    if (currentTime - lastClickTime < 300) {
      // Double click detected
      event.preventDefault()
      setExpandedSymbol(null)
      setConfigOpen(true)
    } else {
      // Single click
      setExpandedSymbol(expandedSymbol === symbol ? null : symbol)
    }
    setLastClickTime(currentTime)
  }, [lastClickTime, expandedSymbol])
  // Show loading state before client-side mount
  if (!mounted || !isClientSide) {
    return (
      <div className="flex space-x-4 h-8 bg-muted/30 items-center px-4">
        {[...Array(8)].map((_, index) => (
          <div key={index} className="flex items-center space-x-2">
            <Skeleton className="h-3 w-16 animate-pulse rounded-md bg-muted" />
          </div>
        ))}
      </div>
    );
  }
  // Show loading state while fetching initial data
  if (isLoading || isDataLoading || !tickers.length) {
    return (
      <div className="flex space-x-4 h-8 bg-muted/30 items-center px-4">
        <span className="text-sm text-muted-foreground">Loading market data...</span>
        <div className="animate-pulse h-2 w-2 rounded-full bg-yellow-500" />
      </div>
    );
  }
  // Show error state with retry button
  if (error || wsError) {
    return (
      <div className="bg-muted/30 p-2 text-sm text-red-500 flex justify-between items-center">
        <div className="flex items-center space-x-2">
          <span>{error || wsError}</span>
          {wsStatus !== 'authenticated' && (
            <span className="text-xs text-muted-foreground">
              WebSocket: {wsStatus}
            </span>
          )}
        </div>
        <button 
          onClick={() => {
            setWsError(null);
            setRetryCount(0);
            fetchData(tickers);
          }} 
          className="text-xs underline hover:no-underline"
        >
          Retry {retryCount > 0 ? `(${retryCount}/3)` : ''}
        </button>
      </div>
    );
  }
  // Show connection status when not authenticated
  if (wsStatus !== 'authenticated') {
    return (
      <div className="bg-muted/30 p-2 text-sm flex justify-between items-center">
        <span className="text-muted-foreground">
          Connecting to market data... ({wsStatus})
        </span>
        <div className="animate-pulse h-2 w-2 rounded-full bg-yellow-500" />
      </div>
    )
  }
  // Prepare ticker data for display
  const tickerDataArray = Object.values(marketData).filter(Boolean)
  const repeatedData = [...tickerDataArray, ...tickerDataArray, ...tickerDataArray]
  return (
    <>
      <div className="relative">
        <div 
          className="h-8 bg-muted/30 cursor-pointer relative overflow-hidden" 
        >
          <div className="ticker">
            <div 
              className="ticker-track"
              style={{ 
                '--scroll-speed': `${calculateScrollSpeed(tickerDataArray.length, viewportWidth)}s`
              } as React.CSSProperties}
            >
              {repeatedData.map((item, index) => (
                <div 
                  key={`${item.symbol}-${index}`} 
                  className={`ticker-item ${expandedSymbol === item.symbol ? 'active' : ''}`}
                  onClick={(e) => handleTickerClick(item.symbol, e)}
                >
                  <span className="font-medium">{item.symbol}</span>
                  <span className="ml-2">${item.price?.toFixed(2) ?? 'N/A'}</span>
                  <span 
                    className={`ml-2 flex items-center ${
                      item.changePercent >= 0 ? "text-green-500" : "text-red-500"
                    }`}
                  >
                    {item.changePercent >= 0 ? (
                      <ArrowUpIcon className="w-3 h-3 mr-1" />
                    ) : (
                      <ArrowDownIcon className="w-3 h-3 mr-1" />
                    )}
                    {Math.abs(item.changePercent).toFixed(2)}%
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>
        {expandedSymbol && marketData[expandedSymbol] && (
          <div className="absolute top-full left-0 w-full z-50 bg-background/95 backdrop-blur-sm border rounded-b-lg shadow-lg p-4">
            <div className="flex justify-between items-start">
              <div>
                <h3 className="font-semibold">
                  {expandedSymbol}
                </h3>
                <p className="text-sm text-muted-foreground">
                  Last updated: {new Date(marketData[expandedSymbol].lastUpdated).toLocaleTimeString()}
                </p>
              </div>
              <div className="text-right">
                <p className="text-lg font-bold">${marketData[expandedSymbol].price.toFixed(2)}</p>
                <p className={`text-sm ${marketData[expandedSymbol].changePercent >= 0 ? "text-green-500" : "text-red-500"}`}>
                  {marketData[expandedSymbol].changePercent >= 0 ? "+" : ""}
                  {marketData[expandedSymbol].changePercent.toFixed(2)}%
                </p>
              </div>
            </div>
          </div>
        )}
      </div>
      <TickerConfigDialog
        open={configOpen}
        onOpenChange={setConfigOpen}
        currentConfig={config}
        onSave={onConfigUpdate}
      />
    </>
  )
}
</file>

<file path="components/LiveStockNews.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Loader2 } from "lucide-react"
interface NewsItem {
  id: string
  headline: string
  summary: string
  source: string
  publishedAt: string
}
const mockNews: NewsItem[] = [
  {
    id: "1",
    headline: "Tech Stocks Surge as AI Adoption Accelerates",
    summary:
      "Major tech companies see significant gains as artificial intelligence integration boosts investor confidence.",
    source: "TechWire",
    publishedAt: "2023-06-15T10:30:00Z",
  },
  {
    id: "2",
    headline: "Oil Prices Stabilize Amid Global Supply Concerns",
    summary: "Crude oil markets show resilience as geopolitical tensions ease and production levels normalize.",
    source: "EnergyInsider",
    publishedAt: "2023-06-15T11:15:00Z",
  },
  {
    id: "3",
    headline: "Federal Reserve Hints at Potential Rate Hike",
    summary: "Central bank officials suggest a possible increase in interest rates to combat inflation pressures.",
    source: "EconomyWatch",
    publishedAt: "2023-06-15T12:00:00Z",
  },
]
function LiveStockNews() {
  const [news, setNews] = useState<NewsItem[]>(mockNews)
  const [isLoading, setIsLoading] = useState(false)
  useEffect(() => {
    const fetchNews = () => {
      setIsLoading(true)
      // Simulate API call
      setTimeout(() => {
        const newItem: NewsItem = {
          id: Date.now().toString(),
          headline: `Breaking: ${["AAPL", "GOOGL", "AMZN", "MSFT"][Math.floor(Math.random() * 4)]} Announces Quarterly Earnings`,
          summary: "The company's financial results exceed market expectations, driving stock price movements.",
          source: "MarketBeat",
          publishedAt: new Date().toISOString(),
        }
        setNews((prevNews) => [newItem, ...prevNews.slice(0, 4)])
        setIsLoading(false)
      }, 1500)
    }
    const interval = setInterval(fetchNews, 15000) // Fetch every 15 seconds
    return () => clearInterval(interval)
  }, [])
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          Live Stock News
          {isLoading && <Loader2 className="h-4 w-4 animate-spin" />}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px] pr-4">
          {news.map((item) => (
            <Card key={item.id} className="mb-4">
              <CardContent className="p-4">
                <h3 className="font-semibold mb-2">{item.headline}</h3>
                <p className="text-sm text-muted-foreground mb-2">{item.summary}</p>
                <div className="flex justify-between items-center">
                  <Badge variant="secondary">{item.source}</Badge>
                  <span className="text-xs text-muted-foreground">
                    {new Date(item.publishedAt).toLocaleTimeString()}
                  </span>
                </div>
              </CardContent>
            </Card>
          ))}
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
export default LiveStockNews
</file>

<file path="components/market-breadth.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, PieChart, Pie, Cell, Tooltip, Legend } from "recharts"
import { Badge } from "@/components/ui/badge"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
interface MarketBreadthData {
  advancing: number
  declining: number
  unchanged: number
}
interface IndexData {
  name: string
  data: MarketBreadthData
}
const generateMockData = (): IndexData[] => {
  return [
    {
      name: "S&P 500",
      data: {
        advancing: Math.floor(Math.random() * 300) + 200,
        declining: Math.floor(Math.random() * 200) + 100,
        unchanged: Math.floor(Math.random() * 50),
      },
    },
    {
      name: "NASDAQ",
      data: {
        advancing: Math.floor(Math.random() * 1500) + 1000,
        declining: Math.floor(Math.random() * 1000) + 500,
        unchanged: Math.floor(Math.random() * 200),
      },
    },
    {
      name: "NYSE",
      data: {
        advancing: Math.floor(Math.random() * 1000) + 700,
        declining: Math.floor(Math.random() * 700) + 300,
        unchanged: Math.floor(Math.random() * 100),
      },
    },
  ]
}
const COLORS = ["#4ade80", "#f87171", "#fbbf24"]
export function MarketBreadth() {
  const [data, setData] = useState<IndexData[]>(generateMockData())
  const [selectedIndex, setSelectedIndex] = useState<string>("S&P 500")
  useEffect(() => {
    const interval = setInterval(() => {
      setData(generateMockData())
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  const selectedData = data.find((item) => item.name === selectedIndex)?.data || data[0].data
  const pieData = [
    { name: "Advancing", value: selectedData.advancing },
    { name: "Declining", value: selectedData.declining },
    { name: "Unchanged", value: selectedData.unchanged },
  ]
  const totalIssues = selectedData.advancing + selectedData.declining + selectedData.unchanged
  const advanceDeclineRatio = (selectedData.advancing / selectedData.declining).toFixed(2)
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Market Breadth</CardTitle>
            <CardDescription>Overview of market-wide trends</CardDescription>
          </div>
          <Select value={selectedIndex} onValueChange={setSelectedIndex}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Select index" />
            </SelectTrigger>
            <SelectContent>
              {data.map((item) => (
                <SelectItem key={item.name} value={item.name}>
                  {item.name}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        <div className="flex justify-between items-center mb-4">
          <div>
            <p className="text-2xl font-bold">{totalIssues}</p>
            <p className="text-sm text-muted-foreground">Total Issues</p>
          </div>
          <Badge variant="outline" className="text-lg">
            A/D Ratio: {advanceDeclineRatio}
          </Badge>
        </div>
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie
              data={pieData}
              cx="50%"
              cy="50%"
              labelLine={false}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
            >
              {pieData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
        <div className="mt-4 space-y-2">
          <div className="flex justify-between items-center">
            <span className="font-medium">Advancing</span>
            <Badge variant="outline" className="bg-green-500/10 text-green-500">
              {selectedData.advancing}
            </Badge>
          </div>
          <div className="flex justify-between items-center">
            <span className="font-medium">Declining</span>
            <Badge variant="outline" className="bg-red-500/10 text-red-500">
              {selectedData.declining}
            </Badge>
          </div>
          <div className="flex justify-between items-center">
            <span className="font-medium">Unchanged</span>
            <Badge variant="outline" className="bg-yellow-500/10 text-yellow-500">
              {selectedData.unchanged}
            </Badge>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/market-overview-chart.tsx">
"use client"
import { XAxis, YAxis, Tooltip, ResponsiveContainer, LineChart, Line, Legend } from "recharts"
interface ChartData {
  time: string
  SP500: number
  NASDAQ: number
  DOW: number
}
interface ChartProps {
  data: ChartData[]
}
export default function MarketOverviewChart({ data }: ChartProps) {
  return (
    <ResponsiveContainer width="100%" height="100%">
      <LineChart data={data}>
        <XAxis dataKey="time" fontSize={10} />
        <YAxis fontSize={10} />
        <Tooltip />
        <Legend iconSize={8} iconType="circle" />
        <Line type="monotone" dataKey="SP500" stroke="#8884d8" dot={false} />
        <Line type="monotone" dataKey="NASDAQ" stroke="#82ca9d" dot={false} />
        <Line type="monotone" dataKey="DOW" stroke="#ffc658" dot={false} />
      </LineChart>
    </ResponsiveContainer>
  )
}
</file>

<file path="components/market-overview.tsx">
"use client"
import { Badge } from "@/components/ui/badge"
import { Card, CardContent } from "@/components/ui/card"
import dynamic from "next/dynamic"
import { ScrollArea } from "@/components/ui/scroll-area"
import { PolygonTickerWall } from "./polygon-ticker-wall"
const Chart = dynamic(() => import("./market-overview-chart"), { ssr: false })
interface IndexData {
  name: string
  value: number
  change: number
}
// Static chart data with fixed points
const chartData = [
  { time: "9:30", SP500: 4150, NASDAQ: 12800, DOW: 33800 },
  { time: "10:00", SP500: 4165, NASDAQ: 12850, DOW: 33850 },
  { time: "10:30", SP500: 4180, NASDAQ: 12900, DOW: 33900 },
  { time: "11:00", SP500: 4175, NASDAQ: 12880, DOW: 33880 },
  { time: "11:30", SP500: 4185, NASDAQ: 12920, DOW: 33920 },
  { time: "12:00", SP500: 4190, NASDAQ: 12950, DOW: 33950 },
  { time: "12:30", SP500: 4188, NASDAQ: 12940, DOW: 33940 },
  { time: "13:00", SP500: 4192, NASDAQ: 12960, DOW: 33960 },
  { time: "13:30", SP500: 4185, NASDAQ: 12930, DOW: 33930 },
  { time: "14:00", SP500: 4186, NASDAQ: 12935, DOW: 33935 },
]
const mockIndices: IndexData[] = [
  { name: "S&P 500", value: 4185.81, change: 0.45 },
  { name: "NASDAQ", value: 12888.28, change: 0.73 },
  { name: "DOW", value: 33875.4, change: -0.23 },
  { name: "VIX", value: 15.65, change: -5.21 },
]
const mockNews = [
  {
    id: 1,
    title: "Fed Signals Potential Rate Changes",
    time: "14:30",
    impact: "high",
  },
  {
    id: 2,
    title: "Tech Sector Leads Market Rally",
    time: "13:45",
    impact: "medium",
  },
  {
    id: 3,
    title: "Oil Prices Stabilize After Recent Drop",
    time: "13:15",
    impact: "medium",
  },
]
export function MarketOverview() {
  return (
    <div className="grid grid-cols-12 gap-2 h-full">
      <Card className="col-span-12">
        <CardContent className="py-2">
          <div className="grid grid-cols-4 gap-2">
            {mockIndices.map((index) => (
              <div key={index.name} className="text-center">
                <div className="text-xs font-medium">{index.name}</div>
                <div className="text-sm font-bold">{index.value.toFixed(2)}</div>
                <Badge variant={index.change >= 0 ? "default" : "destructive"} className="text-xs">
                  {index.change > 0 ? "+" : ""}
                  {index.change.toFixed(2)}%
                </Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
      <Card className="col-span-6">
        <CardContent className="p-2">
          <div className="h-[100px]">
            <Chart data={chartData} />
          </div>
        </CardContent>
      </Card>
      <Card className="col-span-6">
        <CardContent className="p-2">
          <ScrollArea className="h-[100px]">
            <div className="space-y-1">
              {mockNews.map((item) => (
                <div key={item.id} className="flex justify-between items-center">
                  <div className="flex-1">
                    <p className="text-xs truncate">{item.title}</p>
                    <p className="text-[10px] text-muted-foreground">{item.time}</p>
                  </div>
                  <Badge variant={item.impact === "high" ? "destructive" : "secondary"} className="text-[10px]">
                    {item.impact}
                  </Badge>
                </div>
              ))}
            </div>
          </ScrollArea>
        </CardContent>
      </Card>
      <Card className="col-span-12">
        <CardContent>
          <PolygonTickerWall />
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="components/market-status-header.tsx">
"use client"
import { useState, useEffect } from "react"
import { Badge } from "@/components/ui/badge"
import { Card } from "@/components/ui/card"
import { Globe2, Moon, Clock, Sun } from "lucide-react"
import { LiveTickerBar } from "@/components/live-ticker-bar"
import { useMarketData } from "@/lib/hooks/use-swr-market-data"
import { useMarketHours } from "@/lib/hooks/use-market-hours"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"
import { MarketOverview } from "./market-overview"
export function MarketStatusHeader() {
  const [currentTime, setCurrentTime] = useState(new Date())
  const { marketHours, isLoading: isLoadingHours, isError: isErrorHours } = useMarketHours()
  const { marketData, isLoading: isLoadingData, isError: isErrorData } = useMarketData()
  const { setTheme, theme } = useTheme()
  const [mounted, setMounted] = useState(false)
  useEffect(() => {
    setMounted(true)
  }, [])
  useEffect(() => {
    const timer = setInterval(() => setCurrentTime(new Date()), 1000)
    return () => clearInterval(timer)
  }, [])
  const getMarketStatusIcon = (status: string) => {
    switch (status) {
      case "during":
        return <Globe2 className="h-4 w-4 text-green-500" />
      case "after":
        return <Moon className="h-4 w-4 text-blue-500" />
      case "pre":
        return <Sun className="h-4 w-4 text-yellow-500" />
      default:
        return <Clock className="h-4 w-4 text-muted-foreground" />
    }
  }
  const toggleTheme = () => {
    setTheme(theme === "dark" ? "light" : "dark")
  }
  return (
    <Card className="rounded-none border-x-0">
      <div className="flex items-center justify-between bg-muted/50 p-2 rounded-md">
        <div className="flex items-center space-x-2">
          <Button variant="ghost" size="icon" onClick={toggleTheme} className="h-6 w-6" disabled={!mounted}>
            {mounted && (theme === "dark" ? <Sun className="h-4 w-4" /> : <Moon className="h-4 w-4" />)}
          </Button>
          {!isLoadingHours && !isErrorHours && marketHours && (
            <Badge
              variant={marketHours === "during" ? "success" : marketHours === "after" ? "default" : "warning"}
              className="text-xs px-2 py-0.5 flex items-center"
            >
              {getMarketStatusIcon(marketHours)}
              <span className="ml-1">
                {marketHours === "during" ? "Market Open" : marketHours === "after" ? "After Hours" : "Pre-Market"}
              </span>
            </Badge>
          )}
        </div>
        <div className="flex items-center space-x-2">
          <Clock className="h-4 w-4 text-muted-foreground" />
          <span className="text-xs font-medium">
            {currentTime.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
          </span>
        </div>
      </div>
      <LiveTickerBar data={marketData || []} isLoading={isLoadingData} isError={isErrorData} />
      <div className="h-[200px]">
        <MarketOverview />
      </div>
    </Card>
  )
}
</file>

<file path="components/news-room.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { ScrollArea } from "@/components/ui/scroll-area"
const newsItems = [
  {
    title: "Company X Announces Record Profits",
    source: "Financial Times",
    time: "2 hours ago",
    sentiment: "positive",
  },
  {
    title: "Market Volatility Increases Amid Global Tensions",
    source: "Wall Street Journal",
    time: "4 hours ago",
    sentiment: "negative",
  },
  {
    title: "New Tech IPO Sees Strong First Day Trading",
    source: "TechCrunch",
    time: "6 hours ago",
    sentiment: "positive",
  },
  {
    title: "Central Bank Hints at Potential Rate Cut",
    source: "Bloomberg",
    time: "8 hours ago",
    sentiment: "neutral",
  },
]
export function NewsRoom() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>News Room</CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[300px]">
          <ul className="space-y-4">
            {newsItems.map((item, index) => (
              <li key={index} className="border-b pb-2">
                <h3 className="font-medium">{item.title}</h3>
                <div className="flex items-center justify-between mt-1">
                  <span className="text-sm text-muted-foreground">
                    {item.source} • {item.time}
                  </span>
                  <Badge
                    variant={
                      item.sentiment === "positive"
                        ? "success"
                        : item.sentiment === "negative"
                          ? "destructive"
                          : "secondary"
                    }
                  >
                    {item.sentiment}
                  </Badge>
                </div>
              </li>
            ))}
          </ul>
        </ScrollArea>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/option-chain.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Badge } from "@/components/ui/badge"
interface OptionData {
  strike: number
  callBid: number
  callAsk: number
  callVolume: number
  putBid: number
  putAsk: number
  putVolume: number
}
interface StockData {
  symbol: string
  price: number
  change: number
  expirations: string[]
}
const generateMockOptionData = (strike: number): OptionData => ({
  strike,
  callBid: Number((Math.random() * 5).toFixed(2)),
  callAsk: Number((Math.random() * 5 + 0.1).toFixed(2)),
  callVolume: Math.floor(Math.random() * 1000),
  putBid: Number((Math.random() * 5).toFixed(2)),
  putAsk: Number((Math.random() * 5 + 0.1).toFixed(2)),
  putVolume: Math.floor(Math.random() * 1000),
})
const generateMockStockData = (): StockData[] => [
  {
    symbol: "AAPL",
    price: 150.25,
    change: 1.5,
    expirations: ["2023-05-19", "2023-05-26", "2023-06-02", "2023-06-09"],
  },
  {
    symbol: "GOOGL",
    price: 2250.75,
    change: -0.8,
    expirations: ["2023-05-19", "2023-05-26", "2023-06-02", "2023-06-09"],
  },
  {
    symbol: "MSFT",
    price: 305.5,
    change: 0.5,
    expirations: ["2023-05-19", "2023-05-26", "2023-06-02", "2023-06-09"],
  },
]
export function OptionChain() {
  const [stockData, setStockData] = useState<StockData[]>(generateMockStockData())
  const [selectedSymbol, setSelectedSymbol] = useState<string>("AAPL")
  const [selectedExpiration, setSelectedExpiration] = useState<string>("2023-05-19")
  const [optionData, setOptionData] = useState<OptionData[]>([])
  useEffect(() => {
    const selectedStock = stockData.find((stock) => stock.symbol === selectedSymbol)
    if (selectedStock) {
      const strikes = Array.from({ length: 11 }, (_, i) => selectedStock.price + (i - 5) * 5)
      setOptionData(strikes.map(generateMockOptionData))
    }
  }, [selectedSymbol, stockData])
  useEffect(() => {
    const interval = setInterval(() => {
      setStockData(generateMockStockData())
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  const selectedStock = stockData.find((stock) => stock.symbol === selectedSymbol)
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Option Chain</CardTitle>
            <p className="text-sm text-muted-foreground">View and analyze option data</p>
          </div>
          <div className="flex space-x-2">
            <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Select symbol" />
              </SelectTrigger>
              <SelectContent>
                {stockData.map((stock) => (
                  <SelectItem key={stock.symbol} value={stock.symbol}>
                    {stock.symbol}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select value={selectedExpiration} onValueChange={setSelectedExpiration}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Expiration" />
              </SelectTrigger>
              <SelectContent>
                {selectedStock?.expirations.map((exp) => (
                  <SelectItem key={exp} value={exp}>
                    {exp}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {selectedStock && (
          <div className="mb-4 flex items-center justify-between">
            <div>
              <p className="text-2xl font-bold">${selectedStock.price.toFixed(2)}</p>
              <Badge variant={selectedStock.change >= 0 ? "success" : "destructive"}>
                {selectedStock.change >= 0 ? "+" : ""}
                {selectedStock.change.toFixed(2)}%
              </Badge>
            </div>
            <Input
              type="text"
              placeholder="Search Strike"
              className="w-[200px]"
              onChange={(e) => {
                const value = Number.parseFloat(e.target.value)
                if (!isNaN(value)) {
                  const strikes = Array.from({ length: 11 }, (_, i) => value + (i - 5) * 5)
                  setOptionData(strikes.map(generateMockOptionData))
                }
              }}
            />
          </div>
        )}
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="text-right">Call Vol</TableHead>
                <TableHead className="text-right">Call Bid</TableHead>
                <TableHead className="text-right">Call Ask</TableHead>
                <TableHead className="text-center">Strike</TableHead>
                <TableHead className="text-right">Put Bid</TableHead>
                <TableHead className="text-right">Put Ask</TableHead>
                <TableHead className="text-right">Put Vol</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {optionData.map((option) => (
                <TableRow key={option.strike}>
                  <TableCell className="text-right">{option.callVolume}</TableCell>
                  <TableCell className="text-right">{option.callBid.toFixed(2)}</TableCell>
                  <TableCell className="text-right">{option.callAsk.toFixed(2)}</TableCell>
                  <TableCell className="text-center font-bold">{option.strike.toFixed(2)}</TableCell>
                  <TableCell className="text-right">{option.putBid.toFixed(2)}</TableCell>
                  <TableCell className="text-right">{option.putAsk.toFixed(2)}</TableCell>
                  <TableCell className="text-right">{option.putVolume}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/order-book-visualization.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { RefreshCcw } from "lucide-react"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
interface OrderBookEntry {
  price: number
  size: number
}
interface OrderBook {
  bids: OrderBookEntry[]
  asks: OrderBookEntry[]
}
const generateOrderBook = (basePrice: number): OrderBook => {
  const bids: OrderBookEntry[] = []
  const asks: OrderBookEntry[] = []
  for (let i = 0; i < 10; i++) {
    bids.push({
      price: basePrice - i * 0.01 - Math.random() * 0.005,
      size: Math.floor(Math.random() * 1000) + 100,
    })
    asks.push({
      price: basePrice + i * 0.01 + Math.random() * 0.005,
      size: Math.floor(Math.random() * 1000) + 100,
    })
  }
  return { bids, asks }
}
export function OrderBookVisualization() {
  const [orderBook, setOrderBook] = useState<OrderBook>(generateOrderBook(100))
  const [basePrice, setBasePrice] = useState(100)
  const [selectedSymbol, setSelectedSymbol] = useState("BTC/USD")
  const updateOrderBook = useCallback(() => {
    const newBasePrice = basePrice + (Math.random() - 0.5) * 0.1
    setBasePrice(newBasePrice)
    setOrderBook(generateOrderBook(newBasePrice))
  }, [basePrice])
  useEffect(() => {
    const interval = setInterval(updateOrderBook, 2000) // Update every 2 seconds
    return () => clearInterval(interval)
  }, [updateOrderBook])
  const maxSize = Math.max(...orderBook.bids.map((bid) => bid.size), ...orderBook.asks.map((ask) => ask.size))
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Real-time Order Book</CardTitle>
            <CardDescription>Live visualization of bids and asks</CardDescription>
          </div>
          <div className="flex items-center space-x-2">
            <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>
              <SelectTrigger className="w-[120px]">
                <SelectValue placeholder="Symbol" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="BTC/USD">BTC/USD</SelectItem>
                <SelectItem value="ETH/USD">ETH/USD</SelectItem>
                <SelectItem value="AAPL">AAPL</SelectItem>
                <SelectItem value="GOOGL">GOOGL</SelectItem>
              </SelectContent>
            </Select>
            <Button variant="outline" size="icon" onClick={updateOrderBook}>
              <RefreshCcw className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="flex">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="text-right">Size</TableHead>
                <TableHead className="text-right">Bid</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {orderBook.bids.map((bid, index) => (
                <TableRow key={index}>
                  <TableCell className="text-right">{bid.size}</TableCell>
                  <TableCell className="text-right text-green-500">
                    {bid.price.toFixed(2)}
                    <div className="h-1 bg-green-200" style={{ width: `${(bid.size / maxSize) * 100}%` }} />
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ask</TableHead>
                <TableHead>Size</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {orderBook.asks.map((ask, index) => (
                <TableRow key={index}>
                  <TableCell className="text-left text-red-500">
                    {ask.price.toFixed(2)}
                    <div className="h-1 bg-red-200" style={{ width: `${(ask.size / maxSize) * 100}%` }} />
                  </TableCell>
                  <TableCell className="text-left">{ask.size}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/order-book.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
interface Order {
  price: number
  size: number
}
interface OrderBook {
  bids: Order[]
  asks: Order[]
}
const mockOrderBook: OrderBook = {
  bids: [
    { price: 100.0, size: 100 },
    { price: 99.95, size: 200 },
    { price: 99.9, size: 300 },
    { price: 99.85, size: 150 },
    { price: 99.8, size: 250 },
  ],
  asks: [
    { price: 100.05, size: 150 },
    { price: 100.1, size: 250 },
    { price: 100.15, size: 100 },
    { price: 100.2, size: 300 },
    { price: 100.25, size: 200 },
  ],
}
export function OrderBook() {
  const [orderBook, setOrderBook] = useState<OrderBook>(mockOrderBook)
  useEffect(() => {
    // In a real application, you would fetch the order book data here
    // and update it periodically
    const interval = setInterval(() => {
      // Simulate order book updates
      setOrderBook((prevOrderBook) => ({
        bids: prevOrderBook.bids.map((bid) => ({ ...bid, size: bid.size + Math.floor(Math.random() * 10) - 5 })),
        asks: prevOrderBook.asks.map((ask) => ({ ...ask, size: ask.size + Math.floor(Math.random() * 10) - 5 })),
      }))
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Order Book</CardTitle>
        <CardDescription>Real-time market depth</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <h3 className="font-semibold mb-2">Bids</h3>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Price</TableHead>
                  <TableHead>Size</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {orderBook.bids.map((bid, index) => (
                  <TableRow key={index}>
                    <TableCell className="text-green-500">{bid.price.toFixed(2)}</TableCell>
                    <TableCell>{bid.size}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
          <div>
            <h3 className="font-semibold mb-2">Asks</h3>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Price</TableHead>
                  <TableHead>Size</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {orderBook.asks.map((ask, index) => (
                  <TableRow key={index}>
                    <TableCell className="text-red-500">{ask.price.toFixed(2)}</TableCell>
                    <TableCell>{ask.size}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/ownership-structure.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from "recharts"
const ownershipData = [
  { name: "Institutional", value: 60 },
  { name: "Insider", value: 15 },
  { name: "Individual", value: 25 },
]
const COLORS = ["#0088FE", "#00C49F", "#FFBB28"]
export function OwnershipStructure() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Ownership Structure</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie
              data={ownershipData}
              cx="50%"
              cy="50%"
              labelLine={false}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
            >
              {ownershipData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/peter-lynch-valuation.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
const peterLynchMetrics = [
  { name: "P/E Ratio", value: 15.2, benchmark: 20, isBetter: true },
  { name: "PEG Ratio", value: 1.2, benchmark: 1, isBetter: false },
  { name: "Dividend Yield", value: 2.5, benchmark: 2, isBetter: true },
  { name: "Debt-to-Equity", value: 0.8, benchmark: 1, isBetter: true },
]
export function PeterLynchValuation() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Peter Lynch Valuation</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          {peterLynchMetrics.map((metric) => (
            <li key={metric.name} className="flex items-center justify-between">
              <span className="font-medium">{metric.name}</span>
              <div className="flex items-center space-x-2">
                <span>{metric.value}</span>
                <Badge variant={metric.isBetter ? "success" : "destructive"}>
                  {metric.isBetter ? "Better" : "Worse"} than {metric.benchmark}
                </Badge>
              </div>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/polygon-ticker-wall.tsx">
import { useEffect, useState } from 'react';
import { useStockWebSocket } from '@/lib/hooks/use-stock-websocket';
import { AggregateMessage } from '@/types/polygon';
interface TickerData {
  symbol: string;
  price: number;
  volume: number;
  change: number;
  changePercent: number;
  lastUpdate: number;
}
export function PolygonTickerWall() {
  const [tickers, setTickers] = useState<Map<string, TickerData>>(new Map());
  const [symbols, setSymbols] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [status, setStatus] = useState<string>('disconnected');
  // Fetch initial symbols
  useEffect(() => {
    async function fetchSymbols() {
      try {
        const response = await fetch('/api/stock/tickers/trending');
        if (!response.ok) throw new Error('Failed to fetch trending tickers');
        const data = await response.json();
        setSymbols(data.symbols);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch symbols');
      }
    }
    fetchSymbols();
  }, []);
  const handleAggregate = (data: AggregateMessage) => {
    setTickers(prev => {
      const newTickers = new Map(prev);
      const prevTicker = newTickers.get(data.sym);
      const prevPrice = prevTicker?.price ?? data.c;
      newTickers.set(data.sym, {
        symbol: data.sym,
        price: data.c,
        volume: data.v,
        change: data.c - prevPrice,
        changePercent: ((data.c - prevPrice) / prevPrice) * 100,
        lastUpdate: data.t
      });
      return newTickers;
    });
  };
  const { isConnected } = useStockWebSocket({
    symbols,
    onAggregate: handleAggregate,
    onError: (error) => setError(error.message),
    onStatusChange: setStatus
  });
  if (error) {
    return (
      <div className="p-4 text-red-500">
        Error: {error}
      </div>
    );
  }
  if (!isConnected) {
    return (
      <div className="p-4 text-yellow-500">
        Connecting to market data...
      </div>
    );
  }
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 p-4">
      {Array.from(tickers.values()).map((ticker) => (
        <div
          key={ticker.symbol}
          className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4"
        >
          <div className="flex justify-between items-center">
            <h3 className="text-lg font-bold">{ticker.symbol}</h3>
            <span
              className={`text-lg font-semibold ${
                ticker.change >= 0 ? 'text-green-500' : 'text-red-500'
              }`}
            >
              ${ticker.price.toFixed(2)}
            </span>
          </div>
          <div className="flex justify-between mt-2 text-sm">
            <span className="text-gray-500">Volume: {ticker.volume.toLocaleString()}</span>
            <span
              className={`${
                ticker.changePercent >= 0 ? 'text-green-500' : 'text-red-500'
              }`}
            >
              {ticker.changePercent >= 0 ? '+' : ''}
              {ticker.changePercent.toFixed(2)}%
            </span>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="components/porters-five-forces.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
const forces = [
  { name: "Competitive Rivalry", level: "High", description: "Intense competition in the industry" },
  { name: "Threat of New Entrants", level: "Medium", description: "Moderate barriers to entry" },
  { name: "Bargaining Power of Suppliers", level: "Low", description: "Many suppliers available" },
  { name: "Bargaining Power of Buyers", level: "High", description: "Customers have many options" },
  { name: "Threat of Substitutes", level: "Medium", description: "Some alternative products available" },
]
export function PortersFiveForces() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Porter's Five Forces Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          {forces.map((force) => (
            <li key={force.name} className="flex items-center justify-between">
              <span className="font-medium">{force.name}</span>
              <div className="flex items-center space-x-2">
                <Badge
                  variant={force.level === "High" ? "destructive" : force.level === "Medium" ? "default" : "secondary"}
                >
                  {force.level}
                </Badge>
                <span className="text-sm text-muted-foreground">{force.description}</span>
              </div>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-allocation.tsx">
"use client"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, PieChart, Pie, Cell, Tooltip, Legend } from "recharts"
const allocationData = [
  { name: "Stocks", value: 60 },
  { name: "Bonds", value: 20 },
  { name: "Real Estate", value: 10 },
  { name: "Commodities", value: 5 },
  { name: "Cash", value: 5 },
]
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8"]
export function PortfolioAllocation() {
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Portfolio Allocation</CardTitle>
        <CardDescription>Current distribution of your investments</CardDescription>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie
              data={allocationData}
              cx="50%"
              cy="50%"
              labelLine={false}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
            >
              {allocationData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-overview.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, PieChart, Pie, Cell, Tooltip, Legend } from "recharts"
import { Badge } from "@/components/ui/badge"
interface PortfolioItem {
  symbol: string
  value: number
  change: number
}
const COLORS = ["#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884D8"]
const generateRandomPortfolio = (): PortfolioItem[] => {
  const symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"]
  return symbols.map((symbol) => ({
    symbol,
    value: Math.random() * 10000 + 5000,
    change: (Math.random() - 0.5) * 10,
  }))
}
export function PortfolioOverview() {
  const [portfolio, setPortfolio] = useState<PortfolioItem[]>(generateRandomPortfolio())
  useEffect(() => {
    const interval = setInterval(() => {
      setPortfolio(generateRandomPortfolio())
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  const totalValue = portfolio.reduce((sum, item) => sum + item.value, 0)
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Portfolio Overview</CardTitle>
        <CardDescription>Your current holdings and performance</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex justify-between items-center mb-4">
          <div>
            <p className="text-2xl font-bold">${totalValue.toFixed(2)}</p>
            <p className="text-sm text-muted-foreground">Total Value</p>
          </div>
          <Badge variant="outline" className="text-lg">
            {portfolio.reduce((sum, item) => sum + item.change, 0).toFixed(2)}%
          </Badge>
        </div>
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie
              data={portfolio}
              dataKey="value"
              nameKey="symbol"
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              label
            >
              {portfolio.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
        <div className="mt-4 space-y-2">
          {portfolio.map((item) => (
            <div key={item.symbol} className="flex justify-between items-center">
              <span className="font-medium">{item.symbol}</span>
              <div className="flex items-center space-x-2">
                <span>${item.value.toFixed(2)}</span>
                <Badge variant={item.change >= 0 ? "success" : "destructive"}>{item.change.toFixed(2)}%</Badge>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-performance.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ResponsiveContainer, LineChart, Line, XAxis, YAxis, Tooltip, Legend } from "recharts"
const performanceData = [
  { date: "2023-01-01", value: 10000 },
  { date: "2023-02-01", value: 11200 },
  { date: "2023-03-01", value: 10800 },
  { date: "2023-04-01", value: 12000 },
  { date: "2023-05-01", value: 12500 },
  { date: "2023-06-01", value: 13100 },
]
export function PortfolioPerformance() {
  const [timeframe, setTimeframe] = useState("6M")
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Portfolio Performance</CardTitle>
            <CardDescription>Track your portfolio's growth over time</CardDescription>
          </div>
          <Select value={timeframe} onValueChange={setTimeframe}>
            <SelectTrigger className="w-[100px]">
              <SelectValue placeholder="Timeframe" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="1M">1 Month</SelectItem>
              <SelectItem value="3M">3 Months</SelectItem>
              <SelectItem value="6M">6 Months</SelectItem>
              <SelectItem value="1Y">1 Year</SelectItem>
              <SelectItem value="ALL">All Time</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={performanceData}>
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Legend />
            <Line type="monotone" dataKey="value" stroke="#8884d8" />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/portfolio-transactions.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
const transactions = [
  { id: 1, date: "2023-06-01", type: "Buy", symbol: "AAPL", quantity: 10, price: 180.95 },
  { id: 2, date: "2023-06-02", type: "Sell", symbol: "GOOGL", quantity: 5, price: 124.67 },
  { id: 3, date: "2023-06-03", type: "Buy", symbol: "MSFT", quantity: 15, price: 335.4 },
  { id: 4, date: "2023-06-04", type: "Buy", symbol: "AMZN", quantity: 8, price: 124.25 },
  { id: 5, date: "2023-06-05", type: "Sell", symbol: "TSLA", quantity: 12, price: 213.97 },
]
export function PortfolioTransactions() {
  const [filter, setFilter] = useState("all")
  const filteredTransactions =
    filter === "all" ? transactions : transactions.filter((t) => t.type.toLowerCase() === filter)
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Recent Transactions</CardTitle>
            <CardDescription>Your latest portfolio activities</CardDescription>
          </div>
          <Select value={filter} onValueChange={setFilter}>
            <SelectTrigger className="w-[120px]">
              <SelectValue placeholder="Filter" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All</SelectItem>
              <SelectItem value="buy">Buy</SelectItem>
              <SelectItem value="sell">Sell</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Symbol</TableHead>
              <TableHead>Quantity</TableHead>
              <TableHead>Price</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredTransactions.map((transaction) => (
              <TableRow key={transaction.id}>
                <TableCell>{transaction.date}</TableCell>
                <TableCell>{transaction.type}</TableCell>
                <TableCell>{transaction.symbol}</TableCell>
                <TableCell>{transaction.quantity}</TableCell>
                <TableCell>${transaction.price.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/quick-summary.tsx">
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface QuickSummaryProps {
  marketHours: string
}
export function QuickSummary({ marketHours }: QuickSummaryProps) {
  return (
    <Card className="mb-4">
      <CardHeader>
        <CardTitle>Market Quick Summary</CardTitle>
        <CardDescription>Overview of current market conditions</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-medium">Market Status</p>
            <Badge variant={marketHours === "during" ? "default" : "secondary"}>
              {marketHours === "during" ? "Open" : marketHours === "pre" ? "Pre-Market" : "After-Hours"}
            </Badge>
          </div>
          <div>
            <p className="text-sm font-medium">S&P 500</p>
            <p className="text-2xl font-bold">4,185.81</p>
            <Badge variant="outline" className="bg-green-500/10 text-green-500">
              +0.45%
            </Badge>
          </div>
          <div>
            <p className="text-sm font-medium">NASDAQ</p>
            <p className="text-2xl font-bold">12,888.28</p>
            <Badge variant="outline" className="bg-green-500/10 text-green-500">
              +0.73%
            </Badge>
          </div>
          <div>
            <p className="text-sm font-medium">DOW</p>
            <p className="text-2xl font-bold">33,875.40</p>
            <Badge variant="outline" className="bg-red-500/10 text-red-500">
              -0.23%
            </Badge>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/responsive-layout.tsx">
import React from "react"
import { useMediaQuery } from "@/hooks/use-media-query"
interface ResponsiveLayoutProps {
  children: React.ReactNode
}
export function ResponsiveLayout({ children }: ResponsiveLayoutProps) {
  const isMobile = useMediaQuery("(max-width: 768px)")
  return (
    <div className={`container mx-auto p-4 ${isMobile ? "space-y-4" : "grid grid-cols-12 gap-4"}`}>
      {React.Children.map(children, (child) => (
        <div className={isMobile ? "w-full" : "col-span-12 md:col-span-6 lg:col-span-4"}>{child}</div>
      ))}
    </div>
  )
}
</file>

<file path="components/sankey-diagram.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, Sankey, Tooltip } from "recharts"
const data = {
  nodes: [
    { name: "Revenue" },
    { name: "COGS" },
    { name: "Gross Profit" },
    { name: "Operating Expenses" },
    { name: "Operating Income" },
    { name: "Taxes" },
    { name: "Net Income" },
  ],
  links: [
    { source: 0, target: 1, value: 1000 },
    { source: 0, target: 2, value: 500 },
    { source: 2, target: 3, value: 300 },
    { source: 2, target: 4, value: 200 },
    { source: 4, target: 5, value: 50 },
    { source: 4, target: 6, value: 150 },
  ],
}
export function SankeyDiagram() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Cash Flow Sankey Diagram</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={300}>
          <Sankey
            data={data}
            nodePadding={50}
            nodeWidth={10}
            linkCurvature={0.5}
            iterations={64}
            link={{ stroke: "#000000" }}
          >
            <Tooltip />
          </Sankey>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/sector-performance.tsx">
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
interface SectorPerformance {
  name: string
  value: number
}
const mockSectorPerformance: SectorPerformance[] = [
  { name: "Technology", value: 2.31 },
  { name: "Healthcare", value: -0.54 },
  { name: "Financials", value: 1.12 },
  { name: "Energy", value: -1.87 },
  { name: "Consumer", value: 0.76 },
  { name: "Industrials", value: 0.95 },
  { name: "Materials", value: -0.32 },
  { name: "Utilities", value: 0.18 },
]
export function SectorPerformance() {
  return (
    <Card>
      <CardContent className="p-4">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {mockSectorPerformance.map((sector) => (
            <div key={sector.name} className="flex justify-between items-center">
              <span className="text-sm font-medium">{sector.name}</span>
              <Badge variant={sector.value >= 0 ? "success" : "destructive"}>
                {sector.value > 0 ? "+" : ""}
                {sector.value.toFixed(2)}%
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/settings-panel.tsx">
"use client"
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Switch } from "@/components/ui/switch"
import { Label } from "@/components/ui/label"
import { ScrollArea } from "@/components/ui/scroll-area"
import { useUserPreferences } from "@/lib/hooks/use-user-preferences"
import { Settings, X, GripVertical } from "lucide-react"
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from "@dnd-kit/core"
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
} from "@dnd-kit/sortable"
import { CSS } from "@dnd-kit/utilities"
const arrayMove = (array: string[], from: number, to: number) => {
  const newArray = array.slice()
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0])
  return newArray
}
interface SettingsPanelProps {
  editMode: boolean
  setEditMode: (value: boolean) => void
}
export function SettingsPanel({ editMode, setEditMode }: SettingsPanelProps) {
  const { preferences, updatePreferences } = useUserPreferences()
  const [isOpen, setIsOpen] = useState(false)
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  )
  const onDragEnd = (event: any) => {
    const { active, over } = event
    if (active.id !== over.id) {
      const oldIndex = preferences.layout.indexOf(active.id)
      const newIndex = preferences.layout.indexOf(over.id)
      const newLayout = arrayMove(preferences.layout, oldIndex, newIndex)
      updatePreferences({ layout: newLayout })
    }
  }
  const allWidgets = [
    { id: "market-overview", label: "Market Overview" },
    { id: "live-market-data", label: "Live Market Data" },
    { id: "smart-money-flow", label: "Smart Money Flow" },
    { id: "ai-insights", label: "AI Insights" },
    { id: "support-resistance-levels", label: "Support/Resistance Levels" },
    { id: "generative-news-panel", label: "Generative News Panel" },
    { id: "generative-trading-ideas", label: "Generative Trading Ideas" },
    { id: "context-aware-chart", label: "Context-Aware Chart" },
    { id: "order-book-visualization", label: "Order Book Visualization" },
    { id: "generative-chat-interface", label: "Generative Chat Interface" },
    { id: "portfolio-overview", label: "Portfolio Overview" },
    { id: "economic-calendar", label: "Economic Calendar" },
    { id: "market-breadth", label: "Market Breadth" },
    { id: "trading-volume", label: "Trading Volume" },
    { id: "option-chain", label: "Option Chain" },
    { id: "technical-analysis", label: "Technical Analysis" },
  ]
  function SortableItem({ id }: { id: string }) {
    const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id })
    const style = {
      transform: CSS.Transform.toString(transform),
      transition,
    }
    const widget = allWidgets.find((w) => w.id === id)
    if (!widget) return null
    return (
      <li
        ref={setNodeRef}
        style={style}
        {...attributes}
        {...listeners}
        className="flex items-center space-x-2 bg-muted p-2 rounded-md"
      >
        <GripVertical className="h-4 w-4 text-muted-foreground" />
        <label htmlFor={`widget-${id}`} className="text-sm font-medium leading-none cursor-pointer flex-1">
          {widget.label}
        </label>
      </li>
    )
  }
  return (
    <div className="fixed bottom-4 right-4 z-50">
      <Button onClick={() => setIsOpen(!isOpen)} size="icon">
        <Settings className="h-4 w-4" />
      </Button>
      {isOpen && (
        <div className="absolute bottom-12 right-0 w-80 bg-background border rounded-lg shadow-lg">
          <div className="flex justify-between items-center p-4 border-b">
            <h2 className="text-lg font-semibold">Dashboard Settings</h2>
            <Button variant="ghost" size="icon" onClick={() => setIsOpen(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
          <ScrollArea className="h-[400px] p-4">
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <Label htmlFor="edit-mode-toggle">Edit Mode</Label>
                <Switch id="edit-mode-toggle" checked={editMode} onCheckedChange={setEditMode} />
              </div>
              <div className="space-y-2">
                <Label>Widget Order</Label>
                <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onDragEnd}>
                  <SortableContext items={preferences.layout} strategy={verticalListSortingStrategy}>
                    <ul className="space-y-2">
                      {preferences.layout.map((widgetId) => (
                        <SortableItem key={widgetId} id={widgetId} />
                      ))}
                    </ul>
                  </SortableContext>
                </DndContext>
              </div>
            </div>
          </ScrollArea>
        </div>
      )}
    </div>
  )
}
</file>

<file path="components/sidebar.tsx">
"use client"
import { useState, useEffect, useRef } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible"
import {
  ChevronRight,
  ChevronDown,
  Home,
  BarChart2,
  PieChart,
  TrendingUp,
  Eye,
  Settings,
  HelpCircle,
  GraduationCap,
  Search,
  Filter,
  Brain,
  BarChart3,
} from "lucide-react"
interface SubNavItem {
  title: string
  href: string
}
interface NavItem {
  title: string
  icon: React.ElementType
  href: string
  subItems?: SubNavItem[]
}
const navItems: NavItem[] = [
  { title: "Dashboard", icon: Home, href: "/" },
  {
    title: "Market",
    icon: BarChart2,
    href: "/market-overview",
    subItems: [
      { title: "Overview", href: "/market-overview" },
      { title: "Economic Calendar", href: "/economic-calendar" },
      { title: "Financial Heatmap", href: "/financial-heatmap" },
      { title: "Economic Event Tracker", href: "/economic-event-tracker" },
    ],
  },
  {
    title: "Portfolio",
    icon: PieChart,
    href: "/portfolio",
    subItems: [
      { title: "Overview", href: "/portfolio" },
      { title: "Analytics", href: "/portfolio-analytics" },
      { title: "Optimizer", href: "/portfolio-optimizer" },
    ],
  },
  {
    title: "Trading",
    icon: TrendingUp,
    href: "/trading",
    subItems: [
      { title: "Execute Trades", href: "/trading" },
      { title: "Backtesting", href: "/backtesting" },
      { title: "Journal", href: "/trading-journal" },
    ],
  },
  { title: "Watchlist", icon: Eye, href: "/watchlist" },
  {
    title: "Analysis",
    icon: Search,
    href: "/stock-analysis",
    subItems: [
      { title: "Stock Analysis", href: "/stock-analysis" },
      { title: "Technical Analysis", href: "/technical-analysis" },
      { title: "Valuation", href: "/valuation" },
      { title: "Due Diligence", href: "/due-diligence" },
    ],
  },
  {
    title: "Asset Discovery",
    icon: Filter,
    href: "/asset-search",
    subItems: [
      { title: "Asset Search", href: "/asset-search" },
      { title: "Asset Screener", href: "/asset-screener" },
    ],
  },
  { title: "AI Researcher", icon: Brain, href: "/ai-researcher" },
  {
    title: "Education",
    icon: GraduationCap,
    href: "/business-major",
    subItems: [
      { title: "Business Major", href: "/business-major" },
      { title: "Financial Advisor", href: "/financial-advisor" },
    ],
  },
]
function Logo({ size = "default" }: { size?: "default" | "small" }) {
  return (
    <div className="flex items-center gap-2">
      <div
        className={cn(
          "flex items-center justify-center rounded-lg bg-[#4768FD]",
          size === "default" ? "w-7 h-7" : "w-6 h-6",
        )}
      >
        <BarChart3 className={cn("text-white", size === "default" ? "h-4 w-4" : "h-3.5 w-3.5")} />
      </div>
    </div>
  )
}
export function Sidebar() {
  const pathname = usePathname()
  const [isCollapsed, setIsCollapsed] = useState(true)
  const [openItems, setOpenItems] = useState<string[]>([])
  const sidebarRef = useRef<HTMLDivElement>(null)
  useEffect(() => {
    const handleMouseEnter = () => setIsCollapsed(false)
    const handleMouseLeave = () => {
      setIsCollapsed(true)
      // Close all open items when sidebar collapses
      setOpenItems([])
    }
    const sidebar = sidebarRef.current
    if (sidebar) {
      sidebar.addEventListener("mouseenter", handleMouseEnter)
      sidebar.addEventListener("mouseleave", handleMouseLeave)
    }
    return () => {
      if (sidebar) {
        sidebar.removeEventListener("mouseenter", handleMouseEnter)
        sidebar.removeEventListener("mouseleave", handleMouseLeave)
      }
    }
  }, [])
  // Update openItems when pathname changes
  useEffect(() => {
    const currentNavItem = navItems.find(
      (item) => item.subItems?.some((subItem) => pathname === subItem.href)
    )
    if (currentNavItem && !isCollapsed) {
      setOpenItems([currentNavItem.title])
    }
  }, [pathname, isCollapsed])
  const toggleItem = (title: string) => {
    setOpenItems((prevOpenItems) =>
      prevOpenItems.includes(title) ? prevOpenItems.filter((item) => item !== title) : [...prevOpenItems, title],
    )
  }
  const renderNavItem = (item: NavItem, depth = 0) => {
    const isActive = pathname === item.href || pathname.startsWith(item.href + "/")
    const hasSubItems = item.subItems && item.subItems.length > 0
    const isOpen = openItems.includes(item.title) || (hasSubItems && isActive && !isCollapsed)
    const Icon = item.icon
    return (
      <div key={item.href} className={cn("my-1", depth > 0 && "ml-4")}>
        {hasSubItems ? (
          <Collapsible open={isOpen} onOpenChange={() => toggleItem(item.title)}>
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                className={cn(
                  "w-full h-10 flex",
                  isCollapsed ? "justify-center px-0" : "justify-between px-4",
                  isActive && "bg-muted",
                )}
              >
                <div className={cn("flex items-center", isCollapsed && "justify-center w-full")}>
                  <Icon className="h-4 w-4 shrink-0" />
                  {!isCollapsed && <span className="ml-2">{item.title}</span>}
                </div>
                {!isCollapsed && (isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />)}
              </Button>
            </CollapsibleTrigger>
            <CollapsibleContent>
              {item.subItems?.map((subItem) => (
                <Link key={subItem.href} href={subItem.href}>
                  <Button
                    variant={pathname === subItem.href ? "secondary" : "ghost"}
                    className={cn(
                      "w-full h-10 flex justify-start px-4 ml-4",
                      pathname === subItem.href && "bg-muted",
                    )}
                  >
                    <span className="ml-2">{subItem.title}</span>
                  </Button>
                </Link>
              ))}
            </CollapsibleContent>
          </Collapsible>
        ) : (
          <Link href={item.href}>
            <Button
              variant={isActive ? "secondary" : "ghost"}
              className={cn(
                "w-full h-10 flex",
                isCollapsed ? "justify-center px-0" : "justify-start px-4",
                isActive && "bg-muted",
              )}
            >
              <div className={cn("flex items-center", isCollapsed && "justify-center w-full")}>
                <Icon className="h-4 w-4 shrink-0" />
                {!isCollapsed && <span className="ml-2">{item.title}</span>}
              </div>
            </Button>
          </Link>
        )}
      </div>
    )
  }
  return (
    <div
      ref={sidebarRef}
      className={cn(
        "flex flex-col border-r bg-background transition-all duration-300 ease-in-out shrink-0",
        isCollapsed ? "w-16" : "w-64",
      )}
    >
      <div className="h-14 flex items-center justify-center border-b">
        <div className={cn("flex items-center", isCollapsed ? "justify-center w-full" : "justify-start px-3 w-full")}>
          <Logo size={isCollapsed ? "small" : "default"} />
          {!isCollapsed && <h2 className="text-lg font-semibold ml-2 truncate">The Daily Consensus</h2>}
        </div>
      </div>
      <ScrollArea className="flex-1">
        <nav className={cn("flex flex-col gap-1 py-2", isCollapsed ? "px-2" : "px-3")}>
          {navItems.map((item) => renderNavItem(item))}
        </nav>
      </ScrollArea>
      <div className="p-3 border-t">
        <div className={cn("flex", isCollapsed ? "justify-center" : "justify-between")}>
          <Button variant="ghost" size="icon" className="h-8 w-8" asChild>
            <Link href="/settings">
              <Settings className="h-4 w-4" />
            </Link>
          </Button>
          {!isCollapsed && (
            <Button variant="ghost" size="icon" className="h-8 w-8" asChild>
              <Link href="/help">
                <HelpCircle className="h-4 w-4" />
              </Link>
            </Button>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="components/smart-money-flow.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, BarChart, Bar, XAxis, YAxis, Tooltip, Legend } from "recharts"
import { Badge } from "@/components/ui/badge"
interface FlowData {
  ticker: string
  netFlow: number
  inflow: number
  outflow: number
}
const generateRandomData = (): FlowData[] => {
  const tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "FB", "TSLA", "NVDA", "JPM", "V", "JNJ"]
  return tickers.map((ticker) => {
    const inflow = Math.random() * 1000000
    const outflow = Math.random() * 1000000
    return {
      ticker,
      netFlow: inflow - outflow,
      inflow,
      outflow,
    }
  })
}
export function SmartMoneyFlow() {
  const [data, setData] = useState<FlowData[]>(generateRandomData())
  useEffect(() => {
    const interval = setInterval(() => {
      setData(generateRandomData())
    }, 5000)
    return () => clearInterval(interval)
  }, [])
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Smart Money Flow</CardTitle>
        <p className="text-sm text-muted-foreground">Institutional investor activity</p>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={data}>
            <XAxis dataKey="ticker" />
            <YAxis />
            <Tooltip />
            <Legend />
            <Bar dataKey="inflow" fill="#4ade80" name="Inflow" />
            <Bar dataKey="outflow" fill="#f87171" name="Outflow" />
          </BarChart>
        </ResponsiveContainer>
        <div className="mt-4 space-y-2">
          {data.map((item) => (
            <div key={item.ticker} className="flex items-center justify-between">
              <span className="font-medium">{item.ticker}</span>
              <Badge variant={item.netFlow > 0 ? "success" : "destructive"}>
                ${Math.abs(item.netFlow).toLocaleString(undefined, { maximumFractionDigits: 0 })}
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/stock-heatmap.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, Treemap, Tooltip } from "recharts"
const COLORS = ["#8884d8", "#82ca9d", "#ffc658", "#ff8042", "#0088FE", "#00C49F"]
const data = [
  { name: "Technology", size: 400, color: "#8884d8" },
  { name: "Healthcare", size: 300, color: "#82ca9d" },
  { name: "Financials", size: 300, color: "#ffc658" },
  { name: "Consumer Discretionary", size: 200, color: "#ff8042" },
  { name: "Communication Services", size: 200, color: "#0088FE" },
  { name: "Industrials", size: 100, color: "#00C49F" },
]
export function StockHeatmap() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Stock Market Heatmap</CardTitle>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={400}>
          <Treemap
            data={data}
            dataKey="size"
            ratio={4 / 3}
            stroke="#fff"
            fill="#8884d8"
            content={({ root, depth, x, y, width, height, index, payload, name }) => (
              <g>
                <rect
                  x={x}
                  y={y}
                  width={width}
                  height={height}
                  style={{
                    fill: depth < 2 ? COLORS[Math.floor((index / root.children.length) * COLORS.length)] : "#ffffff00",
                    stroke: "#fff",
                    strokeWidth: 2 / (depth + 1e-10),
                    strokeOpacity: 1 / (depth + 1e-10),
                  }}
                />
                {depth === 1 ? (
                  <text x={x + width / 2} y={y + height / 2 + 7} textAnchor="middle" fill="#fff" fontSize={14}>
                    {name}
                  </text>
                ) : null}
              </g>
            )}
          >
            <Tooltip content={<CustomTooltip />} />
          </Treemap>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
const CustomTooltip = ({ active, payload }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-background p-2 border rounded shadow">
        <p>{`${payload[0].payload.name} : ${payload[0].value}`}</p>
      </div>
    )
  }
  return null
}
</file>

<file path="components/stock-screener.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
const mockStocks = [
  { symbol: "AAPL", name: "Apple Inc.", price: 150.25, peRatio: 28.5, marketCap: "2.5T" },
  { symbol: "GOOGL", name: "Alphabet Inc.", price: 2750.8, peRatio: 25.4, marketCap: "1.9T" },
  { symbol: "MSFT", name: "Microsoft Corporation", price: 305.5, peRatio: 32.1, marketCap: "2.3T" },
]
export function StockScreener() {
  const [searchTerm, setSearchTerm] = useState("")
  const [sortBy, setSortBy] = useState("symbol")
  const filteredStocks = mockStocks
    .filter((stock) => stock.symbol.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => (a[sortBy] > b[sortBy] ? 1 : -1))
  return (
    <Card>
      <CardHeader>
        <CardTitle>Stock Screener</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex space-x-2 mb-4">
          <Input
            placeholder="Search by symbol"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="max-w-sm"
          />
          <Select value={sortBy} onValueChange={setSortBy}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Sort by" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="symbol">Symbol</SelectItem>
              <SelectItem value="price">Price</SelectItem>
              <SelectItem value="peRatio">P/E Ratio</SelectItem>
              <SelectItem value="marketCap">Market Cap</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Symbol</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Price</TableHead>
              <TableHead>P/E Ratio</TableHead>
              <TableHead>Market Cap</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredStocks.map((stock) => (
              <TableRow key={stock.symbol}>
                <TableCell>{stock.symbol}</TableCell>
                <TableCell>{stock.name}</TableCell>
                <TableCell>${stock.price.toFixed(2)}</TableCell>
                <TableCell>{stock.peRatio.toFixed(2)}</TableCell>
                <TableCell>{stock.marketCap}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/StockNewsItem.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
type StockNewsItemProps = {
  headline: string
  summary: string
  source: string
  publishedUtc?: string
}
export function StockNewsItem({ headline, summary, source, publishedUtc }: StockNewsItemProps) {
  return (
    <Card className="mb-4">
      <CardHeader>
        <CardTitle className="text-lg">{headline}</CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-sm mb-2">{summary}</p>
        <div className="flex justify-between items-center">
          <Badge variant="secondary">{source}</Badge>
          {publishedUtc && (
            <span className="text-xs text-muted-foreground">{new Date(publishedUtc).toLocaleString()}</span>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/support-resistance-levels.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, LineChart, Line, XAxis, YAxis, Tooltip, ReferenceLine } from "recharts"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
interface PriceData {
  date: string
  price: number
}
interface LevelData {
  price: number
  type: "support" | "resistance"
  strength: "weak" | "medium" | "strong"
}
const generateRandomData = (days: number): PriceData[] => {
  const data: PriceData[] = []
  let price = 100
  for (let i = days; i >= 0; i--) {
    const date = new Date()
    date.setDate(date.getDate() - i)
    price += (Math.random() - 0.5) * 5
    data.push({ date: date.toISOString().split("T")[0], price })
  }
  return data
}
const generateLevels = (data: PriceData[]): LevelData[] => {
  const prices = data.map((d) => d.price)
  const min = Math.min(...prices)
  const max = Math.max(...prices)
  const range = max - min
  return [
    { price: min + range * 0.236, type: "support", strength: "weak" },
    { price: min + range * 0.382, type: "support", strength: "medium" },
    { price: min + range * 0.618, type: "resistance", strength: "medium" },
    { price: min + range * 0.786, type: "resistance", strength: "strong" },
  ]
}
const tickers = ["AAPL", "GOOGL", "MSFT", "AMZN", "FB"]
export function SupportResistanceLevels() {
  const [selectedTicker, setSelectedTicker] = useState(tickers[0])
  const [data, setData] = useState<PriceData[]>(generateRandomData(30))
  const [levels, setLevels] = useState<LevelData[]>(generateLevels(data))
  useEffect(() => {
    setData(generateRandomData(30))
  }, [])
  useEffect(() => {
    setLevels(generateLevels(data))
  }, [data])
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Support & Resistance Levels</CardTitle>
            <p className="text-sm text-muted-foreground">Key price levels for {selectedTicker}</p>
          </div>
          <Select value={selectedTicker} onValueChange={setSelectedTicker}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Select a ticker" />
            </SelectTrigger>
            <SelectContent>
              {tickers.map((ticker) => (
                <SelectItem key={ticker} value={ticker}>
                  {ticker}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={data}>
            <XAxis dataKey="date" />
            <YAxis domain={["auto", "auto"]} />
            <Tooltip />
            <Line type="monotone" dataKey="price" stroke="#8884d8" dot={false} />
            {levels.map((level, index) => (
              <ReferenceLine
                key={index}
                y={level.price}
                stroke={level.type === "support" ? "#4ade80" : "#f87171"}
                strokeDasharray={level.strength === "strong" ? "0" : level.strength === "medium" ? "3 3" : "5 5"}
                label={{
                  value: `${level.type.charAt(0).toUpperCase() + level.type.slice(1)} (${level.strength})`,
                  position: "insideLeft",
                }}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/technical-analysis.tsx">
"use client"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts"
import { getTechnicalAnalysisData, subscribeToTradeSignals } from "@/lib/api/technical-analysis"
import { ChartPatterns } from "@/components/technical-analysis/chart-patterns"
import { TrendlineOverlay } from "@/components/technical-analysis/trendline-overlay"
import { FibonacciRetracement } from "@/components/technical-analysis/fibonacci-retracement"
import { TradeSignalGenerator } from "@/components/technical-analysis/trade-signal-generator"
import { MarketSentimentOverlay } from "@/components/technical-analysis/market-sentiment-overlay"
import { BrokerageIntegration } from "@/components/technical-analysis/brokerage-integration"
export function TechnicalAnalysis() {
  const [symbol, setSymbol] = useState("AAPL")
  const [timeframe, setTimeframe] = useState("1D")
  const [technicalData, setTechnicalData] = useState(null)
  const [selectedPatterns, setSelectedPatterns] = useState([])
  const [showTrendlines, setShowTrendlines] = useState(false)
  const [showFibonacci, setShowFibonacci] = useState(false)
  const [showSentiment, setShowSentiment] = useState(false)
  const [tradeSignals, setTradeSignals] = useState([])
  const fetchData = useCallback(async () => {
    const data = await getTechnicalAnalysisData(symbol, timeframe)
    setTechnicalData(data)
  }, [symbol, timeframe])
  useEffect(() => {
    fetchData()
  }, [fetchData])
  useEffect(() => {
    const unsubscribe = subscribeToTradeSignals((signal) => {
      setTradeSignals((prevSignals) => [signal, ...prevSignals])
    })
    return () => unsubscribe()
  }, [])
  if (!technicalData) {
    return <div>Loading...</div>
  }
  return (
    <Card className="w-full">
      <CardHeader>
        <div className="flex justify-between items-center">
          <div>
            <CardTitle>AI-Enhanced Technical Analysis</CardTitle>
            <CardDescription>Advanced chart analysis and trade signals</CardDescription>
          </div>
          <div className="flex space-x-2">
            <Input
              placeholder="Enter symbol"
              value={symbol}
              onChange={(e) => setSymbol(e.target.value.toUpperCase())}
              className="w-24"
            />
            <Select value={timeframe} onValueChange={setTimeframe}>
              <SelectTrigger className="w-[100px]">
                <SelectValue placeholder="Timeframe" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1D">1 Day</SelectItem>
                <SelectItem value="1W">1 Week</SelectItem>
                <SelectItem value="1M">1 Month</SelectItem>
              </SelectContent>
            </Select>
            <Button onClick={fetchData}>Update</Button>
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="chart">
          <TabsList>
            <TabsTrigger value="chart">Chart</TabsTrigger>
            <TabsTrigger value="patterns">Patterns</TabsTrigger>
            <TabsTrigger value="signals">Signals</TabsTrigger>
            <TabsTrigger value="sentiment">Sentiment</TabsTrigger>
          </TabsList>
          <TabsContent value="chart">
            <div className="h-[400px]">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={technicalData.priceData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" />
                  <YAxis />
                  <Tooltip />
                  <Line type="monotone" dataKey="price" stroke="#8884d8" />
                  {showTrendlines && <TrendlineOverlay data={technicalData.trendlines} />}
                  {showFibonacci && <FibonacciRetracement data={technicalData.fibonacciLevels} />}
                  {showSentiment && <MarketSentimentOverlay data={technicalData.sentimentData} />}
                </LineChart>
              </ResponsiveContainer>
            </div>
            <div className="flex justify-between mt-4">
              <div className="space-x-2">
                <Checkbox id="show-trendlines" checked={showTrendlines} onCheckedChange={setShowTrendlines} />
                <label htmlFor="show-trendlines">Show Trendlines</label>
              </div>
              <div className="space-x-2">
                <Checkbox id="show-fibonacci" checked={showFibonacci} onCheckedChange={setShowFibonacci} />
                <label htmlFor="show-fibonacci">Show Fibonacci</label>
              </div>
              <div className="space-x-2">
                <Checkbox id="show-sentiment" checked={showSentiment} onCheckedChange={setShowSentiment} />
                <label htmlFor="show-sentiment">Show Sentiment</label>
              </div>
            </div>
          </TabsContent>
          <TabsContent value="patterns">
            <ChartPatterns
              patterns={technicalData.detectedPatterns}
              selectedPatterns={selectedPatterns}
              setSelectedPatterns={setSelectedPatterns}
            />
          </TabsContent>
          <TabsContent value="signals">
            <TradeSignalGenerator signals={tradeSignals} />
          </TabsContent>
          <TabsContent value="sentiment">
            <MarketSentimentOverlay data={technicalData.sentimentData} />
          </TabsContent>
        </Tabs>
        <BrokerageIntegration />
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/theme-provider.tsx">
"use client"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes"
export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
</file>

<file path="components/trading-history.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
interface Trade {
  id: number
  date: string
  symbol: string
  type: "buy" | "sell"
  quantity: number
  price: number
}
const mockTrades: Trade[] = [
  { id: 1, date: "2023-06-05 14:30:00", symbol: "AAPL", type: "buy", quantity: 100, price: 180.5 },
  { id: 2, date: "2023-06-05 14:35:00", symbol: "GOOGL", type: "sell", quantity: 50, price: 125.75 },
  { id: 3, date: "2023-06-05 14:40:00", symbol: "MSFT", type: "buy", quantity: 75, price: 335.25 },
  { id: 4, date: "2023-06-05 14:45:00", symbol: "AMZN", type: "buy", quantity: 25, price: 124.5 },
  { id: 5, date: "2023-06-05 14:50:00", symbol: "TSLA", type: "sell", quantity: 30, price: 215.0 },
]
export function TradingHistory() {
  const [trades, setTrades] = useState<Trade[]>(mockTrades)
  useEffect(() => {
    // In a real application, you would fetch the trading history here
    // and potentially update it in real-time
  }, [])
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Trading History</CardTitle>
        <CardDescription>Your recent trading activities</CardDescription>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Date</TableHead>
              <TableHead>Symbol</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Quantity</TableHead>
              <TableHead>Price</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {trades.map((trade) => (
              <TableRow key={trade.id}>
                <TableCell>{trade.date}</TableCell>
                <TableCell>{trade.symbol}</TableCell>
                <TableCell>
                  <Badge variant={trade.type === "buy" ? "success" : "destructive"}>{trade.type.toUpperCase()}</Badge>
                </TableCell>
                <TableCell>{trade.quantity}</TableCell>
                <TableCell>${trade.price.toFixed(2)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trading-interface.tsx">
"use client"
import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
export function TradingInterface() {
  const [symbol, setSymbol] = useState("")
  const [quantity, setQuantity] = useState("")
  const [orderType, setOrderType] = useState("market")
  const [price, setPrice] = useState("")
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    // Handle order submission logic here
    console.log("Order submitted:", { symbol, quantity, orderType, price })
  }
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>Trading Interface</CardTitle>
        <CardDescription>Place your stock orders</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <label htmlFor="symbol">Symbol</label>
            <Input
              id="symbol"
              value={symbol}
              onChange={(e) => setSymbol(e.target.value)}
              placeholder="Enter stock symbol"
              required
            />
          </div>
          <div className="space-y-2">
            <label htmlFor="quantity">Quantity</label>
            <Input
              id="quantity"
              type="number"
              value={quantity}
              onChange={(e) => setQuantity(e.target.value)}
              placeholder="Enter quantity"
              required
            />
          </div>
          <div className="space-y-2">
            <label htmlFor="orderType">Order Type</label>
            <Select value={orderType} onValueChange={setOrderType}>
              <SelectTrigger id="orderType">
                <SelectValue placeholder="Select order type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="market">Market</SelectItem>
                <SelectItem value="limit">Limit</SelectItem>
                <SelectItem value="stop">Stop</SelectItem>
              </SelectContent>
            </Select>
          </div>
          {orderType !== "market" && (
            <div className="space-y-2">
              <label htmlFor="price">Price</label>
              <Input
                id="price"
                type="number"
                value={price}
                onChange={(e) => setPrice(e.target.value)}
                placeholder="Enter price"
                required
              />
            </div>
          )}
          <Button type="submit" className="w-full">
            Place Order
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trading-volume.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ResponsiveContainer, BarChart, Bar, XAxis, YAxis, Tooltip, Legend } from "recharts"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Badge } from "@/components/ui/badge"
interface VolumeData {
  time: string
  volume: number
}
interface SymbolData {
  symbol: string
  data: VolumeData[]
  totalVolume: number
  averageVolume: number
}
const generateMockData = (): SymbolData[] => {
  const symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "FB"]
  return symbols.map((symbol) => {
    const data: VolumeData[] = []
    let totalVolume = 0
    for (let i = 0; i < 12; i++) {
      const volume = Math.floor(Math.random() * 1000000) + 500000
      totalVolume += volume
      data.push({
        time: `${i + 9}:00`,
        volume,
      })
    }
    return {
      symbol,
      data,
      totalVolume,
      averageVolume: Math.floor(totalVolume / 12),
    }
  })
}
const initialData = [
  {
    symbol: "AAPL",
    data: Array(12).fill(null).map((_, i) => ({
      time: `${i + 9}:00`,
      volume: 500000 // Fixed initial volume
    })),
    totalVolume: 6000000,
    averageVolume: 500000
  },
  // Add other symbols with fixed initial data
  {
    symbol: "GOOGL",
    data: Array(12).fill(null).map((_, i) => ({
      time: `${i + 9}:00`,
      volume: 500000
    })),
    totalVolume: 6000000,
    averageVolume: 500000
  }
]
export function TradingVolume() {
  const [data, setData] = useState<SymbolData[]>(initialData)
  const [isHydrated, setIsHydrated] = useState(false)
  const [selectedSymbol, setSelectedSymbol] = useState<string>("AAPL")
  useEffect(() => {
    setIsHydrated(true)
  }, [])
  useEffect(() => {
    if (!isHydrated) return
    const interval = setInterval(() => {
      setData(generateMockData())
    }, 5000)
    return () => clearInterval(interval)
  }, [isHydrated])
  const selectedData = data.find((item) => item.symbol === selectedSymbol) || data[0]
  return (
    <Card className="h-full">
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Trading Volume</CardTitle>
            <p className="text-sm text-muted-foreground">Intraday trading volume analysis</p>
          </div>
          <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Select symbol" />
            </SelectTrigger>
            <SelectContent>
              {data.map((item) => (
                <SelectItem key={item.symbol} value={item.symbol}>
                  {item.symbol}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        <div className="flex justify-between items-center mb-4">
          <div>
            <p className="text-2xl font-bold">{selectedData.totalVolume.toLocaleString()}</p>
            <p className="text-sm text-muted-foreground">Total Volume</p>
          </div>
          <Badge variant="outline" className="text-lg">
            Avg: {selectedData.averageVolume.toLocaleString()}
          </Badge>
        </div>
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={selectedData.data}>
            <XAxis dataKey="time" />
            <YAxis />
            <Tooltip
              formatter={(value: number) => new Intl.NumberFormat("en").format(value)}
              labelFormatter={(label) => `Time: ${label}`}
            />
            <Legend />
            <Bar dataKey="volume" fill="#8884d8" name="Volume" />
          </BarChart>
        </ResponsiveContainer>
        <div className="mt-4 space-y-2">
          <div className="flex justify-between items-center">
            <span className="font-medium">Highest Volume</span>
            <Badge variant="outline" className="bg-green-500/10 text-green-500">
              {Math.max(...selectedData.data.map((d) => d.volume)).toLocaleString()}
            </Badge>
          </div>
          <div className="flex justify-between items-center">
            <span className="font-medium">Lowest Volume</span>
            <Badge variant="outline" className="bg-red-500/10 text-red-500">
              {Math.min(...selectedData.data.map((d) => d.volume)).toLocaleString()}
            </Badge>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/trending-topics.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
const trendingTopics = [
  { topic: "Artificial Intelligence", sentiment: "positive", mentions: 1500 },
  { topic: "Cryptocurrency Regulations", sentiment: "neutral", mentions: 1200 },
  { topic: "Green Energy Stocks", sentiment: "positive", mentions: 1000 },
  { topic: "Supply Chain Disruptions", sentiment: "negative", mentions: 800 },
  { topic: "Interest Rate Hikes", sentiment: "negative", mentions: 750 },
]
export function TrendingTopics() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Trending Market Topics</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-4">
          {trendingTopics.map((topic, index) => (
            <li key={index} className="flex items-center justify-between">
              <span className="font-medium">{topic.topic}</span>
              <div className="flex items-center space-x-2">
                <Badge
                  variant={
                    topic.sentiment === "positive"
                      ? "success"
                      : topic.sentiment === "negative"
                        ? "destructive"
                        : "secondary"
                  }
                >
                  {topic.sentiment}
                </Badge>
                <span className="text-sm text-muted-foreground">{topic.mentions} mentions</span>
              </div>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/universal-clock.tsx">
"use client"
import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Clock } from "lucide-react"
interface TradingSession {
  name: string
  status: "open" | "closed"
  hours: string
}
const tradingSessions: TradingSession[] = [
  { name: "New York", status: "open", hours: "9:30 AM - 4:00 PM EST" },
  { name: "London", status: "open", hours: "8:00 AM - 4:30 PM GMT" },
  { name: "Tokyo", status: "closed", hours: "9:00 AM - 3:00 PM JST" },
  { name: "Hong Kong", status: "closed", hours: "9:30 AM - 4:00 PM HKT" },
]
export function UniversalClock() {
  const [currentTime, setCurrentTime] = useState<Date | null>(null)
  const [mounted, setMounted] = useState(false)
  useEffect(() => {
    setMounted(true)
    setCurrentTime(new Date())
    const timer = setInterval(() => setCurrentTime(new Date()), 1000)
    return () => clearInterval(timer)
  }, [])
  // Don't render anything until mounted to avoid hydration mismatch
  if (!mounted) {
    return (
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Universal Clock</CardTitle>
          <Clock className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            --:--:--
          </div>
          <div className="mt-4 space-y-2">
            {tradingSessions.map((session) => (
              <div key={session.name} className="flex items-center justify-between">
                <span className="text-sm text-muted-foreground">{session.name}</span>
                <Badge variant={session.status === "open" ? "default" : "secondary"}>
                  {session.status}
                </Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    )
  }
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">Universal Clock</CardTitle>
        <Clock className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">
          {currentTime?.toLocaleTimeString([], { 
            hour: "2-digit", 
            minute: "2-digit", 
            second: "2-digit" 
          })}
        </div>
        <div className="mt-4 space-y-2">
          {tradingSessions.map((session) => (
            <div key={session.name} className="flex items-center justify-between">
              <span className="text-sm text-muted-foreground">{session.name}</span>
              <Badge variant={session.status === "open" ? "default" : "secondary"}>
                {session.status}
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="components/watchlist-alerts.tsx">
"use client"
import { useState } from "react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
interface Alert {
  id: string
  symbol: string
  condition: "above" | "below"
  price: number
}
export function WatchlistAlerts() {
  const [alerts, setAlerts] = useState<Alert[]>([
    { id: "1", symbol: "AAPL", condition: "above", price: 150 },
    { id: "2", symbol: "GOOGL", condition: "below", price: 2700 },
  ])
  const [newAlert, setNewAlert] = useState<Omit<Alert, "id">>({
    symbol: "",
    condition: "above",
    price: 0,
  })
  const addAlert = () => {
    if (newAlert.symbol && newAlert.price > 0) {
      setAlerts([...alerts, { ...newAlert, id: Date.now().toString() }])
      setNewAlert({ symbol: "", condition: "above", price: 0 })
    }
  }
  const removeAlert = (id: string) => {
    setAlerts(alerts.filter((alert) => alert.id !== id))
  }
  return (
    <div className="space-y-4">
      <div className="flex space-x-2">
        <Input
          placeholder="Symbol"
          value={newAlert.symbol}
          onChange={(e) => setNewAlert({ ...newAlert, symbol: e.target.value })}
        />
        <Select
          value={newAlert.condition}
          onValueChange={(value: "above" | "below") => setNewAlert({ ...newAlert, condition: value })}
        >
          <SelectTrigger>
            <SelectValue placeholder="Condition" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="above">Above</SelectItem>
            <SelectItem value="below">Below</SelectItem>
          </SelectContent>
        </Select>
        <Input
          type="number"
          placeholder="Price"
          value={newAlert.price}
          onChange={(e) => setNewAlert({ ...newAlert, price: Number.parseFloat(e.target.value) })}
        />
        <Button onClick={addAlert}>Add Alert</Button>
      </div>
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Symbol</TableHead>
            <TableHead>Condition</TableHead>
            <TableHead>Price</TableHead>
            <TableHead>Action</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {alerts.map((alert) => (
            <TableRow key={alert.id}>
              <TableCell>{alert.symbol}</TableCell>
              <TableCell>{alert.condition}</TableCell>
              <TableCell>${alert.price.toFixed(2)}</TableCell>
              <TableCell>
                <Button variant="destructive" onClick={() => removeAlert(alert.id)}>
                  Remove
                </Button>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  )
}
</file>

<file path="components/watchlist-table.tsx">
"use client"
import { useState, useEffect } from "react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { ArrowUpRight, ArrowDownRight } from "lucide-react"
interface WatchlistItem {
  symbol: string
  price: number
  change: number
  changePercent: number
}
const mockWatchlistData: WatchlistItem[] = [
  { symbol: "AAPL", price: 150.25, change: 2.5, changePercent: 1.69 },
  { symbol: "GOOGL", price: 2750.8, change: -15.2, changePercent: -0.55 },
  { symbol: "MSFT", price: 305.15, change: 1.8, changePercent: 0.59 },
  { symbol: "AMZN", price: 3380.5, change: -22.3, changePercent: -0.66 },
  { symbol: "FB", price: 325.75, change: 5.2, changePercent: 1.62 },
]
export function WatchlistTable({ searchTerm }: { searchTerm: string }) {
  const [watchlistData, setWatchlistData] = useState<WatchlistItem[]>(mockWatchlistData)
  useEffect(() => {
    // In a real application, you would fetch the watchlist data here
    // and update it periodically
  }, [])
  const filteredData = watchlistData.filter((item) => item.symbol.toLowerCase().includes(searchTerm.toLowerCase()))
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Symbol</TableHead>
          <TableHead>Price</TableHead>
          <TableHead>Change</TableHead>
          <TableHead>Change %</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {filteredData.map((item) => (
          <TableRow key={item.symbol}>
            <TableCell className="font-medium">{item.symbol}</TableCell>
            <TableCell>${item.price.toFixed(2)}</TableCell>
            <TableCell>
              <Badge variant={item.change >= 0 ? "success" : "destructive"} className="flex items-center space-x-1">
                {item.change >= 0 ? <ArrowUpRight className="h-4 w-4" /> : <ArrowDownRight className="h-4 w-4" />}
                <span>${Math.abs(item.change).toFixed(2)}</span>
              </Badge>
            </TableCell>
            <TableCell>
              <Badge
                variant={item.changePercent >= 0 ? "success" : "destructive"}
                className="flex items-center space-x-1"
              >
                {item.changePercent >= 0 ? (
                  <ArrowUpRight className="h-4 w-4" />
                ) : (
                  <ArrowDownRight className="h-4 w-4" />
                )}
                <span>{Math.abs(item.changePercent).toFixed(2)}%</span>
              </Badge>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
</file>

<file path="components/weather-display.tsx">
interface WeatherDisplayProps {
  location: string
  currentTemp: number
  condition: string
  forecast: Array<{
    hour: string
    temp: number
  }>
}
export function WeatherDisplay({ location, currentTemp, condition, forecast }: WeatherDisplayProps) {
  return (
    <div className="rounded-lg bg-sky-100 dark:bg-sky-900 p-4 my-2">
      <div className="mb-4">
        <h3 className="text-lg font-semibold">{location}</h3>
        <div className="flex items-baseline gap-2">
          <span className="text-3xl font-bold">{currentTemp}°</span>
          <span className="text-sm text-muted-foreground">{condition}</span>
        </div>
      </div>
      <div className="flex gap-4 overflow-x-auto pb-2">
        {forecast.map((period) => (
          <div key={period.hour} className="text-center min-w-[60px]">
            <div className="text-sm text-muted-foreground">{period.hour}</div>
            <div className="font-medium">{period.temp}°</div>
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="hooks/use-media-query.ts">
"use client"
import { useState, useEffect } from "react"
export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false)
  useEffect(() => {
    const media = window.matchMedia(query)
    if (media.matches !== matches) {
      setMatches(media.matches)
    }
    const listener = () => setMatches(media.matches)
    media.addListener(listener)
    return () => media.removeListener(listener)
  }, [matches, query])
  return matches
}
</file>

<file path="hooks/use-mobile.tsx">
import * as React from "react"
const MOBILE_BREAKPOINT = 768
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])
  return !!isMobile
}
</file>

<file path="hooks/use-toast.ts">
"use client"
// Inspired by react-hot-toast library
import * as React from "react"
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"
const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000
type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const
let count = 0
function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}
type ActionType = typeof actionTypes
type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }
interface State {
  toasts: ToasterToast[]
}
const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()
const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)
  toastTimeouts.set(toastId, timeout)
}
export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }
    case "DISMISS_TOAST": {
      const { toastId } = action
      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}
const listeners: Array<(state: State) => void> = []
let memoryState: State = { toasts: [] }
function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}
type Toast = Omit<ToasterToast, "id">
function toast({ ...props }: Toast) {
  const id = genId()
  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })
  return {
    id: id,
    dismiss,
    update,
  }
}
function useToast() {
  const [state, setState] = React.useState<State>(memoryState)
  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])
  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}
export { useToast, toast }
</file>

<file path="lib/api/ai-researcher.ts">
import { EconomicData, Alert } from "@/types/ai-researcher"
import { mockEconomicData, mockAlerts } from "./mock-data"
export async function getEconomicData(): Promise<EconomicData> {
  // In a real application, this would fetch data from an API
  return mockEconomicData
}
type AlertCallback = (alert: Alert) => void
export function subscribeToAlerts(callback: AlertCallback): () => void {
  // Simulate real-time alerts every 30 seconds
  const intervalId = setInterval(() => {
    const randomAlert = mockAlerts[Math.floor(Math.random() * mockAlerts.length)]
    callback(randomAlert)
  }, 30000)
  return () => clearInterval(intervalId)
}
</file>

<file path="lib/api/api-client.ts">
import axios, { AxiosInstance, AxiosError } from 'axios';
// API response types
interface ApiResponse<T> {
  success: boolean;
  data: T;
  meta: {
    timestamp: number;
    cached?: boolean;
    source?: string;
  };
}
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    timestamp: number;
    cached?: boolean;
    source?: string;
  };
}
// Error types
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code: string = 'API_ERROR'
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
class ApiClient {
  private static instance: ApiClient;
  private client: AxiosInstance;
  private authToken: string | null = null;
  private constructor() {
    this.client = axios.create({
      baseURL: '/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    this.setupInterceptors();
  }
  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }
  private setupInterceptors() {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        if (this.authToken) {
          config.headers.Authorization = `Bearer ${this.authToken}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    // Response interceptor
    this.client.interceptors.response.use(
      (response) => response.data,
      (error: AxiosError) => {
        if (error.response) {
          const { status, data } = error.response;
          throw new ApiError(
            (data as any)?.error || 'An error occurred',
            status,
            (data as any)?.code
          );
        }
        throw new ApiError('Network error', 500);
      }
    );
  }
  setAuthToken(token: string) {
    this.authToken = token;
  }
  clearAuthToken() {
    this.authToken = null;
  }
  // Market Data endpoints
  async getMarketData(symbols: string[]): Promise<ApiResponse<Record<string, any>>> {
    return this.client.get('/market-data', { params: { symbols: symbols.join(',') } });
  }
  async getMarketDataBatch(symbols: string[]): Promise<ApiResponse<Record<string, any>>> {
    return this.client.post('/market-data', { symbols });
  }
  // Technical Indicators endpoints
  async getTechnicalIndicators(params: {
    symbol: string;
    indicator: string;
    period: number;
    startDate: string;
    endDate: string;
  }): Promise<ApiResponse<any[]>> {
    return this.client.post('/technical', params);
  }
  async getCommonIndicators(symbol: string): Promise<ApiResponse<any>> {
    return this.client.get('/technical', { params: { symbol } });
  }
  // News endpoints
  async getNews(params: {
    symbols?: string[];
    limit?: number;
    page?: number;
  }): Promise<PaginatedResponse<any>> {
    return this.client.get('/news', { params });
  }
  subscribeToNews(symbols?: string[]): EventSource {
    const params = new URLSearchParams();
    if (symbols) {
      params.set('symbols', symbols.join(','));
    }
    return new EventSource(`/api/news?${params.toString()}`);
  }
  // Company endpoints
  async getCompanyInfo(symbol: string): Promise<ApiResponse<any>> {
    return this.client.get('/company', { params: { symbol } });
  }
  async getCompanyInfoBatch(symbols: string[]): Promise<ApiResponse<Record<string, any>>> {
    return this.client.post('/company', { symbols });
  }
  // Search endpoints
  async searchTickers(params: {
    query: string;
    limit?: number;
    type?: string;
    market?: string;
    active?: boolean;
  }): Promise<PaginatedResponse<any>> {
    return this.client.get('/search', { params });
  }
  async advancedSearch(params: {
    query: string;
    limit?: number;
    type?: string;
    market?: string;
    active?: boolean;
    filters?: Record<string, any>;
  }): Promise<PaginatedResponse<any>> {
    return this.client.post('/search', params);
  }
  // WebSocket connection
  connectWebSocket(symbols: string[]): WebSocket {
    const ws = new WebSocket(`${window.location.origin.replace('http', 'ws')}/ws`);
    ws.onopen = () => {
      ws.send(JSON.stringify({
        action: 'subscribe',
        symbols,
      }));
    };
    return ws;
  }
}
export const apiClient = ApiClient.getInstance();
</file>

<file path="lib/api/asset-screener.ts">
import { ScreeningCriteria, Asset } from '@/types/asset-screener'
export async function screenAssets(criteria: ScreeningCriteria): Promise<Asset[]> {
  // Mock implementation
  return [
    {
      id: '1',
      symbol: 'AAPL',
      name: 'Apple Inc.',
      assetClass: 'stocks',
      price: 150.25,
      change: 2.5,
      score: 85,
      volume: 1000000,
      marketCap: 2500000000000,
      peRatio: 25.5,
    },
    // Add more mock assets as needed
  ]
}
export async function getRealtimeData(symbols: string[]): Promise<Record<string, Partial<Asset>>> {
  // Mock implementation
  return symbols.reduce((acc, symbol) => {
    acc[symbol] = {
      price: Math.random() * 1000,
      change: (Math.random() - 0.5) * 10,
      volume: Math.floor(Math.random() * 1000000),
    }
    return acc
  }, {} as Record<string, Partial<Asset>>)
}
</file>

<file path="lib/api/asset-search.ts">
import type { Asset, AssetDetails, NewsItem } from "@/types/asset"
import { polygonService } from './polygon-service'
import { formatDistanceToNow } from 'date-fns'
import { TickerDetails, AggregateBar, NewsItem as PolygonNewsItem } from '../../types/polygon'
// Cache for search results
const searchCache = new Map<string, {
  data: Asset[];
  timestamp: number;
}>();
const SEARCH_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
export async function searchAssets(query: string): Promise<Asset[]> {
  if (!query) return [];
  // Check cache first
  const cached = searchCache.get(query);
  if (cached && Date.now() - cached.timestamp < SEARCH_CACHE_DURATION) {
    return cached.data;
  }
  try {
    const response = await polygonService.searchTickers(query);
    const assets: Asset[] = response.results.map((ticker: TickerDetails) => ({
      id: ticker.ticker,
      symbol: ticker.ticker,
      name: ticker.name,
      assetClass: ticker.market.toLowerCase(),
      price: 0, // Will be updated with real-time data
      change: 0, // Will be updated with real-time data
      score: calculateAssetScore(ticker),
    }));
    // Update cache
    searchCache.set(query, {
      data: assets,
      timestamp: Date.now(),
    });
    return assets;
  } catch (error) {
    console.error('Error searching assets:', error);
    return [];
  }
}
export async function getAssetDetails(symbol: string): Promise<AssetDetails> {
  try {
    const [details, quote, news] = await Promise.all([
      polygonService.getTickerDetails(symbol),
      polygonService.getLastQuote(symbol),
      polygonService.getMarketNews(symbol, 5),
    ]);
    const tickerDetails = details.results;
    const lastQuote = quote.results;
    // Get related assets based on similar market cap range
    const relatedAssets = await getRelatedAssets(tickerDetails.market_cap);
    return {
      name: tickerDetails.name,
      description: tickerDetails.description || 'No description available.',
      sector: 'Technology', // Note: Basic tier doesn't provide sector info
      industry: 'Technology', // Note: Basic tier doesn't provide industry info
      marketCap: tickerDetails.market_cap || 0,
      peRatio: 0, // Note: Would need additional API calls for this data
      dividendYield: 0, // Note: Would need additional API calls for this data
      beta: 0, // Note: Would need additional API calls for this data
      eps: 0, // Note: Would need additional API calls for this data
      high52Week: 0, // Note: Would need additional API calls for this data
      low52Week: 0, // Note: Would need additional API calls for this data
      volume: 0,
      price: (lastQuote.P + lastQuote.p) / 2, // Midpoint of bid/ask
      relatedAssets,
      newsItems: news.results.map((item: PolygonNewsItem) => ({
        id: item.id,
        title: item.title,
        summary: item.description || 'No summary available.',
        url: item.article_url,
        publishedAt: item.published_utc,
        source: item.publisher.name,
      })),
    };
  } catch (error) {
    console.error('Error fetching asset details:', error);
    throw new Error('Failed to fetch asset details');
  }
}
export async function getAssetChartData(symbol: string, timeframe: string) {
  try {
    let multiplier = 1;
    let timespan: 'minute' | 'hour' | 'day' = 'day';
    let fromDate = new Date();
    // Configure timeframe parameters
    switch (timeframe) {
      case '1D':
        timespan = 'minute';
        multiplier = 5;
        fromDate.setDate(fromDate.getDate() - 1);
        break;
      case '1W':
        timespan = 'hour';
        multiplier = 1;
        fromDate.setDate(fromDate.getDate() - 7);
        break;
      case '1M':
        timespan = 'day';
        multiplier = 1;
        fromDate.setMonth(fromDate.getMonth() - 1);
        break;
      case '3M':
        timespan = 'day';
        multiplier = 1;
        fromDate.setMonth(fromDate.getMonth() - 3);
        break;
      case '1Y':
        timespan = 'day';
        multiplier = 1;
        fromDate.setFullYear(fromDate.getFullYear() - 1);
        break;
      default:
        timespan = 'day';
        multiplier = 1;
        fromDate.setFullYear(fromDate.getFullYear() - 5);
    }
    const response = await polygonService.getAggregates(
      symbol,
      multiplier,
      timespan,
      fromDate.toISOString().split('T')[0],
      new Date().toISOString().split('T')[0]
    );
    return response.results.map((bar: AggregateBar) => ({
      date: new Date(bar.t).toISOString().split('T')[0],
      price: bar.c,
    }));
  } catch (error) {
    console.error('Error fetching chart data:', error);
    throw new Error('Failed to fetch chart data');
  }
}
async function getRelatedAssets(marketCap: number): Promise<Asset[]> {
  try {
    // Get stocks in similar market cap range
    const response = await polygonService.searchTickers('', 5);
    return response.results.map((ticker: TickerDetails) => ({
      id: ticker.ticker,
      symbol: ticker.ticker,
      name: ticker.name,
      assetClass: ticker.market.toLowerCase(),
      price: 0,
      change: 0,
      score: calculateAssetScore(ticker),
    }));
  } catch (error) {
    console.error('Error fetching related assets:', error);
    return [];
  }
}
function calculateAssetScore(ticker: TickerDetails): number {
  // Basic scoring based on available metrics
  let score = 75; // Base score
  if (ticker.market_cap && ticker.market_cap > 1e11) score += 10; // Large cap bonus
  if (ticker.active) score += 5; // Active trading bonus
  if (ticker.primary_exchange === 'XNAS' || ticker.primary_exchange === 'XNYS') score += 5; // Major exchange bonus
  return Math.min(100, Math.max(0, score)); // Ensure score is between 0 and 100
}
</file>

<file path="lib/api/backtesting.ts">
import { BacktestParameters, BacktestResults, Strategy, StrategyParameters } from "@/types/backtesting"
export async function runBacktest(params: BacktestParameters): Promise<BacktestResults> {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000))
  // Generate mock backtest results
  const dates = Array.from({ length: 180 }, (_, i) => {
    const date = new Date(params.startDate)
    date.setDate(date.getDate() + i)
    return date.toISOString().split('T')[0]
  })
  const returns = dates.map(() => (Math.random() - 0.48) * 2) // Slightly positive bias
  const cumulativeReturns = returns.reduce((acc, curr) => [...acc, (acc[acc.length - 1] || 1) * (1 + curr)], [] as number[])
  return {
    returns,
    dates,
    metrics: {
      totalReturn: (cumulativeReturns[cumulativeReturns.length - 1] - 1) * 100,
      annualizedReturn: 12.3,
      sharpeRatio: 1.8,
      maxDrawdown: -15.2,
      volatility: 18.5
    },
    trades: [
      {
        date: dates[10],
        type: "buy",
        asset: params.assets[0],
        price: 150.25,
        quantity: 100
      },
      {
        date: dates[50],
        type: "sell",
        asset: params.assets[0],
        price: 165.50,
        quantity: 50
      },
      {
        date: dates[90],
        type: "buy",
        asset: params.assets[1],
        price: 280.75,
        quantity: 75
      },
      {
        date: dates[130],
        type: "sell",
        asset: params.assets[1],
        price: 295.25,
        quantity: 75
      }
    ]
  }
}
export async function optimizeStrategy(
  strategy: Strategy,
  initialParameters: StrategyParameters
): Promise<StrategyParameters> {
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 2000))
  // Return slightly modified parameters to simulate optimization
  return Object.entries(initialParameters).reduce((acc, [key, value]) => ({
    ...acc,
    [key]: value * (1 + (Math.random() - 0.5) * 0.2) // Adjust by ±10%
  }), {} as StrategyParameters)
}
function generateMockPerformanceData() {
  const startDate = new Date("2022-01-01")
  const data = []
  let strategyValue = 100
  let benchmarkValue = 100
  for (let i = 0; i < 365; i++) {
    const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000)
    strategyValue *= 1 + (Math.random() - 0.5) * 0.02
    benchmarkValue *= 1 + (Math.random() - 0.5) * 0.015
    data.push({
      date: date.toISOString().split("T")[0],
      strategy: strategyValue,
      benchmark: benchmarkValue,
    })
  }
  return data
}
</file>

<file path="lib/api/brokerage.ts">
import { toast } from "@/components/ui/use-toast"
interface OrderParams {
  type: "market" | "limit"
  quantity: number
  limitPrice?: number
  symbol: string
}
export async function executeOrder(params: OrderParams): Promise<boolean> {
  try {
    // In a real-world scenario, this would be an API call to your brokerage
    const response = await fetch("/api/execute-order", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(params),
    })
    if (!response.ok) {
      throw new Error("Failed to execute order")
    }
    const result = await response.json()
    toast({
      title: "Order Executed",
      description: `Successfully placed a ${params.type} order for ${params.quantity} shares of ${params.symbol}`,
    })
    return true
  } catch (error) {
    console.error("Error executing order:", error)
    toast({
      title: "Order Execution Failed",
      description: "There was an error executing your order. Please try again.",
      variant: "destructive",
    })
    return false
  }
}
</file>

<file path="lib/api/due-diligence.ts">
import type { DueDiligenceData } from "@/types/due-diligence"
export async function performDueDiligence(ticker: string): Promise<DueDiligenceData> {
  // TODO: Implement actual API call to due diligence service
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        secFilings: [
          { type: "10-K", date: "2023-02-15", keyInsights: "Strong revenue growth", sentiment: "Positive" },
          { type: "10-Q", date: "2023-05-01", keyInsights: "Increased R&D spending", sentiment: "Neutral" },
        ],
        financialStatements: {
          keyMetrics: {
            Revenue: { value: "$365.8B", yoyChange: "+8.2%" },
            "Net Income": { value: "$94.7B", yoyChange: "+5.4%" },
            EPS: { value: "$6.15", yoyChange: "+9.1%" },
          },
          revenueEarningsTrend: [
            { year: "2019", revenue: 260.2, earnings: 55.3 },
            { year: "2020", revenue: 274.5, earnings: 57.4 },
            { year: "2021", revenue: 365.8, earnings: 94.7 },
            { year: "2022", revenue: 394.3, earnings: 99.8 },
          ],
        },
        earningsCalls: {
          keyTakeaways: [
            "Expansion into emerging markets",
            "Launch of new product line in Q3",
            "Cost-cutting measures implemented",
          ],
          sentiment: "Positive",
          notableQuotes: [
            "We're excited about our growth prospects in the coming year.",
            "Our focus on innovation continues to drive our success.",
          ],
        },
        insiderTransactions: {
          transactions: [
            { date: "2023-06-01", insider: "John Doe (CEO)", type: "Buy", shares: 10000, value: 1500000 },
            { date: "2023-05-15", insider: "Jane Smith (CFO)", type: "Sell", shares: 5000, value: 750000 },
          ],
          aiAnalysis: "Recent insider buying activity suggests confidence in the company's future prospects.",
        },
        valuation: {
          dcf: {
            intrinsicValue: 180.25,
            currentPrice: 165.3,
            upside: 9.04,
          },
          evEbitda: {
            companyRatio: 15.2,
            industryAverage: 18.5,
            valuation: "Undervalued",
          },
          peerBenchmarking: {
            "P/E Ratio": { company: 28.5, peerAverage: 32.1, valuation: "Undervalued" },
            "P/B Ratio": { company: 35.9, peerAverage: 33.2, valuation: "Overvalued" },
            "P/S Ratio": { company: 7.8, peerAverage: 8.2, valuation: "Undervalued" },
          },
        },
        earningsManipulation: {
          overallRisk: "Low",
          overallAssessment: "No significant signs of earnings manipulation detected.",
          riskFactors: [
            { name: "Revenue Recognition", risk: "Low", description: "Consistent with industry standards" },
            { name: "Accruals Quality", risk: "Medium", description: "Slightly higher than peer average" },
            {
              name: "Cash Flow vs. Earnings",
              risk: "Low",
              description: "Strong correlation between cash flow and reported earnings",
            },
          ],
          redFlags: [],
        },
        aiReport: {
          hedgeFund: "<h2>Executive Summary</h2><p>AAPL presents a compelling investment opportunity...</p>",
          retail: "<h2>Should You Buy AAPL?</h2><p>Apple continues to demonstrate strong financial performance...</p>",
          institutional:
            "<h2>AAPL: Long-term Growth Prospects</h2><p>Our analysis indicates that Apple is well-positioned...</p>",
        },
      })
    }, 2000)
  })
}
</file>

<file path="lib/api/economic-calendar.ts">
interface EconomicEvent {
  id: string
  date: string
  time: string
  currency: string
  event: string
  importance: "low" | "medium" | "high"
  actual: string
  forecast: string
  previous: string
}
interface GetEconomicEventsParams {
  from: Date
  to: Date
  importance?: string
}
export async function getEconomicEvents({ from, to, importance }: GetEconomicEventsParams): Promise<EconomicEvent[]> {
  // TODO: Replace with actual API call
  // This is a mock implementation
  const mockEvents: EconomicEvent[] = [
    {
      id: "1",
      date: "2024-03-15",
      time: "08:30",
      currency: "USD",
      event: "US Initial Jobless Claims",
      importance: "high",
      actual: "260K",
      forecast: "261K",
      previous: "259K"
    },
    {
      id: "2",
      date: "2024-03-15",
      time: "12:30",
      currency: "EUR",
      event: "ECB Interest Rate Decision",
      importance: "high",
      actual: "3.50%",
      forecast: "3.50%",
      previous: "3.25%"
    },
    {
      id: "3",
      date: "2024-03-16",
      time: "04:00",
      currency: "CNY",
      event: "China Industrial Production YoY",
      importance: "medium",
      actual: "3.6%",
      forecast: "3.6%",
      previous: "5.6%"
    },
    {
      id: "4",
      date: "2024-03-16",
      time: "08:30",
      currency: "USD",
      event: "US Retail Sales MoM",
      importance: "high",
      actual: "0.2%",
      forecast: "0.2%",
      previous: "0.4%"
    },
    {
      id: "5",
      date: "2024-03-17",
      time: "10:00",
      currency: "EUR",
      event: "Eurozone CPI YoY",
      importance: "high",
      actual: "6.1%",
      forecast: "6.1%",
      previous: "7.0%"
    }
  ]
  // Filter events based on date range and importance
  return mockEvents.filter(event => {
    const eventDate = new Date(event.date)
    const isInDateRange = eventDate >= from && eventDate <= to
    const matchesImportance = !importance || importance === "all" || event.importance === importance
    return isInDateRange && matchesImportance
  })
}
</file>

<file path="lib/api/economic-events.ts">
import type { EconomicEventData } from "@/types/economic-events"
export async function getEconomicEvents(): Promise<EconomicEventData> {
  // TODO: Implement actual API call to fetch economic event data
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        upcomingEvents: [
          {
            date: "2023-06-15",
            name: "Federal Reserve Interest Rate Decision",
            country: "USA",
            impact: "High",
            previous: "5.00%",
            forecast: "5.25%",
          },
          {
            date: "2023-06-16",
            name: "Bank of Japan Policy Rate",
            country: "Japan",
            impact: "Medium",
            previous: "-0.10%",
            forecast: "-0.10%",
          },
          {
            date: "2023-06-17",
            name: "EU Inflation Rate",
            country: "EU",
            impact: "High",
            previous: "7.0%",
            forecast: "6.8%",
          },
          // Add more events...
        ],
        highImpactEvents: [
          {
            name: "Federal Reserve Interest Rate Decision",
            date: "2023-06-15",
            marketImplications: {
              direction: "up",
              description: "Potential strengthening of USD, impact on bond yields",
            },
            affectedSectors: ["Financials", "Real Estate", "Utilities"],
          },
          {
            name: "EU Inflation Rate",
            date: "2023-06-17",
            marketImplications: {
              direction: "down",
              description: "Possible pressure on EUR, impact on consumer goods",
            },
            affectedSectors: ["Consumer Staples", "Consumer Discretionary", "Retail"],
          },
          // Add more high-impact events...
        ],
        aiRecommendations: [
          {
            asset: "EUR/USD",
            type: "Sell",
            recommendation: "Short EUR/USD ahead of EU Inflation Rate announcement",
            rationale: "Expected higher-than-forecast inflation may lead to EUR weakness",
            timeHorizon: "Short-term (1-3 days)",
          },
          {
            asset: "US 10Y Treasury Yield",
            type: "Buy",
            recommendation: "Long position on US 10Y Treasury Yield",
            rationale: "Anticipated rate hike may lead to increased bond yields",
            timeHorizon: "Medium-term (1-2 weeks)",
          },
          // Add more AI recommendations...
        ],
        economicTrends: [
          {
            name: "Rising Inflation in Developed Economies",
            direction: "up",
            duration: "6-12 months",
            confidence: 80,
            opportunities: [
              "Short positions on government bonds",
              "Long positions on commodities as inflation hedge",
              "Defensive stocks in consumer staples sector",
            ],
          },
          {
            name: "Global Supply Chain Disruptions",
            direction: "up",
            duration: "3-6 months",
            confidence: 75,
            opportunities: [
              "Long positions on domestic manufacturing companies",
              "Short positions on companies heavily reliant on imports",
              "Investments in logistics and transportation sector",
            ],
          },
          // Add more economic trends...
        ],
      })
    }, 1000)
  })
}
</file>

<file path="lib/api/financial-heatmap.ts">
interface HeatmapData {
  symbol: string
  name: string
  sector: string
  value: number
  change: number
}
export async function getHeatmapData(metric: string, timeframe: string): Promise<HeatmapData[]> {
  // TODO: Replace with actual API call
  // This is a mock implementation
  return [
    {
      symbol: "AAPL",
      name: "Apple Inc.",
      sector: "Technology",
      value: 75,
      change: 2.5
    },
    {
      symbol: "MSFT",
      name: "Microsoft Corporation",
      sector: "Technology",
      value: 82,
      change: 1.8
    },
    {
      symbol: "GOOGL",
      name: "Alphabet Inc.",
      sector: "Technology",
      value: 68,
      change: -0.5
    },
    {
      symbol: "AMZN",
      name: "Amazon.com Inc.",
      sector: "Consumer Cyclical",
      value: 71,
      change: 1.2
    },
    {
      symbol: "NVDA",
      name: "NVIDIA Corporation",
      sector: "Technology",
      value: 90,
      change: 4.2
    },
    {
      symbol: "META",
      name: "Meta Platforms Inc.",
      sector: "Technology",
      value: 65,
      change: -1.5
    },
    {
      symbol: "TSLA",
      name: "Tesla Inc.",
      sector: "Automotive",
      value: 45,
      change: -3.2
    },
    {
      symbol: "JPM",
      name: "JPMorgan Chase & Co.",
      sector: "Financial Services",
      value: 58,
      change: 0.8
    },
    {
      symbol: "V",
      name: "Visa Inc.",
      sector: "Financial Services",
      value: 62,
      change: 1.1
    }
  ]
}
type UpdateCallback = (update: {
  sectorId: string
  value: number
  aiInsights?: string
  alert?: string
}) => void
export function subscribeToRealtimeUpdates(callback: UpdateCallback): () => void {
  const intervalId = setInterval(() => {
    const update = {
      sectorId: ["technology", "healthcare", "financials"][Math.floor(Math.random() * 3)],
      value: Math.random() * 100,
      aiInsights: `Updated AI insight for ${["Technology", "Healthcare", "Financials"][Math.floor(Math.random() * 3)]}`,
      alert:
        Math.random() < 0.2
          ? `Unusual activity detected in ${["Technology", "Healthcare", "Financials"][Math.floor(Math.random() * 3)]} sector`
          : undefined,
    }
    callback(update)
  }, 5000) // Send updates every 5 seconds
  return () => clearInterval(intervalId)
}
</file>

<file path="lib/api/mock-data.ts">
import { EconomicData, ResearchReport, Alert } from "@/types/ai-researcher"
export const mockEconomicData: EconomicData = {
  gdpGrowth: 2.4,
  gdpGrowthChange: 0.3,
  inflation: 3.1,
  inflationChange: -0.2,
  interestRate: 5.25,
  interestRateChange: 0,
  unemploymentRate: 3.7,
  unemploymentRateChange: -0.1,
  riskAssessment: {
    recessionRisk: 35,
    marketVolatility: 28,
    creditRisk: 42,
    liquidityRisk: 15
  },
  economicCycle: Array.from({ length: 12 }, (_, i) => ({
    date: new Date(2023, i, 1).toISOString().split('T')[0],
    value: 100 + Math.sin(i / 2) * 10,
    phase: ['Expansion', 'Peak', 'Contraction', 'Trough'][Math.floor(i / 3)]
  })),
  geopoliticalRisk: {
    trends: [
      {
        name: "Global Trade Relations",
        impact: "positive",
        description: "Improving international trade relationships and reduced tariffs"
      },
      {
        name: "Regional Conflicts",
        impact: "negative",
        description: "Ongoing geopolitical tensions affecting market stability"
      },
      {
        name: "Policy Changes",
        impact: "neutral",
        description: "New regulatory frameworks being implemented globally"
      }
    ]
  },
  researchReports: [
    {
      id: "1",
      title: "Global Market Outlook 2024",
      summary: "Analysis of major market trends and opportunities",
      category: "Market Analysis",
      content: "Detailed analysis of global market trends...",
      date: "2024-02-01",
      author: "AI Research Team"
    },
    {
      id: "2",
      title: "Emerging Technologies Impact",
      summary: "How AI and blockchain are reshaping finance",
      category: "Technology",
      content: "In-depth review of technological advancements...",
      date: "2024-02-05",
      author: "AI Research Team"
    },
    {
      id: "3",
      title: "ESG Investment Trends",
      summary: "Sustainable investing in the current market",
      category: "ESG",
      content: "Comprehensive analysis of ESG trends...",
      date: "2024-02-10",
      author: "AI Research Team"
    }
  ]
}
export const mockAlerts: Alert[] = [
  {
    title: "GDP Growth Projection Updated",
    description: "Q1 2024 GDP growth projections revised upward by 0.3%"
  },
  {
    title: "Inflation Alert",
    description: "Core inflation shows signs of moderation"
  },
  {
    title: "Market Volatility Warning",
    description: "VIX index showing increased market uncertainty"
  }
]
</file>

<file path="lib/api/polygon-client.ts">
import { WebSocketMessage, TradeMessage, QuoteMessage, AggregateMessage } from '@/types/polygon';
class PolygonClient {
  private static instance: PolygonClient | null = null;
  private ws: WebSocket | null = null;
  private subscribers: Map<string, Set<(data: any) => void>> = new Map();
  private connected: boolean = false;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelay: number = 1000;
  private pingInterval: number | null = null;
  private wsUrl: string = 'wss://delayed.polygon.io/stocks';
  private constructor() {
    // Empty constructor
  }
  public static getInstance(): PolygonClient {
    if (typeof window === 'undefined') {
      // Create a proper dummy instance during SSR
      const dummy = new PolygonClient();
      dummy.connected = false;
      return dummy;
    }
    if (!PolygonClient.instance) {
      PolygonClient.instance = new PolygonClient();
    }
    return PolygonClient.instance;
  }
  private async initializeWebSocket() {
    try {
      // Get WebSocket authentication details from our server
      const response = await fetch(window.location.origin + '/api/polygon-stocks/websocket');
      if (!response.ok) {
        throw new Error('Failed to get WebSocket authentication');
      }
      const { token, wsUrl } = await response.json();
      // Use the provided wsUrl or fall back to default
      this.wsUrl = wsUrl || this.wsUrl;
      this.ws = new WebSocket(this.wsUrl);
      this.setupWebSocketHandlers(token);
    } catch (error) {
      console.error('Failed to initialize WebSocket:', error);
      this.emit('error', new Error('WebSocket initialization failed'));
    }
  }
  private setupWebSocketHandlers(token: string) {
    if (!this.ws) return;
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.connected = true;
      this.authenticate(token);
      this.resetReconnectAttempts();
      this.setupPing();
      this.emit('status', 'connected');
    };
    this.ws.onmessage = (event) => {
      try {
        const messages = JSON.parse(event.data);
        // Handle both single messages and arrays of messages
        const messageArray = Array.isArray(messages) ? messages : [messages];
        messageArray.forEach(msg => {
          if (msg.ev === 'status') {
            this.handleStatus(msg);
          } else {
            this.handleMessage(msg);
          }
        });
      } catch (error) {
        console.error('Error parsing WebSocket message:', error);
      }
    };
    this.ws.onclose = (event) => {
      console.log('WebSocket disconnected', event.code, event.reason);
      this.connected = false;
      this.cleanup();
      this.emit('status', 'disconnected');
      this.attemptReconnect();
    };
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.emit('error', new Error('WebSocket connection error'));
    };
  }
  private authenticate(token: string) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      // Send authentication message
      this.ws.send(JSON.stringify({
        action: 'auth',
        params: token
      }));
    }
  }
  private handleMessage(message: WebSocketMessage) {
    switch (message.ev) {
      case 'A':
        // Handle aggregate message
        this.emit('aggregate', {
          ev: 'AM',
          sym: message.sym,
          v: message.v,  // volume
          o: message.o,  // open price
          c: message.c,  // close price
          h: message.h,  // high price
          l: message.l,  // low price
          t: message.t,  // timestamp
          n: message.n   // number of trades
        });
        break;
      case 'T':
        this.emit('trade', message as TradeMessage);
        break;
      case 'Q':
        this.emit('quote', message as QuoteMessage);
        break;
    }
  }
  private handleStatus(message: any) {
    if (message.status === 'auth_success') {
      console.log('Authentication successful');
      this.emit('status', 'authenticated');
      // After successful authentication, subscribe to all aggregates
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({
          action: 'subscribe',
          params: 'A.*'
        }));
      }
    } else if (message.status === 'auth_failed') {
      console.error('Authentication failed:', message.message);
      this.emit('error', new Error(`Authentication failed: ${message.message}`));
    }
  }
  private emit(event: string, data: any) {
    const subscribers = this.subscribers.get(event);
    if (subscribers) {
      subscribers.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in subscriber callback for event ${event}:`, error);
        }
      });
    }
  }
  public subscribe(event: string, callback: (data: any) => void) {
    if (!this.subscribers.has(event)) {
      this.subscribers.set(event, new Set());
    }
    this.subscribers.get(event)?.add(callback);
    // Initialize WebSocket if not already connected
    if (!this.connected) {
      this.initializeWebSocket();
    }
  }
  public unsubscribe(event: string, callback: (data: any) => void) {
    const subscribers = this.subscribers.get(event);
    if (subscribers) {
      subscribers.delete(callback);
      if (subscribers.size === 0) {
        this.subscribers.delete(event);
      }
    }
  }
  private resetReconnectAttempts() {
    this.reconnectAttempts = 0;
  }
  private attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
      console.log(`Attempting reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);
      setTimeout(() => this.initializeWebSocket(), delay);
    } else {
      console.error('Max reconnection attempts reached');
      this.emit('error', new Error('Max reconnection attempts reached'));
    }
  }
  private setupPing() {
    this.pingInterval = window.setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send('ping');
      }
    }, 30000);
  }
  private cleanup() {
    if (this.pingInterval) {
      window.clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }
  public disconnect() {
    this.cleanup();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.connected = false;
  }
  public isConnected(): boolean {
    return this.connected && this.ws?.readyState === WebSocket.OPEN;
  }
  public connect() {
    if (!this.connected) {
      this.initializeWebSocket();
    }
  }
}
export const polygonClient = PolygonClient.getInstance();
</file>

<file path="lib/api/polygon-service.ts">
import axios, { AxiosError, AxiosInstance } from 'axios';
import { z } from 'zod';
import { PolygonWebSocket } from './polygon-websocket';
import { AggregateMessage } from '@/types/polygon';
import { RateLimiter } from '../utils/rate-limiter';
import { cacheManager, CACHE_KEYS } from '../utils/cache-manager';
import { DataTransformer, ValidationError, NewsItemSchema } from '../utils/data-validator';
const POLYGON_BASE_URL = 'https://api.polygon.io';
const POLYGON_WS_URL = 'wss://delayed.polygon.io/stocks';
// Rate limiting configuration
const RATE_LIMIT = {
  REST: {
    REQUESTS_PER_MINUTE: 5,
    BURST_SIZE: 10,
  },
  WEBSOCKET: {
    MAX_SUBSCRIPTIONS: 100,
    SUBSCRIPTION_BATCH_SIZE: 20,
    SUBSCRIPTION_BATCH_DELAY: 1000, // 1 second between batches
  },
};
// Retry configuration
const RETRY_CONFIG = {
  MAX_RETRIES: 3,
  INITIAL_DELAY: 1000,
  MAX_DELAY: 10000,
  BACKOFF_FACTOR: 2,
};
// Error types for better error handling
export class PolygonError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'PolygonError';
  }
}
export class RateLimitError extends PolygonError {
  constructor(message: string) {
    super(message, 429, true);
    this.name = 'RateLimitError';
  }
}
export class AuthenticationError extends PolygonError {
  constructor(message: string) {
    super(message, 401, false);
    this.name = 'AuthenticationError';
  }
}
// Validation schemas for API responses
const AggregateBarSchema = z.object({
  c: z.number(), // close price
  h: z.number(), // high price
  l: z.number(), // low price
  o: z.number(), // open price
  v: z.number(), // volume
  vw: z.number(), // volume weighted average price
  t: z.number(), // timestamp
});
const AggregatesResponseSchema = z.object({
  ticker: z.string(),
  queryCount: z.number(),
  resultsCount: z.number(),
  adjusted: z.boolean(),
  results: z.array(AggregateBarSchema),
  status: z.string(),
  request_id: z.string(),
  count: z.number(),
});
// Types based on validation schemas
export type AggregateBar = z.infer<typeof AggregateBarSchema>;
export type AggregatesResponse = z.infer<typeof AggregatesResponseSchema>;
export interface TimeRange {
  from: Date;
  to: Date;
}
// Helper interface for market data properties
interface MarketData {
  o: number;
  h: number;
  l: number;
  c: number;
  v: number;
  vw: number;
}
interface SnapshotTicker {
  ticker: string;
  day?: MarketData;
  lastTrade?: {
    p: number;
    s: number;
    t: number;
    c: number[];
  };
  min?: {
    av: number;
    vw: number;
    o: number;
    c: number;
    h: number;
    l: number;
    v: number;
    t: number;
  };
  prevDay?: MarketData;
  todaysChange?: number;
  todaysChangePerc?: number;
  updated: number;
}
interface SnapshotResponse {
  status: string;
  tickers: SnapshotTicker[];
}
export interface TechnicalIndicatorsResponse {
  status: string;
  results: {
    underlying: {
      aggregates: AggregatesResponse['results'];
    };
    values: {
      timestamp: number;
      value: number;
    }[];
  };
}
export class PolygonService {
  private static instance: PolygonService;
  private apiKey: string;
  private baseUrl: string;
  private wsUrl: string;
  private webSocket: PolygonWebSocket;
  private subscribers: Map<string, Set<(data: any) => void>> = new Map();
  private axiosInstance: AxiosInstance;
  private rateLimiter: RateLimiter;
  private retryCount: Map<string, number> = new Map();
  private constructor() {
    if (typeof window !== 'undefined') {
      throw new Error('PolygonService cannot be instantiated on the client side');
    }
    const apiKey = process.env.POLYGON_API_KEY;
    if (!apiKey) {
      throw new Error('POLYGON_API_KEY environment variable is not set');
    }
    this.apiKey = apiKey;
    this.baseUrl = POLYGON_BASE_URL;
    this.wsUrl = POLYGON_WS_URL;
    this.webSocket = new PolygonWebSocket();
    // Initialize axios instance with interceptors
    this.axiosInstance = axios.create({
      baseURL: this.baseUrl,
      timeout: 10000,
    });
    // Initialize rate limiter
    this.rateLimiter = new RateLimiter({
      tokensPerInterval: RATE_LIMIT.REST.REQUESTS_PER_MINUTE,
      interval: 60000, // 1 minute
      burstSize: RATE_LIMIT.REST.BURST_SIZE,
    });
    this.setupAxiosInterceptors();
    this.setupWebSocket();
  }
  public static getInstance(): PolygonService {
    if (!PolygonService.instance) {
      PolygonService.instance = new PolygonService();
    }
    return PolygonService.instance;
  }
  private setupAxiosInterceptors() {
    // Request interceptor for API key and rate limiting
    this.axiosInstance.interceptors.request.use(async (config) => {
      // Wait for rate limiter token
      await this.rateLimiter.waitForToken();
      // Add API key to query parameters
      const params = new URLSearchParams(config.params || {});
      params.append('apiKey', this.apiKey);
      config.params = params;
      return config;
    });
    // Response interceptor for error handling
    this.axiosInstance.interceptors.response.use(
      (response) => response,
      async (error: AxiosError<{ message?: string }>) => {
        if (!error.config) throw error;
        const endpoint = error.config.url || 'unknown';
        const retryCount = this.retryCount.get(endpoint) || 0;
        // Handle different error types
        if (error.response?.status === 429) {
          throw new RateLimitError('Rate limit exceeded');
        }
        if (error.response?.status === 401) {
          throw new AuthenticationError('Invalid API key');
        }
        // Determine if we should retry
        const shouldRetry = 
          retryCount < RETRY_CONFIG.MAX_RETRIES &&
          (error.response?.status === 503 || // Service unavailable
           error.response?.status === 504 || // Gateway timeout
           !error.response); // Network error
        if (shouldRetry) {
          this.retryCount.set(endpoint, retryCount + 1);
          const delay = Math.min(
            RETRY_CONFIG.INITIAL_DELAY * Math.pow(RETRY_CONFIG.BACKOFF_FACTOR, retryCount),
            RETRY_CONFIG.MAX_DELAY
          );
          await new Promise(resolve => setTimeout(resolve, delay));
          return this.axiosInstance(error.config);
        }
        throw new PolygonError(
          `Polygon API error: ${error.response?.data?.message || error.message}`,
          error.response?.status
        );
      }
    );
  }
  private setupWebSocket() {
    this.webSocket.on('aggregate', (data: AggregateMessage) => {
      const subscribers = this.subscribers.get(data.sym);
      if (subscribers) {
        subscribers.forEach(callback => callback(data));
      }
    });
    this.webSocket.on('error', (error: Error) => {
      console.error('WebSocket error:', error);
      // Notify all subscribers about the error
      this.subscribers.forEach(subscribers => {
        subscribers.forEach(callback => callback({ type: 'error', error }));
      });
    });
    this.webSocket.on('status', (status: string) => {
      // Notify all subscribers about the status change
      this.subscribers.forEach(subscribers => {
        subscribers.forEach(callback => callback({ type: 'status', status }));
      });
    });
  }
  public subscribe(symbol: string, callback: (data: any) => void) {
    if (!this.subscribers.has(symbol)) {
      this.subscribers.set(symbol, new Set());
      this.webSocket.subscribe(symbol);
    }
    this.subscribers.get(symbol)?.add(callback);
  }
  public unsubscribe(symbol: string, callback: (data: any) => void) {
    const subscribers = this.subscribers.get(symbol);
    if (subscribers) {
      subscribers.delete(callback);
      if (subscribers.size === 0) {
        this.subscribers.delete(symbol);
        this.webSocket.unsubscribe(symbol);
      }
    }
  }
  public connect() {
    this.webSocket.connect();
  }
  public disconnect() {
    this.webSocket.disconnect();
  }
  public isConnected(): boolean {
    return this.webSocket.isConnected();
  }
  private async fetch<T>(endpoint: string, params: Record<string, string> = {}): Promise<T> {
    try {
      const response = await this.axiosInstance.get(endpoint, { params });
      return response.data;
    } catch (error) {
      if (error instanceof PolygonError) {
        throw error;
      }
      throw new PolygonError('Unknown error occurred while fetching data');
    }
  }
  private async fetchWithCache<T>(
    endpoint: string,
    cacheKey: string,
    cachePrefix: keyof typeof CACHE_KEYS,
    params: Record<string, string> = {},
    options: {
      ttl?: number;
      tags?: string[];
      transform?: (data: unknown) => T;
    } = {}
  ): Promise<T> {
    try {
      // Try to get from cache first
      const cachedData = await cacheManager.get<T>(cacheKey, cachePrefix);
      if (cachedData) {
        return cachedData;
      }
      // If not in cache, fetch from API
      const response = await this.fetch<unknown>(endpoint, params);
      // Transform data if transformer provided
      const data = options.transform ? options.transform(response) : (response as T);
      // Cache the result
      await cacheManager.set(cacheKey, data, cachePrefix, {
        ttl: options.ttl,
        source: 'rest',
        tags: options.tags,
      });
      return data;
    } catch (error) {
      if (error instanceof ValidationError) {
        // If validation fails, invalidate cache and throw
        await cacheManager.invalidate(cacheKey, cachePrefix);
      }
      throw error;
    }
  }
  async getAggregates(
    ticker: string,
    multiplier: number,
    timespan: string,
    from: string,
    to: string,
    adjusted: boolean = true
  ): Promise<AggregatesResponse> {
    const endpoint = `/v2/aggs/ticker/${ticker}/range/${multiplier}/${timespan}/${from}/${to}`;
    const cacheKey = `${ticker}:${multiplier}:${timespan}:${from}:${to}:${adjusted}`;
    return this.fetchWithCache<AggregatesResponse>(
      endpoint,
      cacheKey,
      'AGGREGATE_DATA',
      { adjusted: adjusted.toString() },
      {
        ttl: 60000, // 1 minute cache for aggregates
        tags: ['aggregates', ticker],
        transform: (data) => AggregatesResponseSchema.parse(data),
      }
    );
  }
  async getSnapshots(tickers: string[]): Promise<SnapshotResponse> {
    // Split large requests into batches
    const batchSize = 100;
    const batches = [];
    for (let i = 0; i < tickers.length; i += batchSize) {
      const batch = tickers.slice(i, i + batchSize);
      const endpoint = `/v2/snapshot/locale/us/markets/stocks/tickers`;
      const cacheKey = `snapshot:${batch.join(',')}`;
      batches.push(
        this.fetchWithCache<unknown>(
          endpoint,
          cacheKey,
          'SNAPSHOT_DATA',
          { tickers: batch.join(',') },
          {
            ttl: 5000, // 5 seconds cache for snapshots
            tags: ['snapshots', ...batch],
          }
        )
      );
    }
    try {
      const responses = await Promise.all(batches);
      // Merge and validate responses
      const mergedResponse = responses.reduce((acc: SnapshotResponse, curr: any) => ({
        status: curr.status,
        tickers: [...acc.tickers, ...curr.tickers],
      }), { status: 'OK', tickers: [] });
      // Transform and validate each ticker in the response
      mergedResponse.tickers = mergedResponse.tickers.map(ticker => 
        DataTransformer.normalizeMarketData(ticker, 'polygon')
      );
      return mergedResponse;
    } catch (error) {
      if (error instanceof ValidationError) {
        // Invalidate all batch caches on validation error
        await Promise.all(
          tickers.map(ticker =>
            cacheManager.invalidateByTag(ticker)
          )
        );
      }
      throw error;
    }
  }
  async getSMA(
    ticker: string,
    timespan: string,
    window: number,
    from: string,
    to: string
  ): Promise<TechnicalIndicatorsResponse> {
    const endpoint = `/v1/indicators/sma/${ticker}`;
    return this.fetch<TechnicalIndicatorsResponse>(endpoint, {
      timespan,
      window: window.toString(),
      from,
      to,
    });
  }
  async getRSI(
    ticker: string,
    timespan: string,
    window: number,
    from: string,
    to: string
  ): Promise<TechnicalIndicatorsResponse> {
    const endpoint = `/v1/indicators/rsi/${ticker}`;
    return this.fetch<TechnicalIndicatorsResponse>(endpoint, {
      timespan,
      window: window.toString(),
      from,
      to,
    });
  }
  static formatDateRange(from: Date, to: Date): TimeRange {
    return { from, to };
  }
  // Get company details
  async getTickerDetails(ticker: string) {
    const endpoint = `/v3/reference/tickers/${ticker}`;
    return this.fetchWithCache(
      endpoint,
      ticker,
      'COMPANY_INFO',
      {},
      {
        ttl: 24 * 60 * 60 * 1000, // 24 hours cache for company info
        tags: ['company', ticker],
        transform: (data) => DataTransformer.validateCompanyInfo(data),
      }
    );
  }
  // Get real-time quotes
  async getLastQuote(ticker: string) {
    const url = `${this.baseUrl}/v2/last/nbbo/${ticker}`;
    return this.fetch<any>(url);
  }
  // Get market news
  async getMarketNews(ticker?: string, limit: number = 10) {
    const endpoint = `/v2/reference/news`;
    const cacheKey = `news:${ticker || 'market'}:${limit}`;
    return this.fetchWithCache(
      endpoint,
      cacheKey,
      'NEWS',
      {
        ...(ticker ? { ticker } : {}),
        limit: limit.toString(),
      },
      {
        ttl: 300000, // 5 minutes cache for news
        tags: ['news', ...(ticker ? [ticker] : [])],
        transform: (data) => {
          const items = (data as any).results || [];
          const { valid, errors } = DataTransformer.validateBatch(
            items,
            NewsItemSchema,
            { stopOnFirst: false }
          );
          if (errors.length > 0) {
            console.warn('Some news items failed validation:', errors);
          }
          return valid;
        },
      }
    );
  }
  // Get market status
  async getMarketStatus() {
    const url = `${this.baseUrl}/v1/marketstatus/now`;
    return this.fetch<any>(url);
  }
  // Search tickers
  async searchTickers(search: string, limit: number = 10) {
    const url = `${this.baseUrl}/v3/reference/tickers`;
    return this.fetch<any>(url, {
      search,
      limit: limit.toString(),
      active: 'true'
    });
  }
  // Helper method to reset retry count
  private resetRetryCount(endpoint: string) {
    this.retryCount.delete(endpoint);
  }
  // Helper method to check rate limit status
  public getRateLimitStatus() {
    return {
      remainingTokens: this.rateLimiter.getTokenCount(),
      isRateLimited: this.rateLimiter.getTokenCount() === 0,
    };
  }
  // Cache warming method
  async warmCache(symbols: string[]) {
    try {
      // Warm up snapshots
      await this.getSnapshots(symbols);
      // Warm up company info
      await Promise.all(
        symbols.map(symbol => this.getTickerDetails(symbol))
      );
      // Warm up news
      await this.getMarketNews();
      console.log('Cache warming completed successfully');
    } catch (error) {
      console.error('Error warming cache:', error);
      throw error;
    }
  }
  // Cache cleanup method
  async cleanupStaleData() {
    try {
      const stats = await cacheManager.getStats();
      console.log('Cache stats before cleanup:', stats);
      // Invalidate old news
      await cacheManager.invalidateByTag('news');
      // Invalidate stale market data
      const now = Date.now();
      const staleThreshold = 15 * 60 * 1000; // 15 minutes
      // Get all cached market data
      const marketData = await this.getAllCachedMarketData();
      // Invalidate stale entries
      await Promise.all(
        marketData
          .filter(entry => now - entry.lastUpdated > staleThreshold)
          .map(entry => cacheManager.invalidate(entry.symbol, 'MARKET_DATA'))
      );
      const newStats = await cacheManager.getStats();
      console.log('Cache stats after cleanup:', newStats);
    } catch (error) {
      console.error('Error cleaning up stale data:', error);
      throw error;
    }
  }
  private async getAllCachedMarketData(): Promise<Array<{ symbol: string; lastUpdated: number }>> {
    // Implementation would depend on your cache manager's capabilities
    // This is a placeholder that would need to be implemented based on your specific needs
    return [];
  }
}
export const polygonService = PolygonService.getInstance();
</file>

<file path="lib/api/polygon-websocket.ts">
// Custom EventEmitter implementation for browser
class BrowserEventEmitter {
  private listeners: { [key: string]: Function[] } = {};
  on(event: string, listener: Function): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  }
  off(event: string, listener: Function): void {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event].filter(l => l !== listener);
  }
  emit(event: string, ...args: any[]): void {
    if (!this.listeners[event]) return;
    this.listeners[event].forEach(listener => {
      try {
        listener(...args);
      } catch (error) {
        console.error(`Error in event listener for ${event}:`, error);
      }
    });
  }
}
import { WebSocketMessage, TradeMessage, QuoteMessage, AggregateMessage } from '@/types/polygon';
import { logger } from '@/lib/utils/logger';
interface PolygonEvents {
  'quote': (quote: QuoteMessage) => void;
  'trade': (trade: TradeMessage) => void;
  'aggregate': (agg: AggregateMessage) => void;
  'error': (error: Error) => void;
  'max_reconnects': () => void;
  'status': (status: string) => void;
}
// WebSocket connection states
enum ConnectionState {
  DISCONNECTED = 'DISCONNECTED',
  CONNECTING = 'CONNECTING',
  CONNECTED = 'CONNECTED',
  AUTHENTICATING = 'AUTHENTICATING',
  AUTHENTICATED = 'AUTHENTICATED',
  RECONNECTING = 'RECONNECTING',
}
// WebSocket configuration
const WS_CONFIG = {
  INITIAL_RECONNECT_DELAY: 1000,
  MAX_RECONNECT_DELAY: 30000,
  RECONNECT_BACKOFF_MULTIPLIER: 1.5,
  MAX_RECONNECT_ATTEMPTS: 10,
  PING_INTERVAL: 15000,
  SUBSCRIPTION_BATCH_SIZE: 20,
  SUBSCRIPTION_BATCH_DELAY: 500,
};
export class PolygonWebSocket extends BrowserEventEmitter {
  private ws: WebSocket | null = null;
  private apiKey: string = '';
  private subscriptions: Set<string> = new Set();
  private pendingSubscriptions: Set<string> = new Set();
  private reconnectAttempts: number = 0;
  private reconnectDelay: number = WS_CONFIG.INITIAL_RECONNECT_DELAY;
  private pingInterval: NodeJS.Timeout | null = null;
  private connectionState: ConnectionState = ConnectionState.DISCONNECTED;
  private messageQueue: { action: string, params: string }[] = [];
  private batchTimeout: NodeJS.Timeout | null = null;
  private wsUrl: string = 'wss://delayed.polygon.io/stocks';
  private lastMessageTime: number = Date.now();
  private reconnectTimer: NodeJS.Timeout | null = null;
  private subscriptionBacklog: Set<string> = new Set();
  constructor(apiKey?: string) {
    super();
    this.initializeConnection();
  }
  private async initializeConnection() {
    try {
      logger.info('Initializing WebSocket connection');
      const response = await fetch('http://localhost:3000/api/polygon-stocks/websocket');
      if (!response.ok) {
        logger.error(`WebSocket initialization failed with status: ${response.status}`);
        throw new Error('Failed to get WebSocket authentication');
      }
      const { token, wsUrl } = await response.json();
      this.apiKey = token;
      if (wsUrl) {
        this.wsUrl = wsUrl;
      }
      logger.info(`WebSocket initialized with URL: ${this.wsUrl}`);
    } catch (error) {
      logger.error('Failed to initialize WebSocket connection:', error);
      this.emit('error', new Error('WebSocket initialization failed'));
    }
  }
  isConnected(): boolean {
    return this.connectionState === ConnectionState.AUTHENTICATED;
  }
  connect() {
    if (this.connectionState !== ConnectionState.DISCONNECTED) return;
    if (!this.apiKey) {
      this.emit('error', new Error('Polygon API key is not set'));
      return;
    }
    try {
      this.connectionState = ConnectionState.CONNECTING;
      this.ws = new WebSocket(this.wsUrl);
      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.connectionState = ConnectionState.CONNECTED;
        this.authenticate();
        this.emit('status', 'connected');
      };
      this.ws.onmessage = (event) => {
        this.lastMessageTime = Date.now();
        try {
          const messages: WebSocketMessage[] = JSON.parse(event.data);
          messages.forEach(msg => this.handleMessage(msg));
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
          this.emit('error', new Error('Failed to parse WebSocket message'));
        }
      };
      this.ws.onclose = (event) => {
        console.log('WebSocket disconnected:', event.code, event.reason);
        this.handleDisconnect();
      };
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.emit('error', new Error('WebSocket connection error'));
        this.handleDisconnect();
      };
      this.setupHeartbeat();
    } catch (error) {
      console.error('Error creating WebSocket:', error);
      this.emit('error', new Error('Failed to create WebSocket connection'));
      this.handleDisconnect();
    }
  }
  private setupHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
    }
    this.pingInterval = setInterval(() => {
      if (Date.now() - this.lastMessageTime > WS_CONFIG.PING_INTERVAL * 2) {
        console.log('No messages received recently, reconnecting...');
        this.handleDisconnect();
      }
    }, WS_CONFIG.PING_INTERVAL);
  }
  private handleDisconnect() {
    logger.info(`Handling disconnect. Current state: ${this.connectionState}, Reconnect attempts: ${this.reconnectAttempts}`);
    this.cleanup();
    this.connectionState = ConnectionState.DISCONNECTED;
    this.emit('status', 'disconnected');
    // Save current subscriptions to backlog
    this.subscriptionBacklog = new Set([...this.subscriptions, ...this.pendingSubscriptions]);
    logger.debug(`Saved ${this.subscriptionBacklog.size} subscriptions to backlog`);
    this.subscriptions.clear();
    this.pendingSubscriptions.clear();
    this.attemptReconnect();
  }
  private attemptReconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    if (this.reconnectAttempts >= WS_CONFIG.MAX_RECONNECT_ATTEMPTS) {
      this.emit('max_reconnects');
      return;
    }
    this.connectionState = ConnectionState.RECONNECTING;
    this.reconnectAttempts++;
    this.reconnectTimer = setTimeout(() => {
      console.log(`Attempting reconnection ${this.reconnectAttempts}/${WS_CONFIG.MAX_RECONNECT_ATTEMPTS}`);
      this.connect();
      this.reconnectDelay = Math.min(
        this.reconnectDelay * WS_CONFIG.RECONNECT_BACKOFF_MULTIPLIER,
        WS_CONFIG.MAX_RECONNECT_DELAY
      );
    }, this.reconnectDelay);
  }
  private authenticate() {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.connectionState = ConnectionState.AUTHENTICATING;
      this.ws.send(JSON.stringify({
        action: 'auth',
        params: this.apiKey
      }));
    }
  }
  private handleMessage(message: WebSocketMessage) {
    switch (message.ev) {
      case 'status':
        this.handleStatus(message);
        break;
      case 'T':
        this.emit('trade', message as TradeMessage);
        break;
      case 'Q':
        this.emit('quote', message as QuoteMessage);
        break;
      case 'AM':
        this.emit('aggregate', message as AggregateMessage);
        break;
      default:
        console.log('Unhandled message type:', message.ev);
    }
  }
  private handleStatus(message: any) {
    logger.info(`Received status message: ${JSON.stringify(message)}`);
    if (message.status === 'auth_success') {
      logger.info('Authentication successful');
      this.connectionState = ConnectionState.AUTHENTICATED;
      this.emit('status', 'authenticated');
      this.reconnectAttempts = 0;
      this.reconnectDelay = WS_CONFIG.INITIAL_RECONNECT_DELAY;
      this.resubscribeAll();
    } else if (message.status === 'auth_failed') {
      logger.error(`Authentication failed: ${message.message}`);
      this.emit('error', new Error(`Authentication failed: ${message.message}`));
      this.handleDisconnect();
    }
  }
  private resubscribeAll() {
    if (this.subscriptionBacklog.size > 0) {
      const symbols = Array.from(this.subscriptionBacklog);
      this.subscriptionBacklog.clear();
      this.subscribe(symbols);
    }
  }
  subscribe(symbols: string | string[]) {
    const symbolList = Array.isArray(symbols) ? symbols : [symbols];
    let hasNewSubscriptions = false;
    symbolList.forEach(symbol => {
      ['AM', 'T', 'Q'].forEach(channel => {
        const sub = `${channel}.${symbol}`;
        if (!this.subscriptions.has(sub)) {
          this.pendingSubscriptions.add(sub);
          hasNewSubscriptions = true;
        }
      });
    });
    if (hasNewSubscriptions) {
      this.batchSubscribe();
    }
  }
  private batchSubscribe() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }
    this.batchTimeout = setTimeout(() => {
      if (this.pendingSubscriptions.size > 0) {
        logger.info(`Processing batch subscription for ${this.pendingSubscriptions.size} symbols`);
        const pendingSubs = Array.from(this.pendingSubscriptions);
        // Process subscriptions in batches
        for (let i = 0; i < pendingSubs.length; i += WS_CONFIG.SUBSCRIPTION_BATCH_SIZE) {
          const batch = pendingSubs.slice(i, i + WS_CONFIG.SUBSCRIPTION_BATCH_SIZE);
          setTimeout(() => {
            if (this.connectionState === ConnectionState.AUTHENTICATED) {
              logger.debug(`Sending subscription batch ${Math.floor(i / WS_CONFIG.SUBSCRIPTION_BATCH_SIZE) + 1}, size: ${batch.length}`);
              this.messageQueue.push({
                action: 'subscribe',
                params: batch.join(',')
              });
              batch.forEach(sub => {
                this.pendingSubscriptions.delete(sub);
                this.subscriptions.add(sub);
              });
              logger.debug(`Message queue size after batch: ${this.messageQueue.length}`);
              this.processMessageQueue();
            } else {
              logger.warn(`Attempted to subscribe while not authenticated. Current state: ${this.connectionState}`);
            }
          }, Math.floor(i / WS_CONFIG.SUBSCRIPTION_BATCH_SIZE) * WS_CONFIG.SUBSCRIPTION_BATCH_DELAY);
        }
      }
    }, 100);
  }
  private processMessageQueue() {
    const queueSize = this.messageQueue.length;
    if (queueSize > 0) {
      logger.debug(`Processing message queue, size: ${queueSize}`);
    }
    while (this.messageQueue.length > 0 && this.ws?.readyState === WebSocket.OPEN) {
      const message = this.messageQueue.shift();
      if (message) {
        logger.debug(`Sending message: ${JSON.stringify(message)}`);
        this.ws.send(JSON.stringify(message));
      }
    }
  }
  unsubscribe(symbols: string | string[]) {
    const symbolList = Array.isArray(symbols) ? symbols : [symbols];
    const unsubList: string[] = [];
    symbolList.forEach(symbol => {
      ['AM', 'T', 'Q'].forEach(channel => {
        const sub = `${channel}.${symbol}`;
        if (this.subscriptions.has(sub)) {
          this.subscriptions.delete(sub);
          unsubList.push(sub);
        }
      });
    });
    if (unsubList.length > 0 && this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: 'unsubscribe',
        params: unsubList.join(',')
      }));
    }
  }
  private cleanup() {
    if (this.ws) {
      try {
        this.ws.close();
      } catch (error) {
        console.error('Error closing WebSocket:', error);
      }
      this.ws = null;
    }
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
  disconnect() {
    this.cleanup();
    this.connectionState = ConnectionState.DISCONNECTED;
    this.subscriptions.clear();
    this.pendingSubscriptions.clear();
    this.subscriptionBacklog.clear();
    this.messageQueue = [];
    this.reconnectAttempts = 0;
    this.reconnectDelay = WS_CONFIG.INITIAL_RECONNECT_DELAY;
  }
}
// Export singleton instance
export const polygonWebSocket = new PolygonWebSocket();
</file>

<file path="lib/api/portfolio-analytics.ts">
import type { PortfolioData, Recommendation } from "@/types/portfolio-analytics"
import { PortfolioAnalytics } from '@/types/portfolio-analytics'
export async function getPortfolioData(): Promise<PortfolioData> {
  // TODO: Implement actual API call to fetch portfolio data
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        overview: {
          assetAllocation: [
            { name: "Stocks", value: 60 },
            { name: "Bonds", value: 25 },
            { name: "Real Estate", value: 10 },
            { name: "Commodities", value: 5 },
          ],
          totalValue: 1000000,
          dailyChange: 1.5,
          totalReturn: 12.3,
          riskLevel: "Moderate",
        },
        performance: {
          performanceHistory: [
            { date: "2023-01-01", value: 900000, benchmark: 890000 },
            { date: "2023-02-01", value: 920000, benchmark: 900000 },
            { date: "2023-03-01", value: 950000, benchmark: 920000 },
            { date: "2023-04-01", value: 980000, benchmark: 940000 },
            { date: "2023-05-01", value: 1000000, benchmark: 960000 },
          ],
          assetClassPerformance: [
            { name: "Stocks", currentValue: 600000, dailyChange: 1.8, totalReturn: 15.5 },
            { name: "Bonds", currentValue: 250000, dailyChange: 0.5, totalReturn: 5.2 },
            { name: "Real Estate", currentValue: 100000, dailyChange: 1.2, totalReturn: 8.7 },
            { name: "Commodities", currentValue: 50000, dailyChange: -0.8, totalReturn: -2.3 },
          ],
        },
        benchmarking: {
          benchmarkComparison: [
            { name: "1 Month", portfolio: 2.5, benchmark: 2.1 },
            { name: "3 Months", portfolio: 5.8, benchmark: 4.9 },
            { name: "6 Months", portfolio: 9.2, benchmark: 7.8 },
            { name: "1 Year", portfolio: 12.3, benchmark: 10.5 },
          ],
          hedgeFundComparison: [
            { name: "Long/Short Equity", portfolioPerformance: 14.2, strategyAverage: 12.5, difference: 1.7 },
            { name: "Global Macro", portfolioPerformance: 8.7, strategyAverage: 9.2, difference: -0.5 },
            { name: "Event Driven", portfolioPerformance: 10.1, strategyAverage: 9.8, difference: 0.3 },
          ],
        },
        recommendations: [
          { type: "buy", asset: "AAPL", reason: "Undervalued with strong growth potential", action: "Buy 100 shares" },
          { type: "sell", asset: "XYZ Corp Bonds", reason: "Increased default risk", action: "Sell 50% of holdings" },
          {
            type: "rebalance",
            asset: "Real Estate",
            reason: "Overweight in portfolio",
            action: "Reduce allocation by 2%",
          },
        ],
        taxOptimization: {
          opportunities: [
            {
              strategy: "Tax-Loss Harvesting",
              potentialSavings: 5000,
              impact: 75,
              action: "Sell underperforming assets",
            },
            {
              strategy: "Asset Location",
              potentialSavings: 3000,
              impact: 60,
              action: "Move high-yield assets to tax-advantaged accounts",
            },
            {
              strategy: "Dividend Optimization",
              potentialSavings: 2000,
              impact: 40,
              action: "Favor qualified dividends",
            },
          ],
          taxLossHarvesting: [
            {
              asset: "Tech ETF",
              currentLoss: 8000,
              potentialTaxBenefit: 1760,
              recommendedAction: "Sell and replace with similar ETF",
            },
            {
              asset: "Energy Stock",
              currentLoss: 5000,
              potentialTaxBenefit: 1100,
              recommendedAction: "Hold and reassess in 30 days",
            },
          ],
          annualTaxSavings: 10000,
        },
      })
    }, 1000)
  })
}
export async function executeRecommendation(recommendation: Recommendation): Promise<void> {
  // TODO: Implement actual API call to execute recommendation
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Executing recommendation:", recommendation)
      resolve()
    }, 1000)
  })
}
export async function getPortfolioAnalytics(): Promise<PortfolioAnalytics> {
  // This is a mock implementation. Replace with actual API call when ready.
  return {
    performance: {
      totalReturn: 12.5,
      annualizedReturn: 8.2,
      sharpeRatio: 1.5,
      volatility: 15.3,
      maxDrawdown: -18.4,
      alpha: 2.1,
      beta: 0.85
    },
    allocation: {
      byAsset: [
        { name: 'Stocks', value: 65 },
        { name: 'Bonds', value: 20 },
        { name: 'Cash', value: 10 },
        { name: 'Other', value: 5 }
      ],
      bySector: [
        { name: 'Technology', value: 30 },
        { name: 'Healthcare', value: 20 },
        { name: 'Financials', value: 15 },
        { name: 'Consumer', value: 15 },
        { name: 'Other', value: 20 }
      ]
    },
    risk: {
      riskScore: 7.5,
      riskLevel: 'Moderate-High',
      concentrationRisk: 'Low',
      marketRisk: 'Medium',
      currencyRisk: 'Low'
    }
  }
}
</file>

<file path="lib/api/portfolio-optimizer.ts">
import type { PortfolioData, TradeOrder } from "@/types/portfolio-optimizer"
export async function getPortfolioData(): Promise<PortfolioData> {
  // TODO: Implement actual API call to fetch portfolio data
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        allocation: [
          { name: "Stocks", value: 50 },
          { name: "Bonds", value: 30 },
          { name: "Real Estate", value: 10 },
          { name: "Commodities", value: 5 },
          { name: "Cryptocurrencies", value: 5 },
        ],
        correlation: {
          Stocks: { Stocks: 1, Bonds: -0.2, "Real Estate": 0.5, Commodities: 0.3, Cryptocurrencies: 0.1 },
          Bonds: { Stocks: -0.2, Bonds: 1, "Real Estate": 0.1, Commodities: -0.1, Cryptocurrencies: -0.2 },
          "Real Estate": { Stocks: 0.5, Bonds: 0.1, "Real Estate": 1, Commodities: 0.2, Cryptocurrencies: 0.1 },
          Commodities: { Stocks: 0.3, Bonds: -0.1, "Real Estate": 0.2, Commodities: 1, Cryptocurrencies: 0.3 },
          Cryptocurrencies: { Stocks: 0.1, Bonds: -0.2, "Real Estate": 0.1, Commodities: 0.3, Cryptocurrencies: 1 },
        },
        performance: {
          returns: [
            { date: "2023-01-01", value: 100 },
            { date: "2023-02-01", value: 102 },
            { date: "2023-03-01", value: 105 },
            { date: "2023-04-01", value: 103 },
            { date: "2023-05-01", value: 108 },
          ],
          riskAdjustedReturns: [
            { date: "2023-01-01", value: 0.5 },
            { date: "2023-02-01", value: 0.6 },
            { date: "2023-03-01", value: 0.7 },
            { date: "2023-04-01", value: 0.65 },
            { date: "2023-05-01", value: 0.75 },
          ],
          drawdowns: [
            { date: "2023-01-01", value: 0 },
            { date: "2023-02-01", value: -1 },
            { date: "2023-03-01", value: 0 },
            { date: "2023-04-01", value: -2 },
            { date: "2023-05-01", value: 0 },
          ],
        },
        tradeSuggestions: [
          { asset: "Stocks", action: "Buy", quantity: 100, price: 50.25, reason: "Underweight, strong momentum" },
          { asset: "Bonds", action: "Sell", quantity: 50, price: 98.5, reason: "Overweight, interest rate risk" },
          { asset: "Real Estate", action: "Hold", quantity: 0, price: 0, reason: "Well-balanced" },
        ],
      })
    }, 1000)
  })
}
export async function optimizePortfolio(riskTolerance: number, rebalanceFrequency: string): Promise<PortfolioData> {
  // TODO: Implement actual API call to optimize portfolio
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        allocation: [
          { name: "Stocks", value: 60 },
          { name: "Bonds", value: 20 },
          { name: "Real Estate", value: 10 },
          { name: "Commodities", value: 5 },
          { name: "Cryptocurrencies", value: 5 },
        ],
        correlation: {
          Stocks: { Stocks: 1, Bonds: -0.2, "Real Estate": 0.5, Commodities: 0.3, Cryptocurrencies: 0.1 },
          Bonds: { Stocks: -0.2, Bonds: 1, "Real Estate": 0.1, Commodities: -0.1, Cryptocurrencies: -0.2 },
          "Real Estate": { Stocks: 0.5, Bonds: 0.1, "Real Estate": 1, Commodities: 0.2, Cryptocurrencies: 0.1 },
          Commodities: { Stocks: 0.3, Bonds: -0.1, "Real Estate": 0.2, Commodities: 1, Cryptocurrencies: 0.3 },
          Cryptocurrencies: { Stocks: 0.1, Bonds: -0.2, "Real Estate": 0.1, Commodities: 0.3, Cryptocurrencies: 1 },
        },
        performance: {
          returns: [
            { date: "2023-01-01", value: 100 },
            { date: "2023-02-01", value: 103 },
            { date: "2023-03-01", value: 107 },
            { date: "2023-04-01", value: 106 },
            { date: "2023-05-01", value: 110 },
          ],
          riskAdjustedReturns: [
            { date: "2023-01-01", value: 0.5 },
            { date: "2023-02-01", value: 0.65 },
            { date: "2023-03-01", value: 0.75 },
            { date: "2023-04-01", value: 0.7 },
            { date: "2023-05-01", value: 0.8 },
          ],
          drawdowns: [
            { date: "2023-01-01", value: 0 },
            { date: "2023-02-01", value: -0.5 },
            { date: "2023-03-01", value: 0 },
            { date: "2023-04-01", value: -1 },
            { date: "2023-05-01", value: 0 },
          ],
        },
        tradeSuggestions: [
          {
            asset: "Stocks",
            action: "Buy",
            quantity: 200,
            price: 51.75,
            reason: "Increase allocation due to higher risk tolerance",
          },
          {
            asset: "Bonds",
            action: "Sell",
            quantity: 100,
            price: 97.25,
            reason: "Decrease allocation to match risk profile",
          },
          {
            asset: "Cryptocurrencies",
            action: "Buy",
            quantity: 10,
            price: 35000,
            reason: "Small increase for diversification",
          },
        ],
      })
    }, 1500)
  })
}
export async function executeTradeOrder(order: TradeOrder): Promise<void> {
  // TODO: Implement actual API call to execute trade order
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Executing trade order:", order)
      resolve()
    }, 1000)
  })
}
</file>

<file path="lib/api/stock-data.ts">
import { polygonService } from './polygon-service';
import { polygonWebSocket } from './polygon-websocket';
import { formatDistanceToNow } from 'date-fns';
// Cache for stock data
const cache = new Map<string, {
  data: any;
  timestamp: number;
}>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
export async function fetchStockData(symbol: string) {
  // Check cache first
  const cached = cache.get(symbol);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  try {
    // Fetch data in parallel
    const [details, quote, aggregates] = await Promise.all([
      polygonService.getTickerDetails(symbol),
      polygonService.getLastQuote(symbol),
      polygonService.getAggregates(
        symbol,
        1,
        'day',
        new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        new Date().toISOString().split('T')[0]
      ),
    ]);
    // Calculate metrics
    const lastClose = aggregates.results[aggregates.results.length - 1].c;
    const prevClose = aggregates.results[aggregates.results.length - 2].c;
    const change = lastClose - prevClose;
    const changePercent = (change / prevClose) * 100;
    // Subscribe to real-time updates
    polygonWebSocket.subscribe(symbol);
    const stockData = {
      basicInfo: {
        symbol,
        name: details.results.name,
        price: lastClose,
        change,
        changePercent,
        marketCap: formatMarketCap(details.results.market_cap),
        sector: 'Technology', // Note: Polygon doesn't provide sector info in basic tier
      },
      healthMetrics: calculateHealthMetrics(aggregates.results),
      analystData: generateAnalystData(aggregates.results),
      lastUpdated: formatDistanceToNow(new Date(quote.results.t)),
    };
    // Update cache
    cache.set(symbol, {
      data: stockData,
      timestamp: Date.now(),
    });
    return stockData;
  } catch (error) {
    console.error('Error fetching stock data:', error);
    throw new Error('Failed to fetch stock data');
  }
}
function calculateHealthMetrics(aggregates: any[]) {
  // Calculate some basic health metrics from the available data
  const prices = aggregates.map(bar => bar.c);
  const returns = prices.slice(1).map((price, i) => (price - prices[i]) / prices[i]);
  const volatility = Math.sqrt(returns.reduce((sum, ret) => sum + ret * ret, 0) / returns.length);
  const trend = prices[prices.length - 1] > prices[0];
  return {
    profitabilityScore: Math.round((1 - volatility) * 100),
    solvencyScore: Math.round(trend ? 85 : 65),
    profitabilityMetrics: [
      { label: "Price Trend", value: trend },
      { label: "Low Volatility", value: volatility < 0.02 },
      { label: "Consistent Trading", value: aggregates.every(bar => bar.v > 0) },
    ],
    solvencyMetrics: [
      { label: "Active Trading", value: true },
      { label: "Market Participation", value: true },
      { label: "Price Stability", value: volatility < 0.03 },
    ],
  };
}
function generateAnalystData(aggregates: any[]) {
  const prices = aggregates.map(bar => bar.c);
  const dates = aggregates.map(bar => new Date(bar.t));
  // Generate future dates for projections
  const lastDate = dates[dates.length - 1];
  const futureDates = Array.from({ length: 6 }, (_, i) => {
    const date = new Date(lastDate);
    date.setMonth(date.getMonth() + (i + 1) * 4);
    return date;
  });
  // Simple linear regression for price targets
  const lastPrice = prices[prices.length - 1];
  const priceTargets = futureDates.map((date, i) => ({
    date: formatDate(date),
    price: Math.round(lastPrice * (1 + (i + 1) * 0.05)),
    actual: i < 2 ? Math.round(lastPrice * (1 + i * 0.03)) : undefined,
  }));
  return {
    priceTargets,
    revenueEstimates: generateRevenueEstimates(),
  };
}
function formatDate(date: Date) {
  const month = date.toLocaleString('default', { month: 'short' });
  const year = date.getFullYear().toString().slice(2);
  return `${month} '${year}`;
}
function formatMarketCap(marketCap: number) {
  if (marketCap >= 1e12) {
    return `${(marketCap / 1e12).toFixed(2)}T`;
  } else if (marketCap >= 1e9) {
    return `${(marketCap / 1e9).toFixed(2)}B`;
  } else if (marketCap >= 1e6) {
    return `${(marketCap / 1e6).toFixed(2)}M`;
  }
  return `${marketCap.toFixed(2)}`;
}
function generateRevenueEstimates() {
  const currentYear = new Date().getFullYear();
  return [
    { year: (currentYear - 4).toString(), actual: 274.5, estimate: 275.2, miss: 0.25 },
    { year: (currentYear - 3).toString(), actual: 365.8, estimate: 360.1, miss: -1.5 },
    { year: (currentYear - 2).toString(), actual: 394.3, estimate: 400.2, miss: 1.5 },
    { year: (currentYear - 1).toString(), actual: 383.9, estimate: 385.1, miss: 0.3 },
    { year: currentYear.toString(), estimate: 410.5 },
    { year: (currentYear + 1).toString(), estimate: 445.2 },
    { year: (currentYear + 2).toString(), estimate: 482.8 },
  ];
}
</file>

<file path="lib/api/technical-analysis.ts">
import type { TechnicalAnalysisData, TradeSignal } from "@/types/technical-analysis"
export async function getTechnicalAnalysisData(symbol: string, timeframe: string): Promise<TechnicalAnalysisData> {
  // Simulate API call
  await new Promise((resolve) => setTimeout(resolve, 1000))
  // Mock technical analysis data
  return {
    priceData: [
      { date: "2023-01-01", price: 150 },
      { date: "2023-01-02", price: 152 },
      { date: "2023-01-03", price: 151 },
      { date: "2023-01-04", price: 153 },
      { date: "2023-01-05", price: 155 },
    ],
    detectedPatterns: [
      { name: "Double Bottom", description: "Bullish reversal pattern", confidence: 85 },
      { name: "Flag", description: "Continuation pattern", confidence: 72 },
    ],
    trendlines: [{ startDate: "2023-01-01", endDate: "2023-01-05", startValue: 150, endValue: 155 }],
    fibonacciLevels: [
      { level: 0.236, value: 151.18 },
      { level: 0.382, value: 152.29 },
      { level: 0.618, value: 153.95 },
    ],
    sentimentData: {
      bullishPercentage: 60,
      bearishPercentage: 30,
      neutralPercentage: 10,
    },
  }
}
type TradeSignalCallback = (signal: TradeSignal) => void
export function subscribeToTradeSignals(callback: TradeSignalCallback): () => void {
  const intervalId = setInterval(() => {
    const signal: TradeSignal = {
      type: Math.random() > 0.5 ? "buy" : "sell",
      symbol: "AAPL",
      price: 150 + Math.random() * 10,
      confidence: Math.round(Math.random() * 100),
      timestamp: new Date().toISOString(),
    }
    callback(signal)
  }, 5000) // Send a signal every 5 seconds for demonstration purposes
  return () => clearInterval(intervalId)
}
export async function executeOrder(order: {
  type: string
  quantity: number
  limitPrice?: number
}): Promise<void> {
  // Simulate API call
  await new Promise((resolve) => setTimeout(resolve, 1000))
  // In a real implementation, this would interact with a brokerage API
  console.log("Executing order:", order)
}
</file>

<file path="lib/api/trading-journal.ts">
import type { TradeData } from "@/types/trading-journal"
export async function getTradeData(): Promise<TradeData> {
  // TODO: Implement actual API call to fetch trade data
  // This is a mock implementation
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        trades: [
          {
            date: "2023-06-01T10:30:00Z",
            symbol: "AAPL",
            type: "Buy",
            entryPrice: 150.25,
            exitPrice: 155.5,
            quantity: 100,
            profitLoss: 525,
          },
          {
            date: "2023-06-02T14:15:00Z",
            symbol: "GOOGL",
            type: "Sell",
            entryPrice: 2500.0,
            exitPrice: 2480.75,
            quantity: 10,
            profitLoss: -192.5,
          },
          {
            date: "2023-06-03T11:45:00Z",
            symbol: "TSLA",
            type: "Buy",
            entryPrice: 200.5,
            exitPrice: 210.25,
            quantity: 50,
            profitLoss: 487.5,
          },
        ],
        behaviorAnalysis: {
          "Risk Management": { score: 75, description: "Good overall, but room for improvement in position sizing." },
          "Emotional Control": {
            score: 60,
            description: "Tendency to hold losing trades too long. Work on cutting losses quicker.",
          },
          Discipline: { score: 85, description: "Strong adherence to trading plan. Keep up the good work!" },
          Patience: { score: 70, description: "Occasionally entering trades prematurely. Wait for better setups." },
        },
        performanceReview: {
          metrics: {
            "Win Rate": 65,
            "Profit Factor": 1.8,
            "Average Win": 450,
            "Average Loss": 275,
            "Sharpe Ratio": 1.2,
            "Max Drawdown": "15%",
          },
          equityCurve: [
            { date: "2023-06-01", equity: 10000 },
            { date: "2023-06-02", equity: 10525 },
            { date: "2023-06-03", equity: 10332.5 },
            { date: "2023-06-04", equity: 10820 },
          ],
          improvementStrategies: [
            "Implement a more robust risk management strategy, focusing on consistent position sizing.",
            "Practice mindfulness techniques to improve emotional control during trades.",
            "Set up alerts for optimal trade setups to enhance patience and entry timing.",
            "Review and adjust your stop-loss strategy to minimize average losses.",
          ],
        },
        realtimeFeedback: [
          {
            type: "warning",
            category: "Risk Management",
            title: "Large Position Size",
            description:
              "Your current position in AAPL is 25% of your portfolio. Consider reducing to align with your risk management rules.",
          },
          {
            type: "success",
            category: "Discipline",
            title: "Adhered to Stop-Loss",
            description: "Well done on executing your stop-loss on the GOOGL trade. This demonstrates good discipline.",
          },
          {
            type: "info",
            category: "Market Conditions",
            title: "Increased Volatility",
            description:
              "Market volatility has increased. Consider adjusting your position sizes and being more selective with entries.",
          },
        ],
      })
    }, 1000)
  })
}
</file>

<file path="lib/contexts/market-context.tsx">
import React, { createContext, useContext, useEffect, useState } from 'react'
import { MarketData } from '../hooks/use-market-data'
import { StockData } from '../hooks/use-stock-data'
interface MarketContextType {
  marketData: MarketData | null
  watchlist: Record<string, StockData>
  portfolio: Record<string, StockData>
  isLoading: boolean
  error: Error | null
  addToWatchlist: (symbol: string) => void
  removeFromWatchlist: (symbol: string) => void
  updatePortfolio: (holdings: string[]) => void
  refetchMarketData: () => Promise<void>
}
const MarketContext = createContext<MarketContextType | undefined>(undefined)
export function MarketProvider({ children }: { children: React.ReactNode }) {
  const [marketData, setMarketData] = useState<MarketData | null>(null)
  const [watchlist, setWatchlist] = useState<Record<string, StockData>>({})
  const [portfolio, setPortfolio] = useState<Record<string, StockData>>({})
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const fetchMarketData = async () => {
    try {
      setIsLoading(true)
      setError(null)
      const response = await fetch('/api/polygon-stocks/market')
      if (!response.ok) {
        throw new Error('Failed to fetch market data')
      }
      const data = await response.json()
      setMarketData(data)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('An error occurred'))
    } finally {
      setIsLoading(false)
    }
  }
  const fetchWatchlistData = async (symbols: string[]) => {
    if (!symbols.length) return
    try {
      const response = await fetch(`/api/polygon-stocks/batch?tickers=${symbols.join(',')}`)
      if (!response.ok) {
        throw new Error('Failed to fetch watchlist data')
      }
      const data = await response.json()
      const stocksRecord = data.results.reduce((acc: Record<string, StockData>, stock: StockData) => {
        acc[stock.symbol] = stock
        return acc
      }, {})
      setWatchlist(stocksRecord)
    } catch (err) {
      console.error('Error fetching watchlist data:', err)
    }
  }
  const fetchPortfolioData = async (symbols: string[]) => {
    if (!symbols.length) return
    try {
      const response = await fetch(`/api/polygon-stocks/batch?tickers=${symbols.join(',')}`)
      if (!response.ok) {
        throw new Error('Failed to fetch portfolio data')
      }
      const data = await response.json()
      const stocksRecord = data.results.reduce((acc: Record<string, StockData>, stock: StockData) => {
        acc[stock.symbol] = stock
        return acc
      }, {})
      setPortfolio(stocksRecord)
    } catch (err) {
      console.error('Error fetching portfolio data:', err)
    }
  }
  // Initial fetch
  useEffect(() => {
    fetchMarketData()
    // Set up polling every minute
    const interval = setInterval(fetchMarketData, 60000)
    return () => clearInterval(interval)
  }, [])
  const addToWatchlist = (symbol: string) => {
    fetchWatchlistData([...Object.keys(watchlist), symbol])
  }
  const removeFromWatchlist = (symbol: string) => {
    const newWatchlist = { ...watchlist }
    delete newWatchlist[symbol]
    setWatchlist(newWatchlist)
  }
  const updatePortfolio = (holdings: string[]) => {
    fetchPortfolioData(holdings)
  }
  return (
    <MarketContext.Provider
      value={{
        marketData,
        watchlist,
        portfolio,
        isLoading,
        error,
        addToWatchlist,
        removeFromWatchlist,
        updatePortfolio,
        refetchMarketData: fetchMarketData,
      }}
    >
      {children}
    </MarketContext.Provider>
  )
}
export function useMarket() {
  const context = useContext(MarketContext)
  if (context === undefined) {
    throw new Error('useMarket must be used within a MarketProvider')
  }
  return context
}
</file>

<file path="lib/hooks/use-batch-stock-data.ts">
import { useState, useEffect } from 'react'
import { StockData } from '@/types/stock'
interface UseBatchStockDataParams {
  symbols: string[];
  pollingInterval?: number;
}
interface UseBatchStockDataReturn {
  data: Record<string, StockData>;
  isLoading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
  currentPollingInterval: number;
}
const MIN_POLLING_INTERVAL = 15000; // 15 seconds
const MAX_POLLING_INTERVAL = 60000; // 1 minute
const BACKOFF_MULTIPLIER = 1.5;
export function useBatchStockData({ 
  symbols,
  pollingInterval = MIN_POLLING_INTERVAL
}: UseBatchStockDataParams): UseBatchStockDataReturn {
  const [data, setData] = useState<Record<string, StockData>>({})
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [currentPollingInterval, setCurrentPollingInterval] = useState(pollingInterval)
  const [consecutiveErrors, setConsecutiveErrors] = useState(0)
  const fetchData = async () => {
    if (!symbols.length) return
    try {
      setIsLoading(true)
      setError(null)
      const response = await fetch(`/api/polygon-stocks/batch?tickers=${symbols.join(',')}`)
      if (!response.ok) {
        if (response.status === 429) {
          // Rate limited - increase backoff
          setConsecutiveErrors(prev => prev + 1)
          const retryAfter = response.headers.get('Retry-After')
          if (retryAfter) {
            setCurrentPollingInterval(Math.min(parseInt(retryAfter) * 1000, MAX_POLLING_INTERVAL))
          } else {
            setCurrentPollingInterval(prev => Math.min(prev * BACKOFF_MULTIPLIER, MAX_POLLING_INTERVAL))
          }
          throw new Error('Rate limit exceeded')
        }
        throw new Error('Failed to fetch batch stock data')
      }
      const jsonData = await response.json()
      // Transform array to record for easier lookup
      const stocksRecord = jsonData.results.reduce((acc: Record<string, StockData>, stock: StockData) => {
        acc[stock.symbol] = stock
        return acc
      }, {})
      setData(stocksRecord)
      // Reset on success
      setConsecutiveErrors(0)
      setCurrentPollingInterval(MIN_POLLING_INTERVAL)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('An error occurred'))
      // Increase backoff on error
      setConsecutiveErrors(prev => prev + 1)
      setCurrentPollingInterval(prev => Math.min(prev * BACKOFF_MULTIPLIER, MAX_POLLING_INTERVAL))
    } finally {
      setIsLoading(false)
    }
  }
  useEffect(() => {
    fetchData()
    // Set up polling if interval is provided
    if (currentPollingInterval > 0) {
      const interval = setInterval(fetchData, currentPollingInterval)
      return () => clearInterval(interval)
    }
  }, [symbols.join(','), currentPollingInterval])
  return {
    data,
    isLoading,
    error,
    refetch: fetchData,
    currentPollingInterval
  }
}
</file>

<file path="lib/hooks/use-company-info.ts">
import { useState, useCallback, useEffect } from 'react';
import { apiClient } from '../api/api-client';
interface CompanyInfo {
  symbol: string;
  name: string;
  description: string;
  sector: string;
  industry: string;
  employees?: number;
  website?: string;
  marketCap?: number;
}
interface UseCompanyInfoOptions {
  refreshInterval?: number;
  onUpdate?: (data: CompanyInfo) => void;
  onError?: (error: Error) => void;
}
export function useCompanyInfo(
  symbol: string,
  options: UseCompanyInfoOptions = {}
) {
  const { refreshInterval, onUpdate, onError } = options;
  const [data, setData] = useState<CompanyInfo | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<number>(0);
  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await apiClient.getCompanyInfo(symbol);
      setData(response.data);
      setLastUpdated(Date.now());
      setError(null);
      onUpdate?.(response.data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch company info');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [symbol, onUpdate, onError]);
  // Set up polling if refresh interval is provided
  useEffect(() => {
    fetchData();
    if (refreshInterval) {
      const interval = setInterval(fetchData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, refreshInterval]);
  return {
    data,
    error,
    isLoading,
    lastUpdated,
    refresh: fetchData,
  };
}
// Hook for batch company information
export function useCompanyInfoBatch(
  symbols: string[],
  options: UseCompanyInfoOptions = {}
) {
  const { refreshInterval, onError } = options;
  const [data, setData] = useState<Record<string, CompanyInfo>>({});
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<number>(0);
  const fetchData = useCallback(async () => {
    if (symbols.length === 0) return;
    try {
      setIsLoading(true);
      const response = await apiClient.getCompanyInfoBatch(symbols);
      setData(response.data);
      setLastUpdated(Date.now());
      setError(null);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch company info batch');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [symbols, onError]);
  // Set up polling if refresh interval is provided
  useEffect(() => {
    fetchData();
    if (refreshInterval) {
      const interval = setInterval(fetchData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, refreshInterval]);
  // Utility functions
  const getCompanyInfo = useCallback((symbol: string) => {
    return data[symbol];
  }, [data]);
  const hasAllData = useCallback(() => {
    return symbols.every(symbol => !!data[symbol]);
  }, [symbols, data]);
  return {
    data,
    error,
    isLoading,
    lastUpdated,
    refresh: fetchData,
    getCompanyInfo,
    hasAllData,
  };
}
</file>

<file path="lib/hooks/use-debounce.ts">
"use client"
import { useState, useEffect } from "react"
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])
  return debouncedValue
}
</file>

<file path="lib/hooks/use-market-data.ts">
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { StateCreator } from 'zustand'
import { useCallback, useRef, useEffect, useState } from 'react'
import { apiClient } from '../api/api-client'
// Enhanced market data interface with metadata
interface MarketData {
  symbol: string
  price: number
  change: number
  changePercent: number
  volume: number
  lastUpdated: number
  metadata: {
    source: 'websocket' | 'rest' | 'cache'
    reliability: number // 0-1 score of data reliability
    staleness: number // milliseconds since last update
  }
}
// Configuration for data freshness
const DATA_FRESHNESS = {
  REAL_TIME: 1000, // 1 second for websocket data
  RECENT: 60000, // 1 minute for REST API data
  STALE: 300000, // 5 minutes for considering data stale
  EXPIRED: 900000 // 15 minutes for considering data expired
}
interface MarketDataState {
  data: Record<string, MarketData>
  isLoading: boolean
  error: string | null
  pendingUpdates: Set<string> // Tracks symbols waiting for updates
  batchQueue: Record<string, MarketData> // Queue for batch updates
  lastBatchUpdate: number
  updateData: (symbol: string, data: Partial<MarketData>, source: MarketData['metadata']['source']) => void
  updateBatchData: (updates: Record<string, Partial<MarketData>>, source: MarketData['metadata']['source']) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  invalidateData: (symbol: string) => void
  clearStaleData: () => void
}
type MarketDataStore = StateCreator<
  MarketDataState,
  [["zustand/devtools", never], ["zustand/persist", unknown]],
  [],
  MarketDataState
>
// Create a centralized store for market data with persistence
const useMarketDataStore = create<MarketDataState>()(
  devtools(
    persist(
      ((set, get) => ({
        data: {},
        isLoading: false,
        error: null,
        pendingUpdates: new Set(),
        batchQueue: {},
        lastBatchUpdate: Date.now(),
        updateData: (symbol: string, newData: Partial<MarketData>, source: MarketData['metadata']['source']) =>
          set((state) => {
            const currentData = state.data[symbol]
            const now = Date.now()
            // Calculate reliability based on source and data age
            const reliability = calculateReliability(source, currentData?.lastUpdated, now)
            return {
              data: {
                ...state.data,
                [symbol]: {
                  ...currentData,
                  ...newData,
                  lastUpdated: now,
                  metadata: {
                    source,
                    reliability,
                    staleness: 0
                  }
                }
              }
            }
          }),
        updateBatchData: (updates: Record<string, Partial<MarketData>>, source: MarketData['metadata']['source']) =>
          set((state) => {
            const now = Date.now()
            const updatedData = { ...state.data }
            Object.entries(updates).forEach(([symbol, newData]) => {
              const currentData = state.data[symbol]
              const reliability = calculateReliability(source, currentData?.lastUpdated, now)
              updatedData[symbol] = {
                ...currentData,
                ...newData,
                lastUpdated: now,
                metadata: {
                  source,
                  reliability,
                  staleness: 0
                }
              }
            })
            return {
              data: updatedData,
              lastBatchUpdate: now
            }
          }),
        setLoading: (loading: boolean) => set({ isLoading: loading }),
        setError: (error: string | null) => set({ error }),
        invalidateData: (symbol: string) =>
          set((state) => ({
            data: {
              ...state.data,
              [symbol]: {
                ...state.data[symbol],
                metadata: {
                  ...state.data[symbol].metadata,
                  reliability: 0
                }
              }
            }
          })),
        clearStaleData: () =>
          set((state) => {
            const now = Date.now()
            const freshData = Object.entries(state.data).reduce((acc, [symbol, data]) => {
              const staleness = now - data.lastUpdated
              if (staleness < DATA_FRESHNESS.EXPIRED) {
                acc[symbol] = {
                  ...data,
                  metadata: {
                    ...data.metadata,
                    staleness
                  }
                }
              }
              return acc
            }, {} as Record<string, MarketData>)
            return { data: freshData }
          })
      })) as MarketDataStore,
      {
        name: 'market-data-store',
        partialize: (state) => ({
          data: state.data // Only persist the data, not loading states or errors
        })
      }
    ),
    {
      name: 'market-data-store'
    }
  )
)
// Helper function to calculate data reliability
function calculateReliability(
  source: MarketData['metadata']['source'],
  lastUpdate: number | undefined,
  currentTime: number
): number {
  if (!lastUpdate) return 1 // New data is considered reliable
  const age = currentTime - lastUpdate
  // Base reliability by source
  const baseReliability = {
    websocket: 1,
    rest: 0.9,
    cache: 0.8
  }[source]
  // Decay reliability based on age
  if (age < DATA_FRESHNESS.REAL_TIME) return baseReliability
  if (age < DATA_FRESHNESS.RECENT) return baseReliability * 0.9
  if (age < DATA_FRESHNESS.STALE) return baseReliability * 0.7
  if (age < DATA_FRESHNESS.EXPIRED) return baseReliability * 0.5
  return 0
}
interface QuoteResponse {
  price: number
  change: number
  changePercent: number
  volume: number
}
interface UseMarketDataOptions {
  refreshInterval?: number
  useWebSocket?: boolean
  onUpdate?: (data: MarketData) => void
  onError?: (error: Error) => void
}
export function useMarketData(
  symbols: string[],
  options: UseMarketDataOptions = {}
) {
  const {
    refreshInterval = 5000,
    useWebSocket = true,
    onUpdate,
    onError,
  } = options
  const [data, setData] = useState<Record<string, MarketData>>({})
  const [error, setError] = useState<Error | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const wsRef = useRef<WebSocket | null>(null)
  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null)
  // Fetch initial data
  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true)
      const response = await apiClient.getMarketData(symbols)
      setData(response.data)
      setError(null)
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch market data')
      setError(error)
      onError?.(error)
    } finally {
      setIsLoading(false)
    }
  }, [symbols, onError])
  // Set up WebSocket connection
  const setupWebSocket = useCallback(() => {
    if (!useWebSocket) return
    wsRef.current = apiClient.connectWebSocket(symbols)
    wsRef.current.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data)
        if (message.type === 'marketData') {
          setData(prevData => ({
            ...prevData,
            [message.symbol]: {
              ...message.data,
              metadata: {
                source: 'websocket',
                reliability: 1,
                staleness: 0,
              },
            },
          }))
          onUpdate?.(message.data)
        }
      } catch (err) {
        console.error('WebSocket message error:', err)
      }
    }
    wsRef.current.onerror = (event) => {
      console.error('WebSocket error:', event)
      const error = new Error('WebSocket connection error')
      setError(error)
      onError?.(error)
    }
    wsRef.current.onclose = () => {
      // Fallback to polling if WebSocket fails
      setupPolling()
    }
  }, [symbols, useWebSocket, onUpdate, onError])
  // Set up polling fallback
  const setupPolling = useCallback(() => {
    if (refreshTimerRef.current) {
      clearInterval(refreshTimerRef.current)
    }
    refreshTimerRef.current = setInterval(fetchData, refreshInterval)
  }, [fetchData, refreshInterval])
  // Initialize data fetching
  useEffect(() => {
    fetchData()
    if (useWebSocket) {
      setupWebSocket()
    } else {
      setupPolling()
    }
    return () => {
      if (wsRef.current) {
        wsRef.current.close()
        wsRef.current = null
      }
      if (refreshTimerRef.current) {
        clearInterval(refreshTimerRef.current)
        refreshTimerRef.current = null
      }
    }
  }, [fetchData, setupWebSocket, setupPolling, useWebSocket])
  // Utility functions
  const refresh = useCallback(() => {
    fetchData()
  }, [fetchData])
  const getSymbolData = useCallback((symbol: string) => {
    return data[symbol]
  }, [data])
  return {
    data,
    error,
    isLoading,
    refresh,
    getSymbolData,
  }
}
// Enhanced fetcher with batching and error handling
export function useMarketDataFetcher(symbols: string[]) {
  const { updateBatchData, setError } = useMarketData(symbols)
  const batchTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const pendingUpdates = useRef<Record<string, Partial<MarketData>>>({})
  const fetchData = useCallback(async (targetSymbols?: string[]) => {
    try {
      const symbolsToFetch = targetSymbols || symbols
      if (!symbolsToFetch.length) return
      const response = await fetch(`/api/stock/quotes?symbols=${encodeURIComponent(symbolsToFetch.join(','))}`)
      if (!response.ok) {
        throw new Error(`Failed to fetch market data: ${response.status}`)
      }
      const data = await response.json()
      const updates: Record<string, Partial<MarketData>> = {}
      Object.entries(data).forEach(([symbol, quote]) => {
        if (isQuoteResponse(quote)) {
          updates[symbol] = {
            symbol,
            price: quote.price,
            change: quote.change,
            changePercent: quote.changePercent,
            volume: quote.volume
          }
        }
      })
      // Queue updates for batching
      pendingUpdates.current = { ...pendingUpdates.current, ...updates }
      // Clear existing timeout
      if (batchTimeoutRef.current) {
        clearTimeout(batchTimeoutRef.current)
      }
      // Set new timeout for batch update
      batchTimeoutRef.current = setTimeout(() => {
        if (Object.keys(pendingUpdates.current).length > 0) {
          updateBatchData(pendingUpdates.current, 'rest')
          pendingUpdates.current = {}
        }
      }, 100) // Batch updates within 100ms window
    } catch (error) {
      console.error('Error fetching market data:', error)
      setError(error instanceof Error ? error : new Error('Unknown error'))
    }
  }, [symbols, updateBatchData, setError])
  // Cleanup batch timeout on unmount
  useEffect(() => {
    return () => {
      if (batchTimeoutRef.current) {
        clearTimeout(batchTimeoutRef.current)
      }
    }
  }, [])
  return { fetchData }
}
function isQuoteResponse(quote: unknown): quote is QuoteResponse {
  return (
    typeof quote === 'object' &&
    quote !== null &&
    'price' in quote &&
    'change' in quote &&
    'changePercent' in quote &&
    'volume' in quote
  )
}
</file>

<file path="lib/hooks/use-market-hours.ts">
"use client"
import { useState, useEffect } from "react"
type MarketHours = "pre" | "during" | "after" | "closed"
interface MarketHoursData {
  marketHours: MarketHours
  isLoading: boolean
  isError: boolean
}
export function useMarketHours(): MarketHoursData {
  const [marketHours, setMarketHours] = useState<MarketHours>("closed")
  const [isLoading, setIsLoading] = useState(true)
  const [isError, setIsError] = useState(false)
  useEffect(() => {
    const fetchMarketHours = async () => {
      try {
        setIsLoading(true)
        // In a real application, you would fetch this data from an API
        // For this example, we'll simulate an API call with a timeout
        await new Promise((resolve) => setTimeout(resolve, 1000))
        const currentTime = new Date()
        const currentHour = currentTime.getUTCHours()
        // Simulating market hours based on UTC time
        // Adjust these times according to your specific market
        if (currentHour >= 13 && currentHour < 14) {
          setMarketHours("pre")
        } else if (currentHour >= 14 && currentHour < 21) {
          setMarketHours("during")
        } else if (currentHour >= 21 && currentHour < 22) {
          setMarketHours("after")
        } else {
          setMarketHours("closed")
        }
        setIsLoading(false)
      } catch (error) {
        console.error("Error fetching market hours:", error)
        setIsError(true)
        setIsLoading(false)
      }
    }
    fetchMarketHours()
    // Refresh market hours every minute
    const intervalId = setInterval(fetchMarketHours, 60000)
    return () => clearInterval(intervalId)
  }, [])
  return { marketHours, isLoading, isError }
}
</file>

<file path="lib/hooks/use-market-indices.ts">
import { useState, useCallback, useEffect } from 'react'
import { polygonWebSocket } from '@/lib/api/polygon-websocket'
import { AggregateMessage } from '@/types/polygon'
import { MarketIndex } from '@/types/market'
const INDICES_MAP = {
  'SPY': 'S&P 500',
  'QQQ': 'NASDAQ',
  'DIA': 'DOW',
  'VIX': 'VIX'
}
const MIN_POLLING_INTERVAL = 15000; // 15 seconds
const MAX_POLLING_INTERVAL = 60000; // 1 minute
const BACKOFF_MULTIPLIER = 1.5;
const MAX_CONSECUTIVE_ERRORS = 3; // Maximum number of consecutive errors before forcing reset
const BACKOFF_RESET_TIMEOUT = 300000; // Reset backoff after 5 minutes
export function useMarketIndices() {
  const [indices, setIndices] = useState<MarketIndex[]>([])
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [pollingInterval, setPollingInterval] = useState(MIN_POLLING_INTERVAL)
  const [consecutiveErrors, setConsecutiveErrors] = useState(0)
  const [lastBackoffTime, setLastBackoffTime] = useState<number | null>(null)
  const resetBackoff = useCallback(() => {
    setConsecutiveErrors(0)
    setPollingInterval(MIN_POLLING_INTERVAL)
    setLastBackoffTime(null)
  }, [])
  const handleBackoff = useCallback(() => {
    const now = Date.now()
    // If we've exceeded MAX_CONSECUTIVE_ERRORS or it's been too long since our last backoff, reset
    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS || 
        (lastBackoffTime && now - lastBackoffTime > BACKOFF_RESET_TIMEOUT)) {
      resetBackoff()
      return
    }
    setConsecutiveErrors(prev => prev + 1)
    setPollingInterval(prev => Math.min(prev * BACKOFF_MULTIPLIER, MAX_POLLING_INTERVAL))
    setLastBackoffTime(now)
  }, [consecutiveErrors, lastBackoffTime, resetBackoff])
  const fetchInitialData = useCallback(async () => {
    try {
      // Get all indices data in a single batch request
      const symbols = Object.keys(INDICES_MAP)
      const response = await fetch(`/api/polygon-stocks/batch?tickers=${symbols.join(',')}`)
      if (!response.ok) {
        if (response.status === 429) {
          // Rate limited - increase backoff
          handleBackoff()
          const retryAfter = response.headers.get('Retry-After')
          if (retryAfter) {
            setPollingInterval(Math.min(parseInt(retryAfter) * 1000, MAX_POLLING_INTERVAL))
          }
          throw new Error('Rate limit exceeded')
        }
        throw new Error('Failed to fetch market data')
      }
      const { results, validCount } = await response.json()
      // Transform batch results into indices format
      const initialData = Object.keys(INDICES_MAP).map(symbol => {
        const stockData = results.find((r: any) => r.symbol === symbol)
        if (!stockData || stockData.status === 'error') {
          return {
            name: INDICES_MAP[symbol as keyof typeof INDICES_MAP],
            symbol,
            value: 0,
            change: 0,
            changePercent: 0,
            lastUpdated: Date.now(),
            error: stockData?.error || 'No data available'
          }
        }
        return {
          name: INDICES_MAP[symbol as keyof typeof INDICES_MAP],
          symbol,
          value: stockData.price || 0,
          change: stockData.change || 0,
          changePercent: stockData.changePercent || 0,
          lastUpdated: stockData.lastUpdated || Date.now()
        }
      })
      setIndices(initialData)
      setIsLoading(false)
      // Only reset if we got at least some valid data
      if (validCount > 0) {
        resetBackoff()
      } else {
        // If no valid data, treat as an error
        handleBackoff()
      }
    } catch (error) {
      console.error('Error fetching market data:', error)
      setError(error instanceof Error ? error.message : 'Failed to fetch market data')
      setIsLoading(false)
      // Increase backoff on error
      handleBackoff()
    }
  }, [handleBackoff, resetBackoff])
  const handleUpdate = useCallback((agg: AggregateMessage) => {
    setIndices(prev => {
      const index = prev.findIndex(item => item.symbol === agg.sym)
      if (index === -1) return prev
      const newIndices = [...prev]
      newIndices[index] = {
        ...newIndices[index],
        value: agg.c,
        change: agg.c - agg.o,
        changePercent: ((agg.c - agg.o) / agg.o) * 100,
        lastUpdated: Date.now()
      }
      return newIndices
    })
  }, [])
  useEffect(() => {
    fetchInitialData()
    // Set up WebSocket connection for real-time updates
    const symbols = Object.keys(INDICES_MAP)
    polygonWebSocket.subscribe(symbols)
    polygonWebSocket.on('aggregate', handleUpdate)
    polygonWebSocket.on('error', (error: Error) => {
      console.error('WebSocket error:', error)
      setError('WebSocket connection error')
    })
    const interval = setInterval(fetchInitialData, pollingInterval)
    return () => {
      polygonWebSocket.unsubscribe(symbols)
      polygonWebSocket.off('aggregate', handleUpdate)
      clearInterval(interval)
    }
  }, [fetchInitialData, handleUpdate, pollingInterval])
  return {
    indices,
    error,
    isLoading,
    pollingInterval,
    refetch: fetchInitialData
  }
}
</file>

<file path="lib/hooks/use-news.ts">
import { useState, useCallback, useEffect, useRef } from 'react';
import { apiClient } from '../api/api-client';
interface NewsItem {
  id: string;
  title: string;
  summary: string;
  url: string;
  source: string;
  publishedAt: number;
  symbols: string[];
}
interface UseNewsOptions {
  limit?: number;
  page?: number;
  useStream?: boolean;
  onUpdate?: (news: NewsItem[]) => void;
  onError?: (error: Error) => void;
}
export function useNews(
  symbols?: string[],
  options: UseNewsOptions = {}
) {
  const {
    limit = 10,
    page = 1,
    useStream = false,
    onUpdate,
    onError,
  } = options;
  const [news, setNews] = useState<NewsItem[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [hasMore, setHasMore] = useState(true);
  const eventSourceRef = useRef<EventSource | null>(null);
  const fetchNews = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await apiClient.getNews({
        symbols,
        limit,
        page,
      });
      setNews(prevNews => 
        page === 1 ? response.data : [...prevNews, ...response.data]
      );
      setHasMore(response.meta.page < response.meta.totalPages);
      setError(null);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch news');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [symbols, limit, page, onError]);
  const setupEventSource = useCallback(() => {
    if (!useStream) return;
    eventSourceRef.current = apiClient.subscribeToNews(symbols);
    eventSourceRef.current.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === 'initial') {
          setNews(data.data);
        } else if (data.type === 'update') {
          setNews(prevNews => [...data.data, ...prevNews]);
          onUpdate?.(data.data);
        }
      } catch (err) {
        console.error('News stream error:', err);
      }
    };
    eventSourceRef.current.onerror = (event) => {
      console.error('News stream connection error:', event);
      const error = new Error('News stream connection error');
      setError(error);
      onError?.(error);
      eventSourceRef.current?.close();
      eventSourceRef.current = null;
    };
  }, [symbols, useStream, onUpdate, onError]);
  // Initialize news fetching
  useEffect(() => {
    if (useStream) {
      setupEventSource();
    } else {
      fetchNews();
    }
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }
    };
  }, [fetchNews, setupEventSource, useStream]);
  // Utility functions
  const loadMore = useCallback(() => {
    if (!isLoading && hasMore && !useStream) {
      fetchNews();
    }
  }, [fetchNews, isLoading, hasMore, useStream]);
  const refresh = useCallback(() => {
    if (!useStream) {
      fetchNews();
    }
  }, [fetchNews, useStream]);
  return {
    news,
    error,
    isLoading,
    hasMore,
    loadMore,
    refresh,
  };
}
// Hook for real-time news updates only
export function useNewsStream(
  symbols?: string[],
  options: Omit<UseNewsOptions, 'useStream' | 'page' | 'limit'> = {}
) {
  const { onUpdate, onError } = options;
  const [latestNews, setLatestNews] = useState<NewsItem[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);
  useEffect(() => {
    eventSourceRef.current = apiClient.subscribeToNews(symbols);
    eventSourceRef.current.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === 'update') {
          setLatestNews(data.data);
          onUpdate?.(data.data);
        }
      } catch (err) {
        console.error('News stream error:', err);
      }
    };
    eventSourceRef.current.onerror = (event) => {
      console.error('News stream connection error:', event);
      const error = new Error('News stream connection error');
      setError(error);
      onError?.(error);
    };
    return () => {
      eventSourceRef.current?.close();
      eventSourceRef.current = null;
    };
  }, [symbols, onUpdate, onError]);
  return {
    latestNews,
    error,
    isConnected: !!eventSourceRef.current,
  };
}
</file>

<file path="lib/hooks/use-search.ts">
import { useState, useCallback, useEffect, useRef } from 'react';
import { apiClient } from '../api/api-client';
interface TickerResult {
  ticker: string;
  name: string;
  market: string;
  type: string;
  active: boolean;
  primaryExchange: string;
  [key: string]: unknown;
}
interface SearchFilters {
  type?: 'stocks' | 'crypto' | 'forex';
  market?: 'stocks' | 'crypto' | 'fx';
  active?: boolean;
  [key: string]: unknown;
}
interface UseSearchOptions {
  limit?: number;
  debounceMs?: number;
  filters?: SearchFilters;
  onError?: (error: Error) => void;
}
export function useSearch(options: UseSearchOptions = {}) {
  const {
    limit = 10,
    debounceMs = 300,
    filters = {},
    onError,
  } = options;
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<TickerResult[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const search = useCallback(async (searchQuery: string) => {
    if (!searchQuery) {
      setResults([]);
      return;
    }
    try {
      setIsLoading(true);
      const response = await apiClient.searchTickers({
        query: searchQuery,
        limit,
        ...filters,
      });
      setResults(response.data);
      setError(null);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Search failed');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [limit, filters, onError]);
  // Debounced search effect
  useEffect(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    if (query) {
      debounceTimerRef.current = setTimeout(() => {
        search(query);
      }, debounceMs);
    } else {
      setResults([]);
    }
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [query, search, debounceMs]);
  return {
    query,
    setQuery,
    results,
    error,
    isLoading,
  };
}
// Hook for advanced search with custom filters
export function useAdvancedSearch(options: UseSearchOptions = {}) {
  const {
    limit = 10,
    filters = {},
    onError,
  } = options;
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<TickerResult[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [appliedFilters, setAppliedFilters] = useState(filters);
  const search = useCallback(async () => {
    if (!query) {
      setResults([]);
      return;
    }
    try {
      setIsLoading(true);
      const response = await apiClient.advancedSearch({
        query,
        limit,
        ...appliedFilters,
      });
      setResults(response.data);
      setError(null);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Advanced search failed');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [query, limit, appliedFilters, onError]);
  // Update filters and trigger search
  const updateFilters = useCallback((newFilters: SearchFilters) => {
    setAppliedFilters(prevFilters => ({
      ...prevFilters,
      ...newFilters,
    }));
  }, []);
  // Clear all filters
  const clearFilters = useCallback(() => {
    setAppliedFilters({});
  }, []);
  // Execute search when filters change
  useEffect(() => {
    if (query) {
      search();
    }
  }, [query, appliedFilters, search]);
  return {
    query,
    setQuery,
    results,
    error,
    isLoading,
    filters: appliedFilters,
    updateFilters,
    clearFilters,
    search,
  };
}
</file>

<file path="lib/hooks/use-stock-aggregates.ts">
import { useState, useEffect } from 'react'
import { AggregatesResponse } from '@/lib/api/polygon-service'
interface UseStockAggregatesParams {
  ticker: string
  multiplier: number
  timespan: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'
  from: Date
  to: Date
  adjusted?: boolean
}
interface UseStockAggregatesReturn {
  data: AggregatesResponse | null
  isLoading: boolean
  error: Error | null
  refetch: () => Promise<void>
}
export function useStockAggregates({
  ticker,
  multiplier,
  timespan,
  from,
  to,
  adjusted = true,
}: UseStockAggregatesParams): UseStockAggregatesReturn {
  const [data, setData] = useState<AggregatesResponse | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const fetchData = async () => {
    try {
      setIsLoading(true)
      setError(null)
      const params = new URLSearchParams({
        ticker,
        multiplier: multiplier.toString(),
        timespan,
        from: from.toISOString().split('T')[0],
        to: to.toISOString().split('T')[0],
        adjusted: adjusted.toString(),
      })
      const response = await fetch(`/api/polygon/aggregates?${params}`)
      if (!response.ok) {
        throw new Error('Failed to fetch aggregates data')
      }
      const jsonData = await response.json()
      setData(jsonData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('An error occurred'))
    } finally {
      setIsLoading(false)
    }
  }
  useEffect(() => {
    fetchData()
  }, [ticker, multiplier, timespan, from, to, adjusted])
  return {
    data,
    isLoading,
    error,
    refetch: fetchData,
  }
}
</file>

<file path="lib/hooks/use-stock-data.ts">
import { useState, useEffect } from 'react'
import { polygonService } from '@/lib/api/polygon-service'
export interface StockData {
  symbol: string
  name: string | null
  price: number | null
  previousClose: number | null
  change: number | null
  changePercent: number | null
  volume: number | null
  dayOpen: number | null
  dayHigh: number | null
  dayLow: number | null
  marketCap: number | null
  exchange: string | null
  type: string | null
  lastUpdated: number | null
}
interface UseStockDataParams {
  symbol: string
  pollingInterval?: number // in milliseconds
}
interface UseStockDataReturn {
  data: StockData | null
  isLoading: boolean
  error: Error | null
  refetch: () => Promise<void>
}
export function useStockData({ 
  symbol,
  pollingInterval = 15000 // Default to 15 seconds
}: UseStockDataParams): UseStockDataReturn {
  const [data, setData] = useState<StockData | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const fetchData = async () => {
    if (!symbol) return
    try {
      setIsLoading(true)
      setError(null)
      const response = await fetch(`/api/polygon-stocks?ticker=${symbol}`)
      if (!response.ok) {
        throw new Error('Failed to fetch stock data')
      }
      const jsonData = await response.json()
      setData(jsonData)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('An error occurred'))
    } finally {
      setIsLoading(false)
    }
  }
  useEffect(() => {
    fetchData()
    // Set up polling if interval is provided
    if (pollingInterval > 0) {
      const interval = setInterval(fetchData, pollingInterval)
      return () => clearInterval(interval)
    }
  }, [symbol, pollingInterval])
  return {
    data,
    isLoading,
    error,
    refetch: fetchData,
  }
}
</file>

<file path="lib/hooks/use-stock-websocket.ts">
import { useEffect, useState } from 'react'
import { AggregateMessage } from '@/types/polygon'
import { polygonClient } from '@/lib/api/polygon-client'
interface WebSocketConfig {
  symbols: string[]
  onAggregate?: (data: AggregateMessage) => void
  onError?: (error: Error) => void
  onStatusChange?: (status: string) => void
}
export function useStockWebSocket({
  symbols,
  onAggregate,
  onError,
  onStatusChange
}: WebSocketConfig) {
  const [isClient, setIsClient] = useState(false);
  const [client, setClient] = useState<typeof polygonClient | null>(null);
  // Set isClient to true once component mounts
  useEffect(() => {
    setIsClient(true);
  }, []);
  // Initialize client after component mounts
  useEffect(() => {
    if (isClient) {
      setClient(polygonClient);
    }
  }, [isClient]);
  useEffect(() => {
    if (!isClient || !client) return;
    const handleAggregate = (data: AggregateMessage) => {
      if (symbols.includes(data.sym)) {
        onAggregate?.(data);
      }
    };
    const handleError = (error: Error) => {
      onError?.(error);
    };
    const handleStatus = (status: string) => {
      onStatusChange?.(status);
    };
    // Connect to WebSocket if not already connected
    if (!client.isConnected()) {
      client.connect();
    }
    // Subscribe to each symbol
    symbols.forEach(symbol => {
      client.subscribe('aggregate', (data: AggregateMessage) => {
        if (data.type === 'error') {
          handleError(data.error);
        } else if (data.type === 'status') {
          handleStatus(data.status);
        } else {
          handleAggregate(data);
        }
      });
    });
    // Cleanup function
    return () => {
      if (isClient && client) {
        symbols.forEach(symbol => {
          client.unsubscribe('aggregate', handleAggregate);
        });
      }
    };
  }, [symbols, onAggregate, onError, onStatusChange, isClient, client]);
  return {
    isConnected: isClient && client ? client.isConnected() : false
  };
}
</file>

<file path="lib/hooks/use-swr-market-data.ts">
"use client"
interface MarketData {
  symbol: string
  price: number
  change: number
  changePercent: number
}
interface MarketDataResponse {
  marketData: MarketData[] | null
  isLoading: boolean
  isError: boolean
}
// Mock data for development
const mockMarketData: MarketData[] = [
  { symbol: "AAPL", price: 150.25, change: 2.5, changePercent: 1.69 },
  { symbol: "GOOGL", price: 2750.8, change: -15.2, changePercent: -0.55 },
  { symbol: "MSFT", price: 305.15, change: 1.8, changePercent: 0.59 },
  { symbol: "AMZN", price: 3380.5, change: -22.3, changePercent: -0.66 },
  { symbol: "META", price: 325.75, change: 5.2, changePercent: 1.62 },
]
export function useMarketData(): MarketDataResponse {
  // For development, return mock data directly
  return {
    marketData: mockMarketData,
    isLoading: false,
    isError: false,
  }
  // For production, uncomment this:
  /*
  const { data, error } = useSWR<MarketData[]>('/api/market-data', fetcher, {
    refreshInterval: 30000, // Refresh every 30 seconds
  })
  return {
    marketData: data ?? null,
    isLoading: !error && !data,
    isError: !!error,
  }
  */
}
</file>

<file path="lib/hooks/use-technical-indicators.ts">
import { useState, useCallback, useEffect } from 'react';
import { apiClient } from '../api/api-client';
interface TechnicalIndicator {
  timestamp: number;
  value: number;
  indicator: 'SMA' | 'EMA' | 'RSI' | 'MACD';
  period: number;
}
interface CommonIndicators {
  sma: {
    20: TechnicalIndicator;
    50: TechnicalIndicator;
    200: TechnicalIndicator;
  };
  rsi: TechnicalIndicator;
}
interface UseTechnicalIndicatorsOptions {
  refreshInterval?: number;
  onUpdate?: (data: TechnicalIndicator[]) => void;
  onError?: (error: Error) => void;
}
export function useTechnicalIndicators(
  symbol: string,
  indicator: TechnicalIndicator['indicator'],
  period: number,
  timeRange: { startDate: string; endDate: string },
  options: UseTechnicalIndicatorsOptions = {}
) {
  const { refreshInterval, onUpdate, onError } = options;
  const [data, setData] = useState<TechnicalIndicator[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<number>(0);
  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await apiClient.getTechnicalIndicators({
        symbol,
        indicator,
        period,
        startDate: timeRange.startDate,
        endDate: timeRange.endDate,
      });
      setData(response.data);
      setLastUpdated(Date.now());
      setError(null);
      onUpdate?.(response.data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch technical indicators');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [symbol, indicator, period, timeRange, onUpdate, onError]);
  // Set up polling if refresh interval is provided
  useEffect(() => {
    fetchData();
    if (refreshInterval) {
      const interval = setInterval(fetchData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, refreshInterval]);
  return {
    data,
    error,
    isLoading,
    lastUpdated,
    refresh: fetchData,
  };
}
// Hook for common technical indicators
export function useCommonIndicators(
  symbol: string,
  options: UseTechnicalIndicatorsOptions = {}
) {
  const { refreshInterval, onError } = options;
  const [data, setData] = useState<CommonIndicators | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [lastUpdated, setLastUpdated] = useState<number>(0);
  const fetchData = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await apiClient.getCommonIndicators(symbol);
      setData(response.data);
      setLastUpdated(Date.now());
      setError(null);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Failed to fetch common indicators');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [symbol, onError]);
  // Set up polling if refresh interval is provided
  useEffect(() => {
    fetchData();
    if (refreshInterval) {
      const interval = setInterval(fetchData, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, refreshInterval]);
  return {
    data,
    error,
    isLoading,
    lastUpdated,
    refresh: fetchData,
  };
}
</file>

<file path="lib/hooks/use-user-preferences.ts">
"use client"
import { useState, useEffect } from "react"
import type { Layout } from "react-grid-layout"
interface UserPreferences {
  layout: Layout[]
}
const defaultPreferences: UserPreferences = {
  layout: [],
}
export function useUserPreferences() {
  const [preferences, setPreferences] = useState<UserPreferences>(defaultPreferences)
  useEffect(() => {
    const storedPreferences = localStorage.getItem("userPreferences")
    if (storedPreferences) {
      try {
        setPreferences(JSON.parse(storedPreferences))
      } catch (error) {
        console.error("Failed to parse stored preferences:", error)
        setPreferences(defaultPreferences)
      }
    }
  }, [])
  const updatePreferences = (newPreferences: Partial<UserPreferences>) => {
    const updatedPreferences = { ...preferences, ...newPreferences }
    setPreferences(updatedPreferences)
    localStorage.setItem("userPreferences", JSON.stringify(updatedPreferences))
  }
  const updateLayout = (newLayout: Layout[]) => {
    updatePreferences({ layout: newLayout })
  }
  return {
    preferences,
    updatePreferences,
    updateLayout,
  }
}
</file>

<file path="lib/middleware/auth-middleware.ts">
import { NextRequest, NextResponse } from 'next/server';
import { authService } from '../services/auth-service';
import { rateLimiterService } from '../services/rate-limiter';
import { rbacService } from '../services/rbac-service';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
interface AuthOptions {
  required?: boolean;
  permissions?: string[];
}
export async function authMiddleware(
  req: NextRequest,
  options: AuthOptions = { required: true }
) {
  const startTime = Date.now();
  const identifier = req.ip || 'unknown';
  try {
    // Check rate limit first
    const rateLimitResult = await rateLimiterService.consume(identifier, 'API');
    if (rateLimitResult.blocked) {
      return NextResponse.json(
        {
          error: 'Rate limit exceeded',
          retryAfter: rateLimitResult.blockExpiry,
        },
        {
          status: 429,
          headers: {
            'Retry-After': rateLimitResult.blockExpiry?.toString() || '300',
          },
        }
      );
    }
    // Add rate limit headers
    const headers = new Headers({
      'X-RateLimit-Limit': rateLimitResult.total.toString(),
      'X-RateLimit-Remaining': rateLimitResult.remaining.toString(),
      'X-RateLimit-Reset': rateLimitResult.reset.toString(),
    });
    // Check for API key first
    const apiKey = req.headers.get('x-api-key');
    if (apiKey) {
      const user = await authService.validateApiKey(apiKey);
      if (user) {
        // Check permissions if required
        if (options.permissions?.length) {
          const hasAllPermissions = await Promise.all(
            options.permissions.map(permission =>
              rbacService.hasPermission(user.id, permission)
            )
          );
          if (!hasAllPermissions.every(Boolean)) {
            return NextResponse.json(
              { error: 'Insufficient permissions' },
              { status: 403, headers }
            );
          }
        }
        // Add user to request
        (req as any).user = user;
        return NextResponse.next({ headers });
      }
    }
    // Check for JWT token
    const authHeader = req.headers.get('authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      if (!options.required) {
        return NextResponse.next({ headers });
      }
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401, headers }
      );
    }
    const token = authHeader.split(' ')[1];
    try {
      const payload = await authService.verifyToken(token);
      // Check permissions if required
      if (options.permissions?.length) {
        const hasAllPermissions = await Promise.all(
          options.permissions.map(permission =>
            rbacService.hasPermission(payload.sub, permission)
          )
        );
        if (!hasAllPermissions.every(Boolean)) {
          return NextResponse.json(
            { error: 'Insufficient permissions' },
            { status: 403, headers }
          );
        }
      }
      // Add user to request
      (req as any).user = {
        id: payload.sub,
        email: payload.email,
        role: payload.role,
      };
      return NextResponse.next({ headers });
    } catch (error) {
      return NextResponse.json(
        { error: 'Invalid token' },
        { status: 401, headers }
      );
    }
  } catch (error) {
    logger.error('Auth middleware error:', error);
    metrics.record('auth_middleware_errors', 1);
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 500 }
    );
  } finally {
    // Record metrics
    const duration = Date.now() - startTime;
    metrics.record('auth_middleware_duration', duration);
  }
}
// Helper to extract user from request
export function getUser(req: NextRequest) {
  return (req as any).user;
}
// Helper to check permissions
export async function checkPermissions(
  req: NextRequest,
  permissions: string[]
): Promise<boolean> {
  const user = getUser(req);
  if (!user) return false;
  try {
    const results = await Promise.all(
      permissions.map(permission =>
        rbacService.hasPermission(user.id, permission)
      )
    );
    return results.every(Boolean);
  } catch (error) {
    logger.error('Permission check error:', error);
    return false;
  }
}
</file>

<file path="lib/middleware/auth.ts">
import { NextRequest, NextResponse } from 'next/server';
import { verifyToken } from '../utils/jwt';
export async function authMiddleware(req: NextRequest) {
  try {
    const token = req.headers.get('authorization')?.split(' ')[1];
    if (!token) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    const decoded = await verifyToken(token);
    // Add user info to request context
    (req as any).user = decoded;
    return NextResponse.next();
  } catch (error) {
    return NextResponse.json(
      { error: 'Invalid authentication token' },
      { status: 401 }
    );
  }
}
</file>

<file path="lib/middleware/error-handler.ts">
import { NextRequest, NextResponse } from 'next/server';
import { ValidationError } from '../utils/data-validator';
import { z } from 'zod';
export class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code: string = 'INTERNAL_SERVER_ERROR'
  ) {
    super(message);
    this.name = 'APIError';
  }
}
export async function errorHandler(
  error: unknown,
  req: NextRequest
): Promise<NextResponse> {
  console.error('API Error:', error);
  if (error instanceof APIError) {
    return NextResponse.json(
      {
        error: error.message,
        code: error.code,
      },
      { status: error.statusCode }
    );
  }
  if (error instanceof ValidationError) {
    return NextResponse.json(
      {
        error: 'Validation error',
        code: 'VALIDATION_ERROR',
        details: error.errors.map(e => e.message),
      },
      { status: 400 }
    );
  }
  if (error instanceof z.ZodError) {
    return NextResponse.json(
      {
        error: 'Invalid request data',
        code: 'VALIDATION_ERROR',
        details: error.errors.map(e => ({
          path: e.path.join('.'),
          message: e.message,
        })),
      },
      { status: 400 }
    );
  }
  // Default error response
  return NextResponse.json(
    {
      error: 'An unexpected error occurred',
      code: 'INTERNAL_SERVER_ERROR',
    },
    { status: 500 }
  );
}
</file>

<file path="lib/middleware/rate-limit.ts">
import { NextRequest, NextResponse } from 'next/server';
import { cacheManager } from '../utils/cache-manager';
interface RateLimitConfig {
  windowMs: number;
  max: number;
}
const DEFAULT_CONFIG: RateLimitConfig = {
  windowMs: 60 * 1000, // 1 minute
  max: 60, // 60 requests per minute
};
export async function rateLimitMiddleware(
  req: NextRequest,
  config: RateLimitConfig = DEFAULT_CONFIG
) {
  const ip = req.ip || 'unknown';
  const key = `ratelimit:${ip}`;
  try {
    // Get current count from Redis
    const currentCount = await cacheManager.get<number>(key, 'MARKET_DATA');
    if (currentCount === null) {
      // First request in window
      await cacheManager.set(key, 1, 'MARKET_DATA', {
        ttl: config.windowMs,
      });
      return NextResponse.next();
    }
    if (currentCount >= config.max) {
      return NextResponse.json(
        {
          error: 'Too many requests',
          retryAfter: config.windowMs / 1000,
        },
        { 
          status: 429,
          headers: {
            'Retry-After': (config.windowMs / 1000).toString(),
          },
        }
      );
    }
    // Increment counter
    await cacheManager.set(key, currentCount + 1, 'MARKET_DATA', {
      ttl: config.windowMs,
    });
    return NextResponse.next();
  } catch (error) {
    console.error('Rate limit error:', error);
    // On error, allow the request to proceed
    return NextResponse.next();
  }
}
</file>

<file path="lib/services/analytics-service.ts">
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import type { MarketData, TechnicalIndicator } from '../types/market-data';
interface AnalyticsConfig {
  period: number;
  confidenceLevel?: number;
  smoothing?: number;
  outlierThreshold?: number;
}
interface AnalyticsResult {
  value: number;
  confidence: number;
  metadata: {
    timestamp: number;
    sampleSize: number;
    method: string;
  };
}
interface StatisticalSummary {
  mean: number;
  median: number;
  standardDeviation: number;
  skewness: number;
  kurtosis: number;
  min: number;
  max: number;
  sampleSize: number;
}
class AnalyticsService {
  private static instance: AnalyticsService;
  private constructor() {
    this.setupMetrics();
  }
  public static getInstance(): AnalyticsService {
    if (!AnalyticsService.instance) {
      AnalyticsService.instance = new AnalyticsService();
    }
    return AnalyticsService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'analytics_calculations',
      help: 'Number of analytics calculations performed',
      type: 'counter',
      labels: ['type', 'status'],
    });
    metrics.register({
      name: 'analytics_errors',
      help: 'Number of analytics calculation errors',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'analytics_duration',
      help: 'Duration of analytics calculations in milliseconds',
      type: 'histogram',
      labels: ['type'],
    });
  }
  async calculateVolatility(
    data: MarketData[],
    config: AnalyticsConfig
  ): Promise<AnalyticsResult> {
    const startTime = Date.now();
    try {
      const returns = this.calculateReturns(data);
      const stdDev = this.calculateStandardDeviation(returns);
      const annualizedVol = stdDev * Math.sqrt(252); // Annualize daily volatility
      metrics.record('analytics_calculations', 1, {
        type: 'volatility',
        status: 'success',
      });
      metrics.record('analytics_duration', Date.now() - startTime, {
        type: 'volatility',
      });
      return {
        value: annualizedVol,
        confidence: this.calculateConfidence(returns.length, config.confidenceLevel),
        metadata: {
          timestamp: Date.now(),
          sampleSize: returns.length,
          method: 'standard_deviation',
        },
      };
    } catch (error) {
      logger.error('Error calculating volatility:', error);
      metrics.record('analytics_errors', 1, { type: 'volatility' });
      throw error;
    }
  }
  async calculateMomentum(
    data: MarketData[],
    config: AnalyticsConfig
  ): Promise<AnalyticsResult> {
    const startTime = Date.now();
    try {
      const returns = this.calculateReturns(data);
      const momentum = this.calculateExponentialAverage(returns, config.smoothing || 0.2);
      metrics.record('analytics_calculations', 1, {
        type: 'momentum',
        status: 'success',
      });
      metrics.record('analytics_duration', Date.now() - startTime, {
        type: 'momentum',
      });
      return {
        value: momentum,
        confidence: this.calculateConfidence(returns.length, config.confidenceLevel),
        metadata: {
          timestamp: Date.now(),
          sampleSize: returns.length,
          method: 'exponential_average',
        },
      };
    } catch (error) {
      logger.error('Error calculating momentum:', error);
      metrics.record('analytics_errors', 1, { type: 'momentum' });
      throw error;
    }
  }
  async calculateCorrelation(
    data1: MarketData[],
    data2: MarketData[],
    config: AnalyticsConfig
  ): Promise<AnalyticsResult> {
    const startTime = Date.now();
    try {
      const returns1 = this.calculateReturns(data1);
      const returns2 = this.calculateReturns(data2);
      // Ensure equal length
      const minLength = Math.min(returns1.length, returns2.length);
      const correlation = this.calculatePearsonCorrelation(
        returns1.slice(-minLength),
        returns2.slice(-minLength)
      );
      metrics.record('analytics_calculations', 1, {
        type: 'correlation',
        status: 'success',
      });
      metrics.record('analytics_duration', Date.now() - startTime, {
        type: 'correlation',
      });
      return {
        value: correlation,
        confidence: this.calculateConfidence(minLength, config.confidenceLevel),
        metadata: {
          timestamp: Date.now(),
          sampleSize: minLength,
          method: 'pearson',
        },
      };
    } catch (error) {
      logger.error('Error calculating correlation:', error);
      metrics.record('analytics_errors', 1, { type: 'correlation' });
      throw error;
    }
  }
  async calculateStatistics(data: MarketData[]): Promise<StatisticalSummary> {
    const startTime = Date.now();
    try {
      const prices = data.map(d => d.price);
      const sortedPrices = [...prices].sort((a, b) => a - b);
      const mean = this.calculateMean(prices);
      const median = this.calculateMedian(sortedPrices);
      const stdDev = this.calculateStandardDeviation(prices);
      const skewness = this.calculateSkewness(prices, mean, stdDev);
      const kurtosis = this.calculateKurtosis(prices, mean, stdDev);
      metrics.record('analytics_calculations', 1, {
        type: 'statistics',
        status: 'success',
      });
      metrics.record('analytics_duration', Date.now() - startTime, {
        type: 'statistics',
      });
      return {
        mean,
        median,
        standardDeviation: stdDev,
        skewness,
        kurtosis,
        min: sortedPrices[0],
        max: sortedPrices[sortedPrices.length - 1],
        sampleSize: prices.length,
      };
    } catch (error) {
      logger.error('Error calculating statistics:', error);
      metrics.record('analytics_errors', 1, { type: 'statistics' });
      throw error;
    }
  }
  async detectOutliers(
    data: MarketData[],
    config: AnalyticsConfig
  ): Promise<number[]> {
    const startTime = Date.now();
    try {
      const prices = data.map(d => d.price);
      const stats = await this.calculateStatistics(data);
      const threshold = config.outlierThreshold || 2;
      const outlierIndices = prices.reduce((indices, price, index) => {
        const zScore = Math.abs((price - stats.mean) / stats.standardDeviation);
        if (zScore > threshold) {
          indices.push(index);
        }
        return indices;
      }, [] as number[]);
      metrics.record('analytics_calculations', 1, {
        type: 'outliers',
        status: 'success',
      });
      metrics.record('analytics_duration', Date.now() - startTime, {
        type: 'outliers',
      });
      return outlierIndices;
    } catch (error) {
      logger.error('Error detecting outliers:', error);
      metrics.record('analytics_errors', 1, { type: 'outliers' });
      throw error;
    }
  }
  private calculateReturns(data: MarketData[]): number[] {
    const returns: number[] = [];
    for (let i = 1; i < data.length; i++) {
      const returnValue = (data[i].price - data[i - 1].price) / data[i - 1].price;
      returns.push(returnValue);
    }
    return returns;
  }
  private calculateMean(values: number[]): number {
    return values.reduce((sum, value) => sum + value, 0) / values.length;
  }
  private calculateMedian(sortedValues: number[]): number {
    const mid = Math.floor(sortedValues.length / 2);
    return sortedValues.length % 2 === 0
      ? (sortedValues[mid - 1] + sortedValues[mid]) / 2
      : sortedValues[mid];
  }
  private calculateStandardDeviation(values: number[]): number {
    const mean = this.calculateMean(values);
    const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
    return Math.sqrt(this.calculateMean(squaredDiffs));
  }
  private calculateSkewness(
    values: number[],
    mean: number,
    stdDev: number
  ): number {
    const cubedDiffs = values.map(value =>
      Math.pow((value - mean) / stdDev, 3)
    );
    return this.calculateMean(cubedDiffs);
  }
  private calculateKurtosis(
    values: number[],
    mean: number,
    stdDev: number
  ): number {
    const fourthPowerDiffs = values.map(value =>
      Math.pow((value - mean) / stdDev, 4)
    );
    return this.calculateMean(fourthPowerDiffs) - 3; // Excess kurtosis
  }
  private calculateExponentialAverage(
    values: number[],
    smoothing: number
  ): number {
    let ema = values[0];
    for (let i = 1; i < values.length; i++) {
      ema = smoothing * values[i] + (1 - smoothing) * ema;
    }
    return ema;
  }
  private calculatePearsonCorrelation(
    values1: number[],
    values2: number[]
  ): number {
    const mean1 = this.calculateMean(values1);
    const mean2 = this.calculateMean(values2);
    const stdDev1 = this.calculateStandardDeviation(values1);
    const stdDev2 = this.calculateStandardDeviation(values2);
    const covariance = values1.reduce((sum, value, index) => {
      return sum + (value - mean1) * (values2[index] - mean2);
    }, 0) / values1.length;
    return covariance / (stdDev1 * stdDev2);
  }
  private calculateConfidence(
    sampleSize: number,
    confidenceLevel: number = 0.95
  ): number {
    // Simple confidence calculation based on sample size
    return Math.min(
      confidenceLevel,
      1 - 1 / Math.sqrt(sampleSize)
    );
  }
}
export const analyticsService = AnalyticsService.getInstance();
</file>

<file path="lib/services/auth-service.ts">
import { SignJWT, jwtVerify, JWTPayload } from 'jose';
import { nanoid } from 'nanoid';
import { z } from 'zod';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { cacheManager } from '../utils/cache-manager';
// Schema for user data
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  role: z.enum(['user', 'admin']),
  apiKey: z.string().optional(),
  permissions: z.array(z.string()).default([]),
});
export type User = z.infer<typeof UserSchema>;
// Schema for JWT payload
const JWTPayloadSchema = z.object({
  jti: z.string(),
  iat: z.number(),
  exp: z.number(),
  sub: z.string(),
  email: z.string(),
  role: z.enum(['user', 'admin']),
});
export type JWTData = z.infer<typeof JWTPayloadSchema>;
// Configuration
const AUTH_CONFIG = {
  JWT_SECRET: process.env.JWT_SECRET || 'your-secret-key',
  JWT_EXPIRY: '24h',
  REFRESH_TOKEN_EXPIRY: 30 * 24 * 60 * 60 * 1000, // 30 days
  API_KEY_PREFIX: 'pk_',
  MAX_ACTIVE_SESSIONS: 5,
};
class AuthService {
  private static instance: AuthService;
  private jwtSecret: Uint8Array;
  private constructor() {
    this.jwtSecret = new TextEncoder().encode(AUTH_CONFIG.JWT_SECRET);
    this.setupMetrics();
  }
  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'auth_login_attempts',
      help: 'Number of login attempts',
      type: 'counter',
      labels: ['status'],
    });
    metrics.register({
      name: 'auth_token_validations',
      help: 'Number of token validations',
      type: 'counter',
      labels: ['status'],
    });
    metrics.register({
      name: 'auth_active_sessions',
      help: 'Number of active sessions',
      type: 'gauge',
    });
  }
  async createToken(user: User): Promise<{ token: string; refreshToken: string }> {
    try {
      const jti = nanoid();
      const iat = Math.floor(Date.now() / 1000);
      // Create access token
      const token = await new SignJWT({
        sub: user.id,
        email: user.email,
        role: user.role,
      })
        .setProtectedHeader({ alg: 'HS256' })
        .setJti(jti)
        .setIssuedAt(iat)
        .setExpirationTime(AUTH_CONFIG.JWT_EXPIRY)
        .sign(this.jwtSecret);
      // Create refresh token
      const refreshToken = nanoid(64);
      // Store refresh token in cache
      await cacheManager.set(
        `refresh:${refreshToken}`,
        {
          userId: user.id,
          jti,
          createdAt: Date.now(),
        },
        'MARKET_DATA',
        {
          ttl: AUTH_CONFIG.REFRESH_TOKEN_EXPIRY,
          tags: ['auth', `user:${user.id}`],
        }
      );
      // Update active sessions count
      const activeSessions = await this.getActiveSessions(user.id);
      metrics.record('auth_active_sessions', activeSessions.length);
      return { token, refreshToken };
    } catch (error) {
      logger.error('Error creating token:', error);
      metrics.record('auth_login_attempts', 1, { status: 'error' });
      throw new Error('Failed to create authentication token');
    }
  }
  async verifyToken(token: string): Promise<JWTData> {
    try {
      const { payload } = await jwtVerify(token, this.jwtSecret);
      const validatedPayload = JWTPayloadSchema.parse(payload);
      metrics.record('auth_token_validations', 1, { status: 'success' });
      return validatedPayload;
    } catch (error) {
      logger.error('Error verifying token:', error);
      metrics.record('auth_token_validations', 1, { status: 'error' });
      throw new Error('Invalid authentication token');
    }
  }
  async refreshToken(refreshToken: string): Promise<{ token: string; refreshToken: string }> {
    try {
      // Get refresh token data from cache
      const tokenData = await cacheManager.get<{
        userId: string;
        jti: string;
        createdAt: number;
      }>(`refresh:${refreshToken}`, 'MARKET_DATA');
      if (!tokenData) {
        throw new Error('Invalid refresh token');
      }
      // Get user data
      const user = await this.getUserById(tokenData.userId);
      if (!user) {
        throw new Error('User not found');
      }
      // Invalidate old refresh token
      await cacheManager.invalidate(`refresh:${refreshToken}`, 'MARKET_DATA');
      // Create new tokens
      return this.createToken(user);
    } catch (error) {
      logger.error('Error refreshing token:', error);
      throw new Error('Failed to refresh token');
    }
  }
  async revokeToken(userId: string, jti?: string) {
    try {
      if (jti) {
        // Revoke specific token
        await cacheManager.invalidate(`token:${jti}`, 'MARKET_DATA');
      } else {
        // Revoke all user's tokens
        await cacheManager.invalidateByTag(`user:${userId}`);
      }
      // Update active sessions count
      const activeSessions = await this.getActiveSessions(userId);
      metrics.record('auth_active_sessions', activeSessions.length);
    } catch (error) {
      logger.error('Error revoking token:', error);
      throw new Error('Failed to revoke token');
    }
  }
  async generateApiKey(userId: string): Promise<string> {
    const apiKey = `${AUTH_CONFIG.API_KEY_PREFIX}${nanoid(32)}`;
    try {
      await cacheManager.set(
        `apikey:${apiKey}`,
        { userId },
        'MARKET_DATA',
        {
          ttl: 0, // No expiry
          tags: ['auth', `user:${userId}`],
        }
      );
      return apiKey;
    } catch (error) {
      logger.error('Error generating API key:', error);
      throw new Error('Failed to generate API key');
    }
  }
  async validateApiKey(apiKey: string): Promise<User | null> {
    try {
      const keyData = await cacheManager.get<{ userId: string }>(
        `apikey:${apiKey}`,
        'MARKET_DATA'
      );
      if (!keyData) {
        return null;
      }
      return this.getUserById(keyData.userId);
    } catch (error) {
      logger.error('Error validating API key:', error);
      return null;
    }
  }
  async revokeApiKey(apiKey: string) {
    try {
      await cacheManager.invalidate(`apikey:${apiKey}`, 'MARKET_DATA');
    } catch (error) {
      logger.error('Error revoking API key:', error);
      throw new Error('Failed to revoke API key');
    }
  }
  private async getActiveSessions(userId: string): Promise<string[]> {
    try {
      const sessions = await cacheManager.get<string[]>(
        `sessions:${userId}`,
        'MARKET_DATA'
      );
      return sessions || [];
    } catch (error) {
      logger.error('Error getting active sessions:', error);
      return [];
    }
  }
  private async getUserById(userId: string): Promise<User | null> {
    // This is a placeholder. In a real application, you would fetch the user from your database
    const mockUser: User = {
      id: userId,
      email: 'user@example.com',
      role: 'user',
      permissions: ['read:market-data'],
    };
    return mockUser;
  }
}
export const authService = AuthService.getInstance();
</file>

<file path="lib/services/dashboard-service.ts">
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { visualizationService } from './visualization-service';
import { analyticsService } from './analytics-service';
import { marketDataService } from './market-data-service';
import type { MarketData, ChartConfig } from '../types/market-data';
interface DashboardConfig {
  layout: 'grid' | 'flex' | 'custom';
  theme: 'light' | 'dark';
  refreshInterval: number;
  maxWidgets: number;
}
interface WidgetConfig {
  id: string;
  type: 'chart' | 'stats' | 'news' | 'alerts';
  position: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  settings: any;
}
interface DashboardState {
  widgets: Map<string, WidgetConfig>;
  activeSymbols: Set<string>;
  layout: string;
  theme: string;
}
const DEFAULT_CONFIG: DashboardConfig = {
  layout: 'grid',
  theme: 'light',
  refreshInterval: 5000,
  maxWidgets: 12,
} as const;
class DashboardService extends EventEmitter {
  private static instance: DashboardService;
  private state: DashboardState;
  private updateInterval: NodeJS.Timeout | null = null;
  private widgetSubscriptions: Map<string, () => void> = new Map();
  private marketDataCache: Map<string, MarketData> = new Map();
  private constructor() {
    super();
    this.state = {
      widgets: new Map(),
      activeSymbols: new Set(),
      layout: DEFAULT_CONFIG.layout,
      theme: DEFAULT_CONFIG.theme,
    };
    this.setupMetrics();
  }
  public static getInstance(): DashboardService {
    if (!DashboardService.instance) {
      DashboardService.instance = new DashboardService();
    }
    return DashboardService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'dashboard_widgets',
      help: 'Number of active dashboard widgets',
      type: 'gauge',
      labels: ['type'],
    });
    metrics.register({
      name: 'dashboard_updates',
      help: 'Number of dashboard updates',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'dashboard_errors',
      help: 'Number of dashboard errors',
      type: 'counter',
      labels: ['type'],
    });
  }
  async initialize(config: Partial<DashboardConfig> = {}): Promise<void> {
    try {
      const fullConfig = { ...DEFAULT_CONFIG, ...config };
      this.state.layout = fullConfig.layout;
      this.state.theme = fullConfig.theme;
      // Set up auto-refresh
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
      }
      this.updateInterval = setInterval(
        () => this.refreshDashboard(),
        fullConfig.refreshInterval
      );
      metrics.record('dashboard_updates', 1, { type: 'initialization' });
    } catch (error) {
      logger.error('Error initializing dashboard:', error);
      metrics.record('dashboard_errors', 1, { type: 'initialization' });
      throw error;
    }
  }
  async addWidget(config: WidgetConfig): Promise<void> {
    try {
      if (this.state.widgets.size >= DEFAULT_CONFIG.maxWidgets) {
        throw new Error('Maximum number of widgets reached');
      }
      this.state.widgets.set(config.id, config);
      await this.setupWidgetSubscriptions(config);
      metrics.record('dashboard_widgets', this.state.widgets.size, {
        type: config.type,
      });
      metrics.record('dashboard_updates', 1, { type: 'widget_add' });
      this.emit('widgetAdded', config);
    } catch (error) {
      logger.error('Error adding widget:', error);
      metrics.record('dashboard_errors', 1, { type: 'widget_add' });
      throw error;
    }
  }
  async removeWidget(widgetId: string): Promise<void> {
    try {
      const widget = this.state.widgets.get(widgetId);
      if (!widget) return;
      // Clean up subscriptions
      const unsubscribe = this.widgetSubscriptions.get(widgetId);
      if (unsubscribe) {
        unsubscribe();
        this.widgetSubscriptions.delete(widgetId);
      }
      this.state.widgets.delete(widgetId);
      metrics.record('dashboard_widgets', this.state.widgets.size, {
        type: widget.type,
      });
      metrics.record('dashboard_updates', 1, { type: 'widget_remove' });
      this.emit('widgetRemoved', widgetId);
    } catch (error) {
      logger.error('Error removing widget:', error);
      metrics.record('dashboard_errors', 1, { type: 'widget_remove' });
      throw error;
    }
  }
  async updateWidget(
    widgetId: string,
    updates: Partial<WidgetConfig>
  ): Promise<void> {
    try {
      const widget = this.state.widgets.get(widgetId);
      if (!widget) return;
      const updatedConfig = { ...widget, ...updates };
      this.state.widgets.set(widgetId, updatedConfig);
      // Update subscriptions if necessary
      if (updates.settings?.symbol !== widget.settings?.symbol) {
        await this.setupWidgetSubscriptions(updatedConfig);
      }
      metrics.record('dashboard_updates', 1, { type: 'widget_update' });
      this.emit('widgetUpdated', updatedConfig);
    } catch (error) {
      logger.error('Error updating widget:', error);
      metrics.record('dashboard_errors', 1, { type: 'widget_update' });
      throw error;
    }
  }
  private async setupWidgetSubscriptions(widget: WidgetConfig): Promise<void> {
    // Clean up existing subscription
    const unsubscribe = this.widgetSubscriptions.get(widget.id);
    if (unsubscribe) {
      unsubscribe();
    }
    if (widget.type === 'chart' && widget.settings?.symbol) {
      const symbol = widget.settings.symbol;
      this.state.activeSymbols.add(symbol);
      const callback = async (data: MarketData) => {
        try {
          // Cache the market data
          this.marketDataCache.set(symbol, data);
          const chartData = await visualizationService.prepareChartData(
            [data],
            widget.settings.chartConfig as ChartConfig
          );
          this.emit('widgetData', { widgetId: widget.id, data: chartData });
        } catch (error) {
          logger.error(`Error updating chart widget ${widget.id}:`, error);
        }
      };
      await marketDataService.subscribe(symbol, callback);
      this.widgetSubscriptions.set(widget.id, () => {
        marketDataService.unsubscribe(symbol, callback);
        this.state.activeSymbols.delete(symbol);
        this.marketDataCache.delete(symbol);
      });
    }
  }
  private async refreshDashboard(): Promise<void> {
    try {
      const updates = await Promise.all(
        Array.from(this.state.widgets.values()).map(async widget => {
          if (widget.type === 'stats' && widget.settings?.symbol) {
            const data = await this.fetchWidgetStatistics(widget);
            return { widgetId: widget.id, data };
          }
          return null;
        })
      );
      updates.filter(Boolean).forEach(update => {
        if (update) {
          this.emit('widgetData', update);
        }
      });
      metrics.record('dashboard_updates', 1, { type: 'refresh' });
    } catch (error) {
      logger.error('Error refreshing dashboard:', error);
      metrics.record('dashboard_errors', 1, { type: 'refresh' });
    }
  }
  private async fetchWidgetStatistics(widget: WidgetConfig): Promise<any> {
    const symbol = widget.settings.symbol;
    const marketData = this.marketDataCache.get(symbol);
    if (!marketData) return null;
    switch (widget.settings.statsType) {
      case 'volatility':
        return analyticsService.calculateVolatility([marketData], {
          period: widget.settings.period || 14,
        });
      case 'momentum':
        return analyticsService.calculateMomentum([marketData], {
          period: widget.settings.period || 14,
          smoothing: widget.settings.smoothing || 0.2,
        });
      case 'statistics':
        return analyticsService.calculateStatistics([marketData]);
      default:
        return null;
    }
  }
  getWidgetConfig(widgetId: string): WidgetConfig | undefined {
    return this.state.widgets.get(widgetId);
  }
  getAllWidgets(): WidgetConfig[] {
    return Array.from(this.state.widgets.values());
  }
  getActiveSymbols(): string[] {
    return Array.from(this.state.activeSymbols);
  }
  getDashboardState(): DashboardState {
    return { ...this.state };
  }
  setTheme(theme: DashboardConfig['theme']): void {
    this.state.theme = theme;
    this.emit('themeChanged', theme);
  }
  setLayout(layout: DashboardConfig['layout']): void {
    this.state.layout = layout;
    this.emit('layoutChanged', layout);
  }
}
export const dashboardService = DashboardService.getInstance();
</file>

<file path="lib/services/data-transform-service.ts">
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { dataValidationService } from './data-validation-service';
import type { MarketData, TechnicalIndicator, CompanyInfo, NewsItem } from '../types/market-data';
interface TransformOptions {
  normalize?: boolean;
  validate?: boolean;
  format?: 'compact' | 'full';
}
class DataTransformService {
  private static instance: DataTransformService;
  private constructor() {
    this.setupMetrics();
  }
  public static getInstance(): DataTransformService {
    if (!DataTransformService.instance) {
      DataTransformService.instance = new DataTransformService();
    }
    return DataTransformService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'data_transformations',
      help: 'Number of data transformations',
      type: 'counter',
      labels: ['type', 'status'],
    });
    metrics.register({
      name: 'data_transform_errors',
      help: 'Number of transformation errors',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'data_transform_duration',
      help: 'Duration of data transformations in milliseconds',
      type: 'histogram',
      labels: ['type'],
    });
  }
  async transformMarketData(
    data: unknown,
    source: 'polygon' | 'alternative',
    options: TransformOptions = {}
  ): Promise<MarketData> {
    const startTime = Date.now();
    try {
      let transformed: MarketData;
      if (source === 'polygon') {
        transformed = {
          symbol: (data as any).T || (data as any).symbol,
          price: (data as any).p || (data as any).price,
          change: (data as any).c || (data as any).change,
          changePercent: (data as any).P || (data as any).changePercent,
          volume: (data as any).v || (data as any).volume,
          lastUpdated: Date.now(),
          metadata: {
            source: 'rest',
            reliability: 1,
            staleness: 0,
          },
        };
      } else {
        // Transform alternative source format
        transformed = {
          symbol: (data as any).symbol,
          price: (data as any).lastPrice,
          change: (data as any).priceChange,
          changePercent: (data as any).percentChange,
          volume: (data as any).volume,
          lastUpdated: Date.now(),
          metadata: {
            source: 'rest',
            reliability: 0.9,
            staleness: 0,
          },
        };
      }
      if (options.normalize) {
        transformed = this.normalizeMarketData(transformed);
      }
      if (options.validate) {
        transformed = await dataValidationService.validateMarketData(transformed);
      }
      metrics.record('data_transformations', 1, {
        type: 'market_data',
        status: 'success',
      });
      metrics.record('data_transform_duration', Date.now() - startTime, {
        type: 'market_data',
      });
      return transformed;
    } catch (error) {
      logger.error('Error transforming market data:', error);
      metrics.record('data_transform_errors', 1, { type: 'market_data' });
      throw error;
    }
  }
  async transformTechnicalIndicator(
    data: unknown,
    indicator: string,
    period: number,
    options: TransformOptions = {}
  ): Promise<TechnicalIndicator> {
    const startTime = Date.now();
    try {
      let transformed: TechnicalIndicator = {
        timestamp: (data as any).t || Date.now(),
        value: (data as any).v || (data as any).value,
        indicator: indicator as any,
        period,
        metadata: {
          source: (data as any).source || 'calculation',
          confidence: (data as any).confidence || 1,
        },
      };
      if (options.validate) {
        transformed = await dataValidationService.validateTechnicalIndicator(transformed);
      }
      metrics.record('data_transformations', 1, {
        type: 'technical_indicator',
        status: 'success',
      });
      metrics.record('data_transform_duration', Date.now() - startTime, {
        type: 'technical_indicator',
      });
      return transformed;
    } catch (error) {
      logger.error('Error transforming technical indicator:', error);
      metrics.record('data_transform_errors', 1, { type: 'technical_indicator' });
      throw error;
    }
  }
  async transformCompanyInfo(
    data: unknown,
    options: TransformOptions = {}
  ): Promise<CompanyInfo> {
    const startTime = Date.now();
    try {
      let transformed: CompanyInfo = {
        symbol: (data as any).symbol || (data as any).ticker,
        name: (data as any).name || (data as any).companyName,
        description: (data as any).description || (data as any).about,
        sector: (data as any).sector,
        industry: (data as any).industry,
        employees: (data as any).employees || (data as any).employeeCount,
        website: (data as any).website || (data as any).url,
        marketCap: (data as any).marketCap,
        metadata: {
          lastUpdated: Date.now(),
          source: (data as any).source || 'api',
          reliability: 1,
        },
      };
      if (options.validate) {
        transformed = await dataValidationService.validateCompanyInfo(transformed);
      }
      metrics.record('data_transformations', 1, {
        type: 'company_info',
        status: 'success',
      });
      metrics.record('data_transform_duration', Date.now() - startTime, {
        type: 'company_info',
      });
      return transformed;
    } catch (error) {
      logger.error('Error transforming company info:', error);
      metrics.record('data_transform_errors', 1, { type: 'company_info' });
      throw error;
    }
  }
  async transformNewsItem(
    data: unknown,
    options: TransformOptions = {}
  ): Promise<NewsItem> {
    const startTime = Date.now();
    try {
      let transformed: NewsItem = {
        id: (data as any).id || (data as any).newsId,
        title: (data as any).title || (data as any).headline,
        summary: (data as any).summary || (data as any).description,
        url: (data as any).url || (data as any).link,
        source: (data as any).source || (data as any).provider,
        publishedAt: (data as any).publishedAt || (data as any).timestamp,
        symbols: (data as any).symbols || (data as any).tickers || [],
        sentiment: (data as any).sentiment && {
          score: (data as any).sentiment.score,
          confidence: (data as any).sentiment.confidence,
        },
      };
      if (options.validate) {
        transformed = await dataValidationService.validateNewsItem(transformed);
      }
      metrics.record('data_transformations', 1, {
        type: 'news_item',
        status: 'success',
      });
      metrics.record('data_transform_duration', Date.now() - startTime, {
        type: 'news_item',
      });
      return transformed;
    } catch (error) {
      logger.error('Error transforming news item:', error);
      metrics.record('data_transform_errors', 1, { type: 'news_item' });
      throw error;
    }
  }
  private normalizeMarketData(data: MarketData): MarketData {
    // Normalize price to 2 decimal places
    data.price = Number(data.price.toFixed(2));
    // Normalize change to 2 decimal places
    data.change = Number(data.change.toFixed(2));
    // Normalize change percent to 2 decimal places
    data.changePercent = Number(data.changePercent.toFixed(2));
    // Normalize volume to whole numbers
    data.volume = Math.round(data.volume);
    return data;
  }
  async transformBatch<T>(
    items: unknown[],
    transformFn: (item: unknown) => Promise<T>,
    options: TransformOptions & { stopOnError?: boolean } = {}
  ): Promise<{ transformed: T[]; errors: Error[] }> {
    const startTime = Date.now();
    const transformed: T[] = [];
    const errors: Error[] = [];
    for (const item of items) {
      try {
        const result = await transformFn(item);
        transformed.push(result);
      } catch (error) {
        errors.push(error as Error);
        if (options.stopOnError) break;
      }
    }
    metrics.record('data_transformations', items.length, {
      type: 'batch',
      status: errors.length === 0 ? 'success' : 'partial',
    });
    metrics.record('data_transform_duration', Date.now() - startTime, {
      type: 'batch',
    });
    if (errors.length > 0) {
      metrics.record('data_transform_errors', errors.length, { type: 'batch' });
    }
    return { transformed, errors };
  }
}
export const dataTransformService = DataTransformService.getInstance();
</file>

<file path="lib/services/data-validation-service.ts">
import { z } from 'zod';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
// Base schemas for common data structures
const PriceSchema = z.number().min(0).max(1000000);
const VolumeSchema = z.number().min(0);
const PercentageSchema = z.number().min(-100).max(100);
const TimestampSchema = z.number().min(0);
const SymbolSchema = z.string().regex(/^[A-Z]{1,5}$/);
// Market data validation schemas
export const MarketDataSchema = z.object({
  symbol: SymbolSchema,
  price: PriceSchema,
  change: z.number(),
  changePercent: PercentageSchema,
  volume: VolumeSchema,
  lastUpdated: TimestampSchema,
  metadata: z.object({
    source: z.enum(['websocket', 'rest', 'cache']),
    reliability: z.number().min(0).max(1),
    staleness: z.number().min(0),
  }),
});
// Technical indicator schemas
export const TechnicalIndicatorSchema = z.object({
  timestamp: TimestampSchema,
  value: z.number(),
  indicator: z.enum(['SMA', 'EMA', 'RSI', 'MACD']),
  period: z.number().min(1),
  metadata: z.object({
    source: z.string(),
    confidence: z.number().min(0).max(1),
  }).optional(),
});
// Company information schema
export const CompanyInfoSchema = z.object({
  symbol: SymbolSchema,
  name: z.string(),
  description: z.string(),
  sector: z.string(),
  industry: z.string(),
  employees: z.number().optional(),
  website: z.string().url().optional(),
  marketCap: z.number().optional(),
  metadata: z.object({
    lastUpdated: TimestampSchema,
    source: z.string(),
    reliability: z.number().min(0).max(1),
  }),
});
// News item schema
export const NewsItemSchema = z.object({
  id: z.string(),
  title: z.string(),
  summary: z.string(),
  url: z.string().url(),
  source: z.string(),
  publishedAt: TimestampSchema,
  symbols: z.array(SymbolSchema),
  sentiment: z.object({
    score: z.number().min(-1).max(1),
    confidence: z.number().min(0).max(1),
  }).optional(),
});
// WebSocket message schemas
export const WebSocketMessageSchema = z.object({
  type: z.enum(['trade', 'quote', 'aggregate']),
  data: z.unknown().default(null),
  timestamp: TimestampSchema,
});
// Validation error types
export class ValidationError extends Error {
  constructor(
    message: string,
    public errors: z.ZodError[],
    public data: unknown
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
class DataValidationService {
  private static instance: DataValidationService;
  private constructor() {
    this.setupMetrics();
  }
  public static getInstance(): DataValidationService {
    if (!DataValidationService.instance) {
      DataValidationService.instance = new DataValidationService();
    }
    return DataValidationService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'data_validation_total',
      help: 'Total number of data validations',
      type: 'counter',
      labels: ['type', 'status'],
    });
    metrics.register({
      name: 'data_validation_errors',
      help: 'Number of validation errors',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'data_validation_duration',
      help: 'Duration of data validation in milliseconds',
      type: 'histogram',
      labels: ['type'],
    });
  }
  async validateMarketData(data: unknown): Promise<z.infer<typeof MarketDataSchema>> {
    const startTime = Date.now();
    try {
      const validatedData = MarketDataSchema.parse(data);
      metrics.record('data_validation_total', 1, {
        type: 'market_data',
        status: 'success',
      });
      metrics.record('data_validation_duration', Date.now() - startTime, {
        type: 'market_data',
      });
      return validatedData;
    } catch (error) {
      metrics.record('data_validation_total', 1, {
        type: 'market_data',
        status: 'error',
      });
      metrics.record('data_validation_errors', 1, { type: 'market_data' });
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid market data', [error], data);
      }
      throw error;
    }
  }
  async validateTechnicalIndicator(data: unknown): Promise<z.infer<typeof TechnicalIndicatorSchema>> {
    const startTime = Date.now();
    try {
      const validatedData = TechnicalIndicatorSchema.parse(data);
      metrics.record('data_validation_total', 1, {
        type: 'technical_indicator',
        status: 'success',
      });
      metrics.record('data_validation_duration', Date.now() - startTime, {
        type: 'technical_indicator',
      });
      return validatedData;
    } catch (error) {
      metrics.record('data_validation_total', 1, {
        type: 'technical_indicator',
        status: 'error',
      });
      metrics.record('data_validation_errors', 1, { type: 'technical_indicator' });
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid technical indicator data', [error], data);
      }
      throw error;
    }
  }
  async validateCompanyInfo(data: unknown): Promise<z.infer<typeof CompanyInfoSchema>> {
    const startTime = Date.now();
    try {
      const validatedData = CompanyInfoSchema.parse(data);
      metrics.record('data_validation_total', 1, {
        type: 'company_info',
        status: 'success',
      });
      metrics.record('data_validation_duration', Date.now() - startTime, {
        type: 'company_info',
      });
      return validatedData;
    } catch (error) {
      metrics.record('data_validation_total', 1, {
        type: 'company_info',
        status: 'error',
      });
      metrics.record('data_validation_errors', 1, { type: 'company_info' });
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid company information', [error], data);
      }
      throw error;
    }
  }
  async validateNewsItem(data: unknown): Promise<z.infer<typeof NewsItemSchema>> {
    const startTime = Date.now();
    try {
      const validatedData = NewsItemSchema.parse(data);
      metrics.record('data_validation_total', 1, {
        type: 'news_item',
        status: 'success',
      });
      metrics.record('data_validation_duration', Date.now() - startTime, {
        type: 'news_item',
      });
      return validatedData;
    } catch (error) {
      metrics.record('data_validation_total', 1, {
        type: 'news_item',
        status: 'error',
      });
      metrics.record('data_validation_errors', 1, { type: 'news_item' });
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid news item', [error], data);
      }
      throw error;
    }
  }
  async validateWebSocketMessage(data: unknown): Promise<z.infer<typeof WebSocketMessageSchema>> {
    const startTime = Date.now();
    try {
      const validatedData = WebSocketMessageSchema.parse(data);
      metrics.record('data_validation_total', 1, {
        type: 'websocket_message',
        status: 'success',
      });
      metrics.record('data_validation_duration', Date.now() - startTime, {
        type: 'websocket_message',
      });
      return validatedData;
    } catch (error) {
      metrics.record('data_validation_total', 1, {
        type: 'websocket_message',
        status: 'error',
      });
      metrics.record('data_validation_errors', 1, { type: 'websocket_message' });
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid WebSocket message', [error], data);
      }
      throw error;
    }
  }
  async validateBatch<T>(
    items: unknown[],
    schema: z.ZodSchema<T>,
    options: { stopOnFirst?: boolean } = {}
  ): Promise<{ valid: T[]; errors: ValidationError[] }> {
    const startTime = Date.now();
    const valid: T[] = [];
    const errors: ValidationError[] = [];
    for (const item of items) {
      try {
        valid.push(schema.parse(item));
      } catch (error) {
        if (error instanceof z.ZodError) {
          errors.push(new ValidationError('Validation failed', [error], item));
          if (options.stopOnFirst) break;
        } else {
          throw error;
        }
      }
    }
    metrics.record('data_validation_total', items.length, {
      type: 'batch',
      status: errors.length === 0 ? 'success' : 'partial',
    });
    metrics.record('data_validation_duration', Date.now() - startTime, {
      type: 'batch',
    });
    if (errors.length > 0) {
      metrics.record('data_validation_errors', errors.length, { type: 'batch' });
    }
    return { valid, errors };
  }
  // Type guard utilities
  isMarketData(data: unknown): data is z.infer<typeof MarketDataSchema> {
    try {
      MarketDataSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }
  isTechnicalIndicator(data: unknown): data is z.infer<typeof TechnicalIndicatorSchema> {
    try {
      TechnicalIndicatorSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }
  isCompanyInfo(data: unknown): data is z.infer<typeof CompanyInfoSchema> {
    try {
      CompanyInfoSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }
  isNewsItem(data: unknown): data is z.infer<typeof NewsItemSchema> {
    try {
      NewsItemSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  }
}
export const dataValidationService = DataValidationService.getInstance();
</file>

<file path="lib/services/market-data-service.ts">
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { cacheManager } from '../utils/cache-manager';
import { dataValidationService } from './data-validation-service';
import { webSocketService } from './websocket-service';
interface MarketDataConfig {
  refreshInterval?: number;
  cacheTTL?: number;
  batchSize?: number;
  maxRetries?: number;
  retryDelay?: number;
}
const DEFAULT_CONFIG = {
  refreshInterval: 5000, // 5 seconds
  cacheTTL: 60000, // 1 minute
  batchSize: 100,
  maxRetries: 3,
  retryDelay: 1000,
} as const;
class MarketDataService extends EventEmitter {
  private static instance: MarketDataService;
  private subscriptions: Map<string, Set<(data: any) => void>> = new Map();
  private updateQueue: Set<string> = new Set();
  private updateTimeout: NodeJS.Timeout | null = null;
  private retryAttempts: Map<string, number> = new Map();
  private lastUpdate: Map<string, number> = new Map();
  private constructor() {
    super();
    this.setupMetrics();
    this.setupWebSocket();
  }
  public static getInstance(): MarketDataService {
    if (!MarketDataService.instance) {
      MarketDataService.instance = new MarketDataService();
    }
    return MarketDataService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'market_data_updates',
      help: 'Number of market data updates',
      type: 'counter',
      labels: ['type', 'source'],
    });
    metrics.register({
      name: 'market_data_errors',
      help: 'Number of market data errors',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'market_data_latency',
      help: 'Market data update latency in milliseconds',
      type: 'histogram',
      labels: ['type'],
    });
  }
  private setupWebSocket() {
    const wsUrl = process.env.MARKET_DATA_WS_URL || 'wss://example.com/market-data';
    webSocketService.connect(wsUrl).catch(error => {
      logger.error('Failed to connect to market data WebSocket:', error);
    });
    webSocketService.on('messages', ({ messages }) => {
      for (const message of messages) {
        if (message.type === 'trade' || message.type === 'quote') {
          this.handleWebSocketUpdate(message);
        }
      }
    });
  }
  private async handleWebSocketUpdate(message: any) {
    try {
      const validatedData = await dataValidationService.validateMarketData(message.data);
      // Update cache
      await this.updateCache(validatedData.symbol, validatedData);
      // Notify subscribers
      this.notifySubscribers(validatedData.symbol, validatedData);
      metrics.record('market_data_updates', 1, {
        type: message.type,
        source: 'websocket',
      });
    } catch (error) {
      logger.error('Error handling WebSocket update:', error);
      metrics.record('market_data_errors', 1, { type: 'websocket' });
    }
  }
  private async updateCache(symbol: string, data: any) {
    try {
      await cacheManager.set(
        symbol,
        data,
        'MARKET_DATA',
        {
          ttl: DEFAULT_CONFIG.cacheTTL,
          tags: ['market-data', symbol],
        }
      );
      this.lastUpdate.set(symbol, Date.now());
    } catch (error) {
      logger.error(`Error updating cache for symbol ${symbol}:`, error);
      metrics.record('market_data_errors', 1, { type: 'cache' });
    }
  }
  private notifySubscribers(symbol: string, data: any) {
    const subscribers = this.subscriptions.get(symbol);
    if (subscribers) {
      subscribers.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          logger.error(`Error in subscriber callback for symbol ${symbol}:`, error);
        }
      });
    }
  }
  async subscribe(
    symbol: string,
    callback: (data: any) => void,
    config: Partial<MarketDataConfig> = {}
  ): Promise<void> {
    const fullConfig = { ...DEFAULT_CONFIG, ...config };
    // Add to subscribers
    if (!this.subscriptions.has(symbol)) {
      this.subscriptions.set(symbol, new Set());
    }
    this.subscriptions.get(symbol)?.add(callback);
    try {
      // Get initial data
      const cachedData = await cacheManager.get(symbol, 'MARKET_DATA');
      if (cachedData) {
        callback(cachedData);
      } else {
        // Queue for update
        this.queueUpdate(symbol);
      }
      // Subscribe to WebSocket updates
      webSocketService.subscribe(
        process.env.MARKET_DATA_WS_URL || 'wss://example.com/market-data',
        symbol
      );
      // Set up polling if requested
      if (fullConfig.refreshInterval) {
        setInterval(() => this.queueUpdate(symbol), fullConfig.refreshInterval);
      }
    } catch (error) {
      logger.error(`Error subscribing to symbol ${symbol}:`, error);
      metrics.record('market_data_errors', 1, { type: 'subscription' });
      throw error;
    }
  }
  async unsubscribe(symbol: string, callback: (data: any) => void): Promise<void> {
    const subscribers = this.subscriptions.get(symbol);
    if (subscribers) {
      subscribers.delete(callback);
      if (subscribers.size === 0) {
        this.subscriptions.delete(symbol);
        webSocketService.unsubscribe(
          process.env.MARKET_DATA_WS_URL || 'wss://example.com/market-data',
          symbol
        );
      }
    }
  }
  private queueUpdate(symbol: string) {
    this.updateQueue.add(symbol);
    this.scheduleUpdate();
  }
  private scheduleUpdate() {
    if (this.updateTimeout) return;
    this.updateTimeout = setTimeout(() => {
      this.processBatchUpdate();
      this.updateTimeout = null;
    }, 100); // Process updates every 100ms
  }
  private async processBatchUpdate() {
    if (this.updateQueue.size === 0) return;
    const symbols = Array.from(this.updateQueue);
    this.updateQueue.clear();
    // Split into batches
    for (let i = 0; i < symbols.length; i += DEFAULT_CONFIG.batchSize) {
      const batch = symbols.slice(i, i + DEFAULT_CONFIG.batchSize);
      await this.fetchBatchUpdate(batch);
    }
  }
  private async fetchBatchUpdate(symbols: string[]) {
    try {
      const startTime = Date.now();
      const response = await fetch('/api/market-data/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ symbols }),
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Process each symbol's data
      for (const [symbol, marketData] of Object.entries(data)) {
        try {
          const validatedData = await dataValidationService.validateMarketData(marketData);
          await this.updateCache(symbol, validatedData);
          this.notifySubscribers(symbol, validatedData);
          metrics.record('market_data_updates', 1, {
            type: 'batch',
            source: 'rest',
          });
          metrics.record('market_data_latency', Date.now() - startTime, {
            type: 'batch',
          });
        } catch (error) {
          logger.error(`Error processing data for symbol ${symbol}:`, error);
          this.handleUpdateError(symbol);
        }
      }
    } catch (error) {
      logger.error('Error fetching batch update:', error);
      metrics.record('market_data_errors', 1, { type: 'batch' });
      // Requeue failed symbols with backoff
      symbols.forEach(symbol => this.handleUpdateError(symbol));
    }
  }
  private handleUpdateError(symbol: string) {
    const attempts = (this.retryAttempts.get(symbol) || 0) + 1;
    this.retryAttempts.set(symbol, attempts);
    if (attempts <= DEFAULT_CONFIG.maxRetries) {
      const delay = Math.min(
        DEFAULT_CONFIG.retryDelay * Math.pow(2, attempts - 1),
        30000
      );
      setTimeout(() => {
        this.queueUpdate(symbol);
      }, delay);
    } else {
      logger.error(`Max retry attempts reached for symbol ${symbol}`);
      this.retryAttempts.delete(symbol);
      this.emit('maxRetries', symbol);
    }
  }
  async getLastUpdate(symbol: string): Promise<number | null> {
    return this.lastUpdate.get(symbol) || null;
  }
  async getSubscriberCount(symbol: string): Promise<number> {
    return this.subscriptions.get(symbol)?.size || 0;
  }
}
export const marketDataService = MarketDataService.getInstance();
</file>

<file path="lib/services/rate-limiter.ts">
import { cacheManager } from '../utils/cache-manager';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
interface RateLimitConfig {
  points: number;
  duration: number;
  blockDuration?: number;
}
interface RateLimitInfo {
  remaining: number;
  reset: number;
  total: number;
  blocked?: boolean;
  blockExpiry?: number;
}
const RATE_LIMIT_DEFAULTS = {
  API: {
    points: 100,
    duration: 60, // 1 minute
    blockDuration: 300, // 5 minutes
  },
  WEBSOCKET: {
    points: 1000,
    duration: 60,
    blockDuration: 300,
  },
};
class RateLimiterService {
  private static instance: RateLimiterService;
  private constructor() {
    this.setupMetrics();
  }
  public static getInstance(): RateLimiterService {
    if (!RateLimiterService.instance) {
      RateLimiterService.instance = new RateLimiterService();
    }
    return RateLimiterService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'rate_limit_requests',
      help: 'Number of rate-limited requests',
      type: 'counter',
      labels: ['status', 'type'],
    });
    metrics.register({
      name: 'rate_limit_blocks',
      help: 'Number of rate limit blocks',
      type: 'counter',
      labels: ['type'],
    });
  }
  private generateKeys(identifier: string, type: 'API' | 'WEBSOCKET') {
    const prefix = `ratelimit:${type.toLowerCase()}`;
    return {
      points: `${prefix}:${identifier}:points`,
      block: `${prefix}:${identifier}:block`,
    };
  }
  async consume(
    identifier: string,
    type: 'API' | 'WEBSOCKET' = 'API',
    config: RateLimitConfig = RATE_LIMIT_DEFAULTS[type]
  ): Promise<RateLimitInfo> {
    const keys = this.generateKeys(identifier, type);
    const now = Math.floor(Date.now() / 1000);
    try {
      // Check if blocked
      const blocked = await cacheManager.get<boolean>(keys.block, 'MARKET_DATA');
      if (blocked) {
        const blockExpiry = await this.getKeyTTL(keys.block);
        metrics.record('rate_limit_requests', 1, { status: 'blocked', type });
        return {
          remaining: 0,
          reset: now + blockExpiry,
          total: config.points,
          blocked: true,
          blockExpiry: blockExpiry,
        };
      }
      // Get current points
      const pointsData = await cacheManager.get<{
        points: number;
        expires: number;
      }>(keys.points, 'MARKET_DATA');
      if (!pointsData) {
        // First request
        await cacheManager.set(
          keys.points,
          { points: config.points - 1, expires: now + config.duration },
          'MARKET_DATA',
          { ttl: config.duration * 1000 }
        );
        metrics.record('rate_limit_requests', 1, { status: 'allowed', type });
        return {
          remaining: config.points - 1,
          reset: now + config.duration,
          total: config.points,
        };
      }
      // Check if expired
      if (now >= pointsData.expires) {
        await cacheManager.set(
          keys.points,
          { points: config.points - 1, expires: now + config.duration },
          'MARKET_DATA',
          { ttl: config.duration * 1000 }
        );
        metrics.record('rate_limit_requests', 1, { status: 'allowed', type });
        return {
          remaining: config.points - 1,
          reset: now + config.duration,
          total: config.points,
        };
      }
      // Check remaining points
      if (pointsData.points <= 0) {
        // Block if configured
        if (config.blockDuration) {
          await cacheManager.set(
            keys.block,
            true,
            'MARKET_DATA',
            { ttl: config.blockDuration * 1000 }
          );
          metrics.record('rate_limit_blocks', 1, { type });
        }
        metrics.record('rate_limit_requests', 1, { status: 'exceeded', type });
        return {
          remaining: 0,
          reset: pointsData.expires,
          total: config.points,
          blocked: true,
          blockExpiry: config.blockDuration,
        };
      }
      // Consume point
      await cacheManager.set(
        keys.points,
        { points: pointsData.points - 1, expires: pointsData.expires },
        'MARKET_DATA',
        { ttl: (pointsData.expires - now) * 1000 }
      );
      metrics.record('rate_limit_requests', 1, { status: 'allowed', type });
      return {
        remaining: pointsData.points - 1,
        reset: pointsData.expires,
        total: config.points,
      };
    } catch (error) {
      logger.error('Rate limit error:', error);
      // On error, allow the request
      return {
        remaining: 1,
        reset: now + config.duration,
        total: config.points,
      };
    }
  }
  async reset(identifier: string, type: 'API' | 'WEBSOCKET' = 'API'): Promise<void> {
    const keys = this.generateKeys(identifier, type);
    try {
      await Promise.all([
        cacheManager.invalidate(keys.points, 'MARKET_DATA'),
        cacheManager.invalidate(keys.block, 'MARKET_DATA'),
      ]);
    } catch (error) {
      logger.error('Error resetting rate limit:', error);
    }
  }
  async getLimit(
    identifier: string,
    type: 'API' | 'WEBSOCKET' = 'API'
  ): Promise<RateLimitInfo | null> {
    const keys = this.generateKeys(identifier, type);
    const config = RATE_LIMIT_DEFAULTS[type];
    const now = Math.floor(Date.now() / 1000);
    try {
      const [pointsData, blocked] = await Promise.all([
        cacheManager.get<{
          points: number;
          expires: number;
        }>(keys.points, 'MARKET_DATA'),
        cacheManager.get<boolean>(keys.block, 'MARKET_DATA'),
      ]);
      if (blocked) {
        const blockExpiry = await this.getKeyTTL(keys.block);
        return {
          remaining: 0,
          reset: now + blockExpiry,
          total: config.points,
          blocked: true,
          blockExpiry,
        };
      }
      if (!pointsData) {
        return {
          remaining: config.points,
          reset: now + config.duration,
          total: config.points,
        };
      }
      return {
        remaining: pointsData.points,
        reset: pointsData.expires,
        total: config.points,
      };
    } catch (error) {
      logger.error('Error getting rate limit:', error);
      return null;
    }
  }
  private async getKeyTTL(key: string): Promise<number> {
    try {
      const ttl = await cacheManager.getTTL(key);
      return Math.max(0, ttl);
    } catch (error) {
      logger.error('Error getting TTL:', error);
      return 0;
    }
  }
}
export const rateLimiterService = RateLimiterService.getInstance();
</file>

<file path="lib/services/rbac-service.ts">
import { z } from 'zod';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { cacheManager } from '../utils/cache-manager';
// Schema for permissions
const PermissionSchema = z.object({
  name: z.string(),
  description: z.string(),
  resource: z.string(),
  action: z.enum(['create', 'read', 'update', 'delete', 'manage']),
});
// Schema for roles
const RoleSchema = z.object({
  name: z.string(),
  description: z.string(),
  permissions: z.array(z.string()),
  inherits: z.array(z.string()).optional(),
});
export type Permission = z.infer<typeof PermissionSchema>;
export type Role = z.infer<typeof RoleSchema>;
// Default permissions
const DEFAULT_PERMISSIONS: Permission[] = [
  {
    name: 'read:market-data',
    description: 'Read market data',
    resource: 'market-data',
    action: 'read',
  },
  {
    name: 'read:company-info',
    description: 'Read company information',
    resource: 'company-info',
    action: 'read',
  },
  {
    name: 'read:news',
    description: 'Read news',
    resource: 'news',
    action: 'read',
  },
  {
    name: 'manage:users',
    description: 'Manage users',
    resource: 'users',
    action: 'manage',
  },
];
// Default roles
const DEFAULT_ROLES: Role[] = [
  {
    name: 'user',
    description: 'Basic user role',
    permissions: ['read:market-data', 'read:company-info', 'read:news'],
  },
  {
    name: 'admin',
    description: 'Administrator role',
    permissions: ['read:market-data', 'read:company-info', 'read:news', 'manage:users'],
  },
];
class RBACService {
  private static instance: RBACService;
  private permissions: Map<string, Permission>;
  private roles: Map<string, Role>;
  private constructor() {
    this.permissions = new Map();
    this.roles = new Map();
    this.initialize();
    this.setupMetrics();
  }
  public static getInstance(): RBACService {
    if (!RBACService.instance) {
      RBACService.instance = new RBACService();
    }
    return RBACService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'rbac_permission_checks',
      help: 'Number of permission checks',
      type: 'counter',
      labels: ['status', 'permission'],
    });
    metrics.register({
      name: 'rbac_role_assignments',
      help: 'Number of role assignments',
      type: 'counter',
      labels: ['role'],
    });
  }
  private async initialize() {
    try {
      // Initialize permissions
      for (const permission of DEFAULT_PERMISSIONS) {
        await this.addPermission(permission);
      }
      // Initialize roles
      for (const role of DEFAULT_ROLES) {
        await this.addRole(role);
      }
    } catch (error) {
      logger.error('Error initializing RBAC:', error);
    }
  }
  async addPermission(permission: Permission): Promise<void> {
    try {
      // Validate permission
      const validatedPermission = PermissionSchema.parse(permission);
      // Store in memory
      this.permissions.set(permission.name, validatedPermission);
      // Store in cache
      await cacheManager.set(
        `permission:${permission.name}`,
        validatedPermission,
        'MARKET_DATA',
        {
          ttl: 0, // No expiry
          tags: ['rbac', 'permission'],
        }
      );
    } catch (error) {
      logger.error('Error adding permission:', error);
      throw new Error('Failed to add permission');
    }
  }
  async addRole(role: Role): Promise<void> {
    try {
      // Validate role
      const validatedRole = RoleSchema.parse(role);
      // Validate permissions exist
      for (const permission of role.permissions) {
        if (!this.permissions.has(permission)) {
          throw new Error(`Permission ${permission} does not exist`);
        }
      }
      // Store in memory
      this.roles.set(role.name, validatedRole);
      // Store in cache
      await cacheManager.set(
        `role:${role.name}`,
        validatedRole,
        'MARKET_DATA',
        {
          ttl: 0, // No expiry
          tags: ['rbac', 'role'],
        }
      );
      metrics.record('rbac_role_assignments', 1, { role: role.name });
    } catch (error) {
      logger.error('Error adding role:', error);
      throw new Error('Failed to add role');
    }
  }
  async hasPermission(
    userId: string,
    permissionName: string,
    context: Record<string, unknown> = {}
  ): Promise<boolean> {
    try {
      // Get user's roles from cache
      const userRoles = await cacheManager.get<string[]>(
        `user:${userId}:roles`,
        'MARKET_DATA'
      );
      if (!userRoles || userRoles.length === 0) {
        metrics.record('rbac_permission_checks', 1, {
          status: 'denied',
          permission: permissionName,
        });
        return false;
      }
      // Check each role
      for (const roleName of userRoles) {
        const role = this.roles.get(roleName);
        if (!role) continue;
        // Check direct permissions
        if (role.permissions.includes(permissionName)) {
          metrics.record('rbac_permission_checks', 1, {
            status: 'allowed',
            permission: permissionName,
          });
          return true;
        }
        // Check inherited permissions
        if (role.inherits) {
          for (const inheritedRole of role.inherits) {
            const parentRole = this.roles.get(inheritedRole);
            if (parentRole?.permissions.includes(permissionName)) {
              metrics.record('rbac_permission_checks', 1, {
                status: 'allowed',
                permission: permissionName,
              });
              return true;
            }
          }
        }
      }
      metrics.record('rbac_permission_checks', 1, {
        status: 'denied',
        permission: permissionName,
      });
      return false;
    } catch (error) {
      logger.error('Error checking permission:', error);
      metrics.record('rbac_permission_checks', 1, {
        status: 'error',
        permission: permissionName,
      });
      return false;
    }
  }
  async assignRole(userId: string, roleName: string): Promise<void> {
    try {
      // Validate role exists
      if (!this.roles.has(roleName)) {
        throw new Error(`Role ${roleName} does not exist`);
      }
      // Get current roles
      const currentRoles = await cacheManager.get<string[]>(
        `user:${userId}:roles`,
        'MARKET_DATA'
      ) || [];
      // Add new role if not already assigned
      if (!currentRoles.includes(roleName)) {
        currentRoles.push(roleName);
        // Update cache
        await cacheManager.set(
          `user:${userId}:roles`,
          currentRoles,
          'MARKET_DATA',
          {
            ttl: 0, // No expiry
            tags: ['rbac', `user:${userId}`],
          }
        );
        metrics.record('rbac_role_assignments', 1, { role: roleName });
      }
    } catch (error) {
      logger.error('Error assigning role:', error);
      throw new Error('Failed to assign role');
    }
  }
  async removeRole(userId: string, roleName: string): Promise<void> {
    try {
      // Get current roles
      const currentRoles = await cacheManager.get<string[]>(
        `user:${userId}:roles`,
        'MARKET_DATA'
      ) || [];
      // Remove role
      const updatedRoles = currentRoles.filter(role => role !== roleName);
      // Update cache
      await cacheManager.set(
        `user:${userId}:roles`,
        updatedRoles,
        'MARKET_DATA',
        {
          ttl: 0, // No expiry
          tags: ['rbac', `user:${userId}`],
        }
      );
    } catch (error) {
      logger.error('Error removing role:', error);
      throw new Error('Failed to remove role');
    }
  }
  async getRoles(userId: string): Promise<string[]> {
    try {
      return await cacheManager.get<string[]>(
        `user:${userId}:roles`,
        'MARKET_DATA'
      ) || [];
    } catch (error) {
      logger.error('Error getting roles:', error);
      return [];
    }
  }
  getPermissions(): Permission[] {
    return Array.from(this.permissions.values());
  }
  getRoleDefinitions(): Role[] {
    return Array.from(this.roles.values());
  }
}
export const rbacService = RBACService.getInstance();
</file>

<file path="lib/services/visualization-service.ts">
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { dataTransformService } from './data-transform-service';
import type { MarketData, TechnicalIndicator } from '../types/market-data';
interface ChartConfig {
  type: 'line' | 'candlestick' | 'bar' | 'scatter';
  timeframe: '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '1d';
  indicators?: string[];
  overlay?: boolean;
  theme?: 'light' | 'dark';
}
interface ChartData {
  data: any[];
  config: ChartConfig;
  metadata: {
    symbol: string;
    lastUpdated: number;
    dataPoints: number;
  };
}
class VisualizationService {
  private static instance: VisualizationService;
  private constructor() {
    this.setupMetrics();
  }
  public static getInstance(): VisualizationService {
    if (!VisualizationService.instance) {
      VisualizationService.instance = new VisualizationService();
    }
    return VisualizationService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'visualization_transformations',
      help: 'Number of visualization data transformations',
      type: 'counter',
      labels: ['type', 'status'],
    });
    metrics.register({
      name: 'visualization_errors',
      help: 'Number of visualization errors',
      type: 'counter',
      labels: ['type'],
    });
  }
  async prepareChartData(
    data: MarketData[],
    config: ChartConfig
  ): Promise<ChartData> {
    const startTime = Date.now();
    try {
      let transformedData = data;
      // Sort data by timestamp
      transformedData.sort((a, b) => a.lastUpdated - b.lastUpdated);
      // Apply timeframe aggregation
      transformedData = this.aggregateByTimeframe(transformedData, config.timeframe);
      // Transform data based on chart type
      const chartData = this.transformForChartType(transformedData, config.type);
      // Add technical indicators if requested
      if (config.indicators?.length) {
        await this.addTechnicalIndicators(chartData, config.indicators);
      }
      metrics.record('visualization_transformations', 1, {
        type: config.type,
        status: 'success',
      });
      return {
        data: chartData,
        config,
        metadata: {
          symbol: data[0]?.symbol || 'unknown',
          lastUpdated: Date.now(),
          dataPoints: chartData.length,
        },
      };
    } catch (error) {
      logger.error('Error preparing chart data:', error);
      metrics.record('visualization_errors', 1, { type: 'preparation' });
      throw error;
    }
  }
  private aggregateByTimeframe(
    data: MarketData[],
    timeframe: ChartConfig['timeframe']
  ): MarketData[] {
    const timeframeMs = this.getTimeframeMs(timeframe);
    const aggregated: Map<number, MarketData> = new Map();
    data.forEach(item => {
      const timestamp = Math.floor(item.lastUpdated / timeframeMs) * timeframeMs;
      const existing = aggregated.get(timestamp);
      if (!existing) {
        aggregated.set(timestamp, { ...item, lastUpdated: timestamp });
      } else {
        // Update existing aggregate
        aggregated.set(timestamp, {
          ...existing,
          price: item.price, // Use latest price
          volume: existing.volume + item.volume,
          change: item.price - existing.price,
          changePercent: ((item.price - existing.price) / existing.price) * 100,
        });
      }
    });
    return Array.from(aggregated.values());
  }
  private transformForChartType(
    data: MarketData[],
    type: ChartConfig['type']
  ): any[] {
    switch (type) {
      case 'line':
        return data.map(item => ({
          timestamp: item.lastUpdated,
          value: item.price,
        }));
      case 'candlestick':
        return data.map(item => ({
          timestamp: item.lastUpdated,
          open: item.price - item.change,
          close: item.price,
          high: Math.max(item.price, item.price - item.change),
          low: Math.min(item.price, item.price - item.change),
          volume: item.volume,
        }));
      case 'bar':
        return data.map(item => ({
          timestamp: item.lastUpdated,
          value: item.volume,
        }));
      case 'scatter':
        return data.map(item => ({
          timestamp: item.lastUpdated,
          price: item.price,
          volume: item.volume,
        }));
      default:
        throw new Error(`Unsupported chart type: ${type}`);
    }
  }
  private async addTechnicalIndicators(
    data: any[],
    indicators: string[]
  ): Promise<void> {
    for (const indicator of indicators) {
      const [type, period] = indicator.split('-');
      const values = await this.calculateIndicator(data, type, Number(period));
      // Add indicator values to each data point
      data.forEach((point, index) => {
        point[indicator] = values[index];
      });
    }
  }
  private async calculateIndicator(
    data: any[],
    type: string,
    period: number
  ): Promise<number[]> {
    const prices = data.map(d => d.value || d.close);
    switch (type.toUpperCase()) {
      case 'SMA':
        return this.calculateSMA(prices, period);
      case 'EMA':
        return this.calculateEMA(prices, period);
      case 'RSI':
        return this.calculateRSI(prices, period);
      default:
        throw new Error(`Unsupported indicator: ${type}`);
    }
  }
  private calculateSMA(prices: number[], period: number): number[] {
    const sma: number[] = [];
    for (let i = 0; i < prices.length; i++) {
      if (i < period - 1) {
        sma.push(NaN);
        continue;
      }
      const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
      sma.push(sum / period);
    }
    return sma;
  }
  private calculateEMA(prices: number[], period: number): number[] {
    const ema: number[] = [];
    const multiplier = 2 / (period + 1);
    // First EMA is SMA
    const firstSMA = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
    ema.push(firstSMA);
    for (let i = 1; i < prices.length; i++) {
      const value = (prices[i] - ema[i - 1]) * multiplier + ema[i - 1];
      ema.push(value);
    }
    return ema;
  }
  private calculateRSI(prices: number[], period: number): number[] {
    const rsi: number[] = [];
    let gains: number[] = [];
    let losses: number[] = [];
    // Calculate price changes
    for (let i = 1; i < prices.length; i++) {
      const change = prices[i] - prices[i - 1];
      gains.push(Math.max(0, change));
      losses.push(Math.max(0, -change));
    }
    // Calculate initial averages
    const avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
    const avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
    let prevAvgGain = avgGain;
    let prevAvgLoss = avgLoss;
    // Calculate RSI values
    for (let i = period; i < prices.length; i++) {
      const currentGain = gains[i - 1];
      const currentLoss = losses[i - 1];
      const smoothedAvgGain = (prevAvgGain * (period - 1) + currentGain) / period;
      const smoothedAvgLoss = (prevAvgLoss * (period - 1) + currentLoss) / period;
      prevAvgGain = smoothedAvgGain;
      prevAvgLoss = smoothedAvgLoss;
      const rs = smoothedAvgGain / smoothedAvgLoss;
      const rsiValue = 100 - (100 / (1 + rs));
      rsi.push(rsiValue);
    }
    return rsi;
  }
  private getTimeframeMs(timeframe: ChartConfig['timeframe']): number {
    const minute = 60 * 1000;
    const hour = 60 * minute;
    const day = 24 * hour;
    switch (timeframe) {
      case '1m': return minute;
      case '5m': return 5 * minute;
      case '15m': return 15 * minute;
      case '30m': return 30 * minute;
      case '1h': return hour;
      case '4h': return 4 * hour;
      case '1d': return day;
      default: throw new Error(`Invalid timeframe: ${timeframe}`);
    }
  }
  // Helper method to get default chart configuration
  getDefaultConfig(type: ChartConfig['type'] = 'line'): ChartConfig {
    return {
      type,
      timeframe: '1m',
      indicators: [],
      overlay: false,
      theme: 'light',
    };
  }
}
export const visualizationService = VisualizationService.getInstance();
</file>

<file path="lib/services/websocket-service.ts">
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { metrics } from '../utils/metrics';
import { dataValidationService } from './data-validation-service';
interface WebSocketConfig {
  url: string;
  protocols?: string | string[];
  maxRetries?: number;
  retryDelay?: number;
  maxQueueSize?: number;
  batchSize?: number;
  batchInterval?: number;
}
interface WebSocketMessage {
  type: 'trade' | 'quote' | 'aggregate';
  data: unknown;
  timestamp: number;
}
interface WebSocketStats {
  connected: boolean;
  messageCount: number;
  errorCount: number;
  reconnectCount: number;
  queueSize: number;
  lastMessageTime?: number;
  uptime: number;
}
const DEFAULT_CONFIG = {
  maxRetries: 5,
  retryDelay: 1000,
  maxQueueSize: 10000,
  batchSize: 100,
  batchInterval: 100,
} as const;
class WebSocketService extends EventEmitter {
  private static instance: WebSocketService;
  private connections: Map<string, WebSocket> = new Map();
  private subscriptions: Map<string, Set<string>> = new Map();
  private messageQueues: Map<string, WebSocketMessage[]> = new Map();
  private retryAttempts: Map<string, number> = new Map();
  private batchTimeouts: Map<string, NodeJS.Timeout> = new Map();
  private stats: Map<string, WebSocketStats> = new Map();
  private pingIntervals: Map<string, NodeJS.Timeout> = new Map();
  private constructor() {
    super();
    this.setupMetrics();
  }
  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }
  private setupMetrics() {
    metrics.register({
      name: 'websocket_connections',
      help: 'Number of active WebSocket connections',
      type: 'gauge',
    });
    metrics.register({
      name: 'websocket_messages',
      help: 'Number of WebSocket messages',
      type: 'counter',
      labels: ['type', 'status'],
    });
    metrics.register({
      name: 'websocket_errors',
      help: 'Number of WebSocket errors',
      type: 'counter',
      labels: ['type'],
    });
    metrics.register({
      name: 'websocket_queue_size',
      help: 'Size of message queues',
      type: 'gauge',
      labels: ['connection'],
    });
  }
  async connect(url: string, config: Partial<WebSocketConfig> = {}): Promise<void> {
    const fullConfig = { ...DEFAULT_CONFIG, ...config, url };
    if (this.connections.has(url)) {
      logger.warn(`WebSocket connection to ${url} already exists`);
      return;
    }
    try {
      const ws = new WebSocket(url, fullConfig.protocols);
      this.setupWebSocket(url, ws, fullConfig);
      this.connections.set(url, ws);
      this.messageQueues.set(url, []);
      this.subscriptions.set(url, new Set());
      this.initializeStats(url);
      metrics.record('websocket_connections', this.connections.size);
    } catch (error) {
      logger.error(`Error connecting to WebSocket ${url}:`, error);
      metrics.record('websocket_errors', 1, { type: 'connection' });
      throw error;
    }
  }
  private setupWebSocket(url: string, ws: WebSocket, config: WebSocketConfig) {
    ws.onopen = () => {
      logger.info(`WebSocket connected to ${url}`);
      this.retryAttempts.set(url, 0);
      this.updateStats(url, { connected: true });
      this.setupPingInterval(url, ws);
      this.emit('connect', url);
    };
    ws.onmessage = async (event) => {
      try {
        const rawMessage = JSON.parse(event.data);
        const validatedMessage = await dataValidationService.validateWebSocketMessage({
          ...rawMessage,
          data: rawMessage.data || null, // Ensure data is never undefined
        });
        this.queueMessage(url, validatedMessage);
        this.updateStats(url, {
          messageCount: (this.stats.get(url)?.messageCount || 0) + 1,
          lastMessageTime: Date.now(),
        });
        metrics.record('websocket_messages', 1, {
          type: validatedMessage.type,
          status: 'success',
        });
      } catch (error) {
        logger.error(`Error processing WebSocket message from ${url}:`, error);
        metrics.record('websocket_messages', 1, { type: 'error', status: 'error' });
      }
    };
    ws.onerror = (error) => {
      logger.error(`WebSocket error for ${url}:`, error);
      this.updateStats(url, {
        errorCount: (this.stats.get(url)?.errorCount || 0) + 1,
      });
      metrics.record('websocket_errors', 1, { type: 'websocket' });
      this.emit('error', { url, error });
    };
    ws.onclose = () => {
      logger.warn(`WebSocket connection to ${url} closed`);
      this.updateStats(url, { connected: false });
      this.clearPingInterval(url);
      this.emit('close', url);
      this.handleReconnect(url, config);
    };
  }
  private queueMessage(url: string, message: WebSocketMessage & { data: unknown }) {
    const queue = this.messageQueues.get(url);
    if (!queue) return;
    queue.push(message);
    metrics.record('websocket_queue_size', queue.length, { connection: url });
    // Trim queue if it exceeds max size
    const maxSize = DEFAULT_CONFIG.maxQueueSize;
    if (queue.length > maxSize) {
      queue.splice(0, queue.length - maxSize);
    }
    this.scheduleBatchProcessing(url);
  }
  private scheduleBatchProcessing(url: string) {
    const existingTimeout = this.batchTimeouts.get(url);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
    }
    const timeout = setTimeout(() => {
      this.processBatch(url);
      this.batchTimeouts.delete(url);
    }, DEFAULT_CONFIG.batchInterval);
    this.batchTimeouts.set(url, timeout);
  }
  private processBatch(url: string) {
    const queue = this.messageQueues.get(url);
    if (!queue || queue.length === 0) return;
    const batch = queue.splice(0, DEFAULT_CONFIG.batchSize);
    this.emit('messages', { url, messages: batch });
    metrics.record('websocket_queue_size', queue.length, { connection: url });
  }
  private handleReconnect(url: string, config: WebSocketConfig) {
    const attempts = (this.retryAttempts.get(url) || 0) + 1;
    this.retryAttempts.set(url, attempts);
    if (attempts <= (config.maxRetries || DEFAULT_CONFIG.maxRetries)) {
      const delay = Math.min(
        (config.retryDelay || DEFAULT_CONFIG.retryDelay) * Math.pow(2, attempts - 1),
        30000
      );
      logger.info(`Attempting to reconnect to ${url} in ${delay}ms (attempt ${attempts})`);
      setTimeout(() => {
        this.connect(url, config).catch(error => {
          logger.error(`Reconnection attempt to ${url} failed:`, error);
        });
      }, delay);
      this.updateStats(url, {
        reconnectCount: (this.stats.get(url)?.reconnectCount || 0) + 1,
      });
    } else {
      logger.error(`Max reconnection attempts reached for ${url}`);
      this.emit('maxReconnects', url);
    }
  }
  private setupPingInterval(url: string, ws: WebSocket) {
    const interval = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000);
    this.pingIntervals.set(url, interval);
  }
  private clearPingInterval(url: string) {
    const interval = this.pingIntervals.get(url);
    if (interval) {
      clearInterval(interval);
      this.pingIntervals.delete(url);
    }
  }
  private initializeStats(url: string) {
    this.stats.set(url, {
      connected: false,
      messageCount: 0,
      errorCount: 0,
      reconnectCount: 0,
      queueSize: 0,
      uptime: 0,
    });
  }
  private updateStats(url: string, update: Partial<WebSocketStats>) {
    const current = this.stats.get(url);
    if (current) {
      this.stats.set(url, { ...current, ...update });
    }
  }
  subscribe(url: string, channel: string): void {
    const ws = this.connections.get(url);
    const subs = this.subscriptions.get(url);
    if (!ws || !subs) {
      throw new Error(`No WebSocket connection found for ${url}`);
    }
    if (ws.readyState === WebSocket.OPEN && !subs.has(channel)) {
      ws.send(JSON.stringify({ type: 'subscribe', channel }));
      subs.add(channel);
    }
  }
  unsubscribe(url: string, channel: string): void {
    const ws = this.connections.get(url);
    const subs = this.subscriptions.get(url);
    if (!ws || !subs) {
      throw new Error(`No WebSocket connection found for ${url}`);
    }
    if (ws.readyState === WebSocket.OPEN && subs.has(channel)) {
      ws.send(JSON.stringify({ type: 'unsubscribe', channel }));
      subs.delete(channel);
    }
  }
  disconnect(url: string): void {
    const ws = this.connections.get(url);
    if (ws) {
      ws.close();
      this.connections.delete(url);
      this.subscriptions.delete(url);
      this.messageQueues.delete(url);
      this.retryAttempts.delete(url);
      this.clearPingInterval(url);
      this.stats.delete(url);
      metrics.record('websocket_connections', this.connections.size);
    }
  }
  disconnectAll(): void {
    for (const url of this.connections.keys()) {
      this.disconnect(url);
    }
  }
  getStats(url: string): WebSocketStats | undefined {
    return this.stats.get(url);
  }
  getAllStats(): Map<string, WebSocketStats> {
    return new Map(this.stats);
  }
}
export const webSocketService = WebSocketService.getInstance();
</file>

<file path="lib/tools/stock-news.ts">
import { tool as createTool } from "ai"
import { z } from "zod"
export const stockNewsTool = createTool({
  description: "Display a stock news article with headline, summary, and source.",
  parameters: z.object({
    id: z.string(),
    headline: z.string(),
    summary: z.string(),
    source: z.string(),
    publishedUtc: z.string().optional(),
  }),
  execute: async ({ headline, summary, source, publishedUtc }) => ({ headline, summary, source, publishedUtc }),
})
export const tools = {
  displayStockNews: stockNewsTool,
}
</file>

<file path="lib/tools/weather.ts">
import { tool } from "ai"
import { z } from "zod"
export const weatherTool = tool({
  name: "getWeather",
  description: "Get the current weather for a location",
  parameters: z.object({
    location: z.string().describe("The location to get weather information for"),
  }),
  execute: async ({ location }) => {
    // Simulated weather data - in production, replace with actual API call
    await new Promise((resolve) => setTimeout(resolve, 1000))
    const temperatures = Array.from({ length: 7 }, (_, i) => ({
      hour: `${i + 7}am`,
      temp: Math.floor(Math.random() * 15) + 45, // Random temp between 45-60°F
    }))
    return {
      location,
      currentTemp: temperatures[0].temp,
      condition: "Sunny",
      forecast: temperatures,
    }
  },
})
export const tools = {
  getWeather: weatherTool,
}
</file>

<file path="lib/types/grid-layout.d.ts">
declare module "react-grid-layout" {
  import type { ReactElement } from "react"
  export interface Layout {
    i: string
    x: number
    y: number
    w: number
    h: number
    minW?: number
    maxW?: number
    minH?: number
    maxH?: number
    isDraggable?: boolean
    isResizable?: boolean
    static?: boolean
  }
  export interface Layouts {
    [key: string]: Layout[]
  }
  export interface ResponsiveProps {
    className?: string
    layouts: Layouts
    breakpoints: { [key: string]: number }
    cols: { [key: string]: number }
    rowHeight: number
    onLayoutChange?: (layout: Layout[], layouts: Layouts) => void
    isDraggable?: boolean
    isResizable?: boolean
    margin?: [number, number]
    containerPadding?: [number, number]
    children?: ReactElement[]
  }
  export const Responsive: React.ComponentType<ResponsiveProps>
  export function WidthProvider<T>(component: React.ComponentType<T>): React.ComponentType<Omit<T, "width">>
}
</file>

<file path="lib/types/market-data.ts">
// Market data types
export interface MarketData {
  symbol: string;
  price: number;
  change: number;
  changePercent: number;
  volume: number;
  lastUpdated: number;
  metadata: {
    source: 'websocket' | 'rest' | 'cache';
    reliability: number;
    staleness: number;
  };
}
// Technical indicator types
export interface TechnicalIndicator {
  timestamp: number;
  value: number;
  indicator: 'SMA' | 'EMA' | 'RSI' | 'MACD';
  period: number;
  metadata?: {
    source: string;
    confidence: number;
  };
}
// Company information types
export interface CompanyInfo {
  symbol: string;
  name: string;
  description: string;
  sector: string;
  industry: string;
  employees?: number;
  website?: string;
  marketCap?: number;
  metadata: {
    lastUpdated: number;
    source: string;
    reliability: number;
  };
}
// News item types
export interface NewsItem {
  id: string;
  title: string;
  summary: string;
  url: string;
  source: string;
  publishedAt: number;
  symbols: string[];
  sentiment?: {
    score: number;
    confidence: number;
  };
}
// WebSocket message types
export interface WebSocketMessage {
  type: 'trade' | 'quote' | 'aggregate';
  data: unknown;
  timestamp: number;
}
// Chart configuration types
export interface ChartConfig {
  type: 'line' | 'candlestick' | 'bar' | 'scatter';
  timeframe: '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '1d';
  indicators?: string[];
  overlay?: boolean;
  theme?: 'light' | 'dark';
}
export interface ChartData {
  data: any[];
  config: ChartConfig;
  metadata: {
    symbol: string;
    lastUpdated: number;
    dataPoints: number;
  };
}
// Widget configuration types
export interface WidgetConfig {
  id: string;
  type: 'chart' | 'stats' | 'news' | 'alerts';
  position: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  settings: {
    symbol?: string;
    chartConfig?: ChartConfig;
    statsType?: 'volatility' | 'momentum' | 'statistics';
    period?: number;
    smoothing?: number;
  };
}
// Batch operation types
export interface BatchResult<T> {
  data: T[];
  errors: Error[];
  metadata: {
    total: number;
    successful: number;
    failed: number;
    duration: number;
  };
}
// Error types
export interface ValidationError {
  message: string;
  field?: string;
  value?: unknown;
  code: string;
}
export interface TransformError {
  message: string;
  source: string;
  target: string;
  data: unknown;
}
// Configuration types
export interface DataSourceConfig {
  type: 'rest' | 'websocket' | 'cache';
  priority: number;
  ttl: number;
  retryConfig?: {
    maxRetries: number;
    backoffMs: number;
  };
}
export interface ValidationConfig {
  strict: boolean;
  allowPartial: boolean;
  requiredFields: string[];
}
export interface TransformConfig {
  normalize: boolean;
  validate: boolean;
  format: 'compact' | 'full';
}
// Utility types
export type DataType = 'market' | 'technical' | 'company' | 'news';
export type SourceType = 'rest' | 'websocket' | 'cache';
export type ValidationLevel = 'strict' | 'lenient' | 'none';
</file>

<file path="lib/utils/cache-manager.ts">
import Redis, { Cluster, RedisOptions } from 'ioredis';
import { z } from 'zod';
import { EventEmitter } from 'events';
import { logger } from './logger';
import { metrics } from './metrics';
// Cache configuration
const CACHE_CONFIG = {
  DEFAULT_TTL: 60 * 1000, // 1 minute
  MARKET_DATA_TTL: 5 * 1000, // 5 seconds for market data
  COMPANY_INFO_TTL: 24 * 60 * 60 * 1000, // 24 hours for company info
  BATCH_SIZE: 100,
  MAX_KEYS_TO_SCAN: 1000,
  CLUSTER_RETRY_DELAY: 2000,
  MAX_CLUSTER_RETRIES: 5,
  METRICS_INTERVAL: 60 * 1000, // 1 minute
};
// Cache key patterns
export const CACHE_KEYS = {
  MARKET_DATA: 'market:data:',
  COMPANY_INFO: 'company:info:',
  AGGREGATE_DATA: 'aggregate:data:',
  SNAPSHOT_DATA: 'snapshot:data:',
  TECHNICAL_DATA: 'technical:data:',
  NEWS: 'news:data:',
  METRICS: 'metrics:',
} as const;
// Cache entry schema for validation
const CacheEntrySchema = z.object({
  data: z.unknown(),
  timestamp: z.number(),
  ttl: z.number(),
  source: z.enum(['websocket', 'rest', 'cache']),
  version: z.string(),
  metadata: z.object({
    priority: z.number().min(0).max(10),
    tags: z.array(z.string()),
    compressionEnabled: z.boolean(),
  }).optional(),
});
type CacheEntry = z.infer<typeof CacheEntrySchema>;
interface CacheOptions {
  ttl?: number;
  source?: CacheEntry['source'];
  tags?: string[];
  priority?: number;
  compressionEnabled?: boolean;
}
interface CacheMetrics {
  hits: number;
  misses: number;
  latency: number[];
  size: number;
  memory: number;
  operations: {
    set: number;
    get: number;
    delete: number;
  };
}
class CacheManager extends EventEmitter {
  private static instance: CacheManager;
  private redis!: Redis | Cluster;
  private version: string;
  private metrics: CacheMetrics;
  private metricsInterval: NodeJS.Timeout | null = null;
  private warmupInProgress: boolean;
  private constructor() {
    super();
    this.initializeRedis();
    this.version = process.env.CACHE_VERSION || '1.0.0';
    this.metrics = this.initializeMetrics();
    this.warmupInProgress = false;
    this.setupMetricsCollection();
    this.setupErrorHandling();
  }
  private initializeMetrics(): CacheMetrics {
    return {
      hits: 0,
      misses: 0,
      latency: [],
      size: 0,
      memory: 0,
      operations: {
        set: 0,
        get: 0,
        delete: 0,
      },
    };
  }
  private initializeRedis() {
    const redisConfig: RedisOptions = {
      retryStrategy: (times) => {
        if (times > CACHE_CONFIG.MAX_CLUSTER_RETRIES) {
          return null; // Stop retrying
        }
        return Math.min(times * CACHE_CONFIG.CLUSTER_RETRY_DELAY, 5000);
      },
      maxRetriesPerRequest: 3,
      enableReadyCheck: true,
      enableOfflineQueue: true,
    };
    if (process.env.REDIS_CLUSTER_ENABLED === 'true') {
      const nodes = process.env.REDIS_CLUSTER_NODES?.split(',') || [];
      this.redis = new Cluster(nodes.map(node => ({ host: node, port: 6379 })), {
        ...redisConfig,
        scaleReads: 'slave',
        clusterRetryStrategy: redisConfig.retryStrategy,
      });
    } else {
      const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
      this.redis = new Redis(redisUrl, redisConfig);
    }
  }
  private setupMetricsCollection() {
    this.metricsInterval = setInterval(async () => {
      try {
        const info = await this.redis.info();
        const memory = parseInt(info.match(/used_memory:(\d+)/)?.[1] || '0', 10);
        this.metrics.memory = memory;
        await this.saveMetrics();
        // Reset latency array after calculating percentiles
        this.metrics.latency = [];
        // Emit metrics event for monitoring
        this.emit('metrics', this.getMetricsSummary());
      } catch (error) {
        logger.error('Error collecting cache metrics:', error);
      }
    }, CACHE_CONFIG.METRICS_INTERVAL);
  }
  private async saveMetrics() {
    const timestamp = Date.now();
    const metricsKey = `${CACHE_KEYS.METRICS}${timestamp}`;
    await this.redis.set(metricsKey, JSON.stringify(this.metrics), 'EX', 86400); // Store for 24 hours
  }
  private getMetricsSummary() {
    const latencyPercentiles = this.calculatePercentiles(this.metrics.latency);
    return {
      ...this.metrics,
      latencyPercentiles,
      hitRate: this.metrics.hits / (this.metrics.hits + this.metrics.misses),
      timestamp: Date.now(),
    };
  }
  private calculatePercentiles(values: number[]) {
    if (values.length === 0) return { p50: 0, p90: 0, p99: 0 };
    const sorted = [...values].sort((a, b) => a - b);
    return {
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }
  private setupErrorHandling() {
    this.redis.on('error', (error) => {
      logger.error('Redis error:', error);
      this.emit('error', error);
    });
    this.redis.on('connect', () => {
      logger.info('Connected to Redis');
      this.emit('connect');
    });
    this.redis.on('ready', () => {
      logger.info('Redis is ready');
      this.emit('ready');
    });
    this.redis.on('close', () => {
      logger.warn('Redis connection closed');
      this.emit('close');
    });
  }
  public static getInstance(): CacheManager {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager();
    }
    return CacheManager.instance;
  }
  private generateKey(key: string, prefix: keyof typeof CACHE_KEYS): string {
    return `${CACHE_KEYS[prefix]}${key}:v${this.version}`;
  }
  async set(
    key: string,
    data: unknown,
    prefix: keyof typeof CACHE_KEYS,
    options: CacheOptions = {}
  ): Promise<void> {
    const startTime = Date.now();
    const fullKey = this.generateKey(key, prefix);
    try {
      const entry: CacheEntry = {
        data,
        timestamp: Date.now(),
        ttl: options.ttl || CACHE_CONFIG.DEFAULT_TTL,
        source: options.source || 'cache',
        version: this.version,
        metadata: {
          priority: options.priority || 5,
          tags: options.tags || [],
          compressionEnabled: options.compressionEnabled || false,
        },
      };
      let valueToStore = JSON.stringify(entry);
      if (options.compressionEnabled) {
        // Implement compression if needed
        // valueToStore = await compress(valueToStore);
      }
      await this.redis.set(
        fullKey,
        valueToStore,
        'PX',
        entry.ttl
      );
      if (options.tags?.length) {
        await Promise.all([
          this.redis.sadd(`tags:${fullKey}`, ...options.tags),
          ...options.tags.map(tag =>
            this.redis.sadd(`tag:${tag}`, fullKey)
          ),
        ]);
      }
      // Update metrics
      this.metrics.operations.set++;
      this.metrics.latency.push(Date.now() - startTime);
    } catch (error) {
      logger.error('Cache set error:', error);
      this.emit('error', error);
      throw new Error('Failed to set cache entry');
    }
  }
  async get<T>(key: string, prefix: keyof typeof CACHE_KEYS): Promise<T | null> {
    const startTime = Date.now();
    const fullKey = this.generateKey(key, prefix);
    try {
      const rawData = await this.redis.get(fullKey);
      if (!rawData) {
        this.metrics.misses++;
        return null;
      }
      let parsedData = rawData;
      // if (isCompressed(rawData)) {
      //   parsedData = await decompress(rawData);
      // }
      const entry = CacheEntrySchema.parse(JSON.parse(parsedData));
      // Check if data is stale based on TTL
      if (Date.now() - entry.timestamp > entry.ttl) {
        await this.redis.del(fullKey);
        this.metrics.misses++;
        return null;
      }
      this.metrics.hits++;
      this.metrics.latency.push(Date.now() - startTime);
      return entry.data as T;
    } catch (error) {
      logger.error('Cache get error:', error);
      this.emit('error', error);
      return null;
    }
  }
  async warmUp(entries: Array<{ key: string; data: unknown; prefix: keyof typeof CACHE_KEYS; options?: CacheOptions }>) {
    if (this.warmupInProgress) {
      logger.warn('Cache warmup already in progress');
      return;
    }
    this.warmupInProgress = true;
    const startTime = Date.now();
    let successCount = 0;
    let errorCount = 0;
    try {
      // Sort entries by priority
      const sortedEntries = entries.sort((a, b) => 
        (b.options?.priority || 5) - (a.options?.priority || 5)
      );
      // Process in batches to avoid overwhelming Redis
      for (let i = 0; i < sortedEntries.length; i += CACHE_CONFIG.BATCH_SIZE) {
        const batch = sortedEntries.slice(i, i + CACHE_CONFIG.BATCH_SIZE);
        await Promise.all(
          batch.map(async ({ key, data, prefix, options }) => {
            try {
              await this.set(key, data, prefix, options);
              successCount++;
            } catch (error) {
              errorCount++;
              logger.error(`Error warming up cache for key ${key}:`, error);
            }
          })
        );
        // Small delay between batches
        if (i + CACHE_CONFIG.BATCH_SIZE < sortedEntries.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    } finally {
      this.warmupInProgress = false;
      const duration = Date.now() - startTime;
      logger.info(`Cache warmup completed in ${duration}ms. Success: ${successCount}, Errors: ${errorCount}`);
      this.emit('warmupComplete', { duration, successCount, errorCount });
    }
  }
  async invalidate(key: string, prefix: keyof typeof CACHE_KEYS): Promise<void> {
    const fullKey = this.generateKey(key, prefix);
    try {
      const startTime = Date.now();
      // Get tags associated with the key
      const tags = await this.redis.smembers(`tags:${fullKey}`);
      // Remove key from all tag sets
      await Promise.all([
        this.redis.del(fullKey),
        this.redis.del(`tags:${fullKey}`),
        ...tags.map(tag => this.redis.srem(`tag:${tag}`, fullKey)),
      ]);
      this.metrics.operations.delete++;
      this.metrics.latency.push(Date.now() - startTime);
    } catch (error) {
      logger.error('Cache invalidation error:', error);
      this.emit('error', error);
      throw new Error('Failed to invalidate cache entry');
    }
  }
  async clear(): Promise<void> {
    try {
      if (this.redis instanceof Cluster) {
        // For cluster, we need to clear each node
        const nodes = this.redis.nodes('master');
        await Promise.all(nodes.map(node => node.flushdb()));
      } else {
        await this.redis.flushdb();
      }
      this.metrics = this.initializeMetrics();
      this.emit('clear');
    } catch (error) {
      logger.error('Cache clear error:', error);
      this.emit('error', error);
      throw new Error('Failed to clear cache');
    }
  }
  async disconnect(): Promise<void> {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
    }
    await this.redis.quit();
    this.emit('disconnect');
  }
  // Health check method
  async healthCheck(): Promise<boolean> {
    try {
      await this.redis.ping();
      return true;
    } catch (error) {
      logger.error('Cache health check failed:', error);
      return false;
    }
  }
  async getTTL(key: string): Promise<number> {
    try {
      const ttl = await this.redis.ttl(key);
      return ttl > 0 ? ttl : 0;
    } catch (error) {
      logger.error('Error getting TTL:', error);
      return 0;
    }
  }
  async invalidateByTag(tag: string): Promise<void> {
    try {
      // Get all keys associated with the tag
      const keys = await this.redis.smembers(`tag:${tag}`);
      if (keys.length > 0) {
        // Remove all keys and their tag associations
        await Promise.all([
          this.redis.del(...keys),
          ...keys.map(key => this.redis.del(`tags:${key}`)),
          this.redis.del(`tag:${tag}`),
        ]);
      }
    } catch (error) {
      logger.error('Tag invalidation error:', error);
      throw new Error('Failed to invalidate by tag');
    }
  }
}
// Export singleton instance
export const cacheManager = CacheManager.getInstance();
</file>

<file path="lib/utils/data-validator.ts">
import { z } from 'zod';
// Base schemas for common data structures
const PriceSchema = z.number().min(0).max(1000000);
const VolumeSchema = z.number().min(0);
const PercentageSchema = z.number().min(-100).max(100);
const TimestampSchema = z.number().min(0);
const SymbolSchema = z.string().regex(/^[A-Z]{1,5}$/);
// Market data validation schemas
export const MarketDataSchema = z.object({
  symbol: SymbolSchema,
  price: PriceSchema,
  change: z.number(),
  changePercent: PercentageSchema,
  volume: VolumeSchema,
  lastUpdated: TimestampSchema,
  metadata: z.object({
    source: z.enum(['websocket', 'rest', 'cache']),
    reliability: z.number().min(0).max(1),
    staleness: z.number().min(0),
  }),
});
// Technical indicator schemas
export const TechnicalIndicatorSchema = z.object({
  timestamp: TimestampSchema,
  value: z.number(),
  indicator: z.enum(['SMA', 'EMA', 'RSI', 'MACD']),
  period: z.number().min(1),
});
// Company information schema
export const CompanyInfoSchema = z.object({
  symbol: SymbolSchema,
  name: z.string(),
  description: z.string(),
  sector: z.string(),
  industry: z.string(),
  employees: z.number().optional(),
  website: z.string().url().optional(),
  marketCap: z.number().optional(),
});
// News item schema
export const NewsItemSchema = z.object({
  id: z.string(),
  title: z.string(),
  summary: z.string(),
  url: z.string().url(),
  source: z.string(),
  publishedAt: TimestampSchema,
  symbols: z.array(SymbolSchema),
});
// Validation error types
export class ValidationError extends Error {
  constructor(
    message: string,
    public errors: z.ZodError[],
    public data: unknown
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
// Data transformation utilities
export const DataTransformer = {
  // Normalize market data from different sources
  normalizeMarketData(data: unknown, source: 'polygon' | 'alternative'): z.infer<typeof MarketDataSchema> {
    try {
      if (source === 'polygon') {
        // Transform Polygon.io format to our standard format
        const transformed = {
          symbol: (data as any).T || (data as any).symbol,
          price: (data as any).p || (data as any).price,
          change: (data as any).c || (data as any).change,
          changePercent: (data as any).P || (data as any).changePercent,
          volume: (data as any).v || (data as any).volume,
          lastUpdated: Date.now(),
          metadata: {
            source: 'rest' as const,
            reliability: 1,
            staleness: 0,
          },
        };
        return MarketDataSchema.parse(transformed);
      } else {
        // Transform alternative source format
        // Add more source transformations as needed
        throw new Error('Unsupported data source');
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Failed to normalize market data', [error], data);
      }
      throw error;
    }
  },
  // Format technical indicators
  formatTechnicalIndicator(
    data: unknown,
    indicator: z.infer<typeof TechnicalIndicatorSchema>['indicator'],
    period: number
  ): z.infer<typeof TechnicalIndicatorSchema> {
    try {
      const transformed = {
        timestamp: (data as any).t || Date.now(),
        value: (data as any).v || (data as any).value,
        indicator,
        period,
      };
      return TechnicalIndicatorSchema.parse(transformed);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Failed to format technical indicator', [error], data);
      }
      throw error;
    }
  },
  // Validate and clean company information
  validateCompanyInfo(data: unknown): z.infer<typeof CompanyInfoSchema> {
    try {
      return CompanyInfoSchema.parse(data);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid company information', [error], data);
      }
      throw error;
    }
  },
  // Validate and format news items
  validateNewsItem(data: unknown): z.infer<typeof NewsItemSchema> {
    try {
      return NewsItemSchema.parse(data);
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError('Invalid news item', [error], data);
      }
      throw error;
    }
  },
  // Batch validation for multiple items
  validateBatch<T>(
    items: unknown[],
    schema: z.ZodSchema<T>,
    options: { stopOnFirst?: boolean } = {}
  ): { valid: T[]; errors: ValidationError[] } {
    const valid: T[] = [];
    const errors: ValidationError[] = [];
    for (const item of items) {
      try {
        valid.push(schema.parse(item));
      } catch (error) {
        if (error instanceof z.ZodError) {
          errors.push(new ValidationError('Validation failed', [error], item));
          if (options.stopOnFirst) break;
        } else {
          throw error;
        }
      }
    }
    return { valid, errors };
  },
};
// Type guard utilities
export const TypeGuards = {
  isMarketData(data: unknown): data is z.infer<typeof MarketDataSchema> {
    try {
      MarketDataSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  },
  isTechnicalIndicator(data: unknown): data is z.infer<typeof TechnicalIndicatorSchema> {
    try {
      TechnicalIndicatorSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  },
  isCompanyInfo(data: unknown): data is z.infer<typeof CompanyInfoSchema> {
    try {
      CompanyInfoSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  },
  isNewsItem(data: unknown): data is z.infer<typeof NewsItemSchema> {
    try {
      NewsItemSchema.parse(data);
      return true;
    } catch {
      return false;
    }
  },
};
</file>

<file path="lib/utils/jwt.ts">
import { SignJWT, jwtVerify } from 'jose';
import { nanoid } from 'nanoid';
export interface UserJWTPayload {
  jti: string;
  iat: number;
  userId: string;
  email: string;
  role: 'user' | 'admin';
}
const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'your-secret-key'
);
export async function signToken(payload: Omit<UserJWTPayload, 'jti' | 'iat'>) {
  const iat = Math.floor(Date.now() / 1000);
  const jti = nanoid();
  return new SignJWT({ ...payload, jti, iat })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt(iat)
    .setExpirationTime('24h')
    .sign(JWT_SECRET);
}
export async function verifyToken(token: string): Promise<UserJWTPayload> {
  const { payload } = await jwtVerify(token, JWT_SECRET);
  return payload as UserJWTPayload;
}
</file>

<file path="lib/utils/logger.ts">
import winston from 'winston';
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
  ],
});
// Add file transport in production
if (process.env.NODE_ENV === 'production') {
  logger.add(
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  logger.add(
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
}
export { logger };
</file>

<file path="lib/utils/metrics.ts">
import { EventEmitter } from 'events';
import { logger } from './logger';
export interface MetricValue {
  value: number;
  timestamp: number;
  labels?: Record<string, string>;
}
export interface MetricConfig {
  name: string;
  help: string;
  type: 'counter' | 'gauge' | 'histogram';
  labels?: string[];
}
class Metric {
  private values: MetricValue[] = [];
  private config: MetricConfig;
  constructor(config: MetricConfig) {
    this.config = config;
  }
  record(value: number, labels?: Record<string, string>) {
    this.values.push({
      value,
      timestamp: Date.now(),
      labels,
    });
    // Keep only last 1000 values
    if (this.values.length > 1000) {
      this.values = this.values.slice(-1000);
    }
  }
  get(): MetricValue[] {
    return this.values;
  }
  getLast(): MetricValue | undefined {
    return this.values[this.values.length - 1];
  }
  clear() {
    this.values = [];
  }
}
class Metrics extends EventEmitter {
  private static instance: Metrics;
  private metrics: Map<string, Metric> = new Map();
  private exportInterval: NodeJS.Timer | null = null;
  private constructor() {
    super();
    this.setupExport();
  }
  public static getInstance(): Metrics {
    if (!Metrics.instance) {
      Metrics.instance = new Metrics();
    }
    return Metrics.instance;
  }
  register(config: MetricConfig): Metric {
    if (this.metrics.has(config.name)) {
      return this.metrics.get(config.name)!;
    }
    const metric = new Metric(config);
    this.metrics.set(config.name, metric);
    return metric;
  }
  record(name: string, value: number, labels?: Record<string, string>) {
    const metric = this.metrics.get(name);
    if (!metric) {
      logger.warn(`Metric ${name} not registered`);
      return;
    }
    metric.record(value, labels);
    this.emit('record', { name, value, labels });
  }
  get(name: string): MetricValue[] {
    const metric = this.metrics.get(name);
    if (!metric) {
      logger.warn(`Metric ${name} not registered`);
      return [];
    }
    return metric.get();
  }
  getAll(): Record<string, MetricValue[]> {
    const result: Record<string, MetricValue[]> = {};
    for (const [name, metric] of this.metrics.entries()) {
      result[name] = metric.get();
    }
    return result;
  }
  private setupExport() {
    // Export metrics every minute
    this.exportInterval = setInterval(() => {
      try {
        const metrics = this.getAll();
        this.emit('export', metrics);
        // Log metrics summary
        for (const [name, values] of Object.entries(metrics)) {
          const last = values[values.length - 1];
          if (last) {
            logger.info(`Metric ${name}: ${last.value}`, {
              metric: name,
              value: last.value,
              labels: last.labels,
            });
          }
        }
      } catch (error) {
        logger.error('Error exporting metrics:', error);
      }
    }, 60000);
  }
  async disconnect() {
    if (this.exportInterval) {
      clearInterval(this.exportInterval);
      this.exportInterval = null;
    }
  }
}
export const metrics = Metrics.getInstance();
</file>

<file path="lib/utils/rate-limiter.ts">
import { RateLimiter } from 'limiter';
// Global rate limiters
const globalLimiter = new RateLimiter({
  tokensPerInterval: 300, // Increased from 100 to 300 to handle more concurrent requests
  interval: 'minute'
});
// Per-IP rate limiters
const ipLimiters = new Map<string, RateLimiter>();
// Per-endpoint rate limiters
const endpointLimiters = new Map<string, RateLimiter>();
export interface RateLimitConfig {
  tokensPerInterval: number;
  interval: 'second' | 'minute' | 'hour';
  maxWaitMs?: number;
}
export interface RateLimitResult {
  success: boolean;
  retryAfter?: number;
}
export class RateLimitManager {
  private static instance: RateLimitManager;
  private constructor() {}
  static getInstance(): RateLimitManager {
    if (!RateLimitManager.instance) {
      RateLimitManager.instance = new RateLimitManager();
    }
    return RateLimitManager.instance;
  }
  async checkRateLimit(
    ip: string,
    endpoint: string,
    config: RateLimitConfig
  ): Promise<RateLimitResult> {
    // Get or create IP limiter
    let ipLimiter = ipLimiters.get(ip);
    if (!ipLimiter) {
      ipLimiter = new RateLimiter({
        tokensPerInterval: config.tokensPerInterval,
        interval: config.interval
      });
      ipLimiters.set(ip, ipLimiter);
    }
    // Get or create endpoint limiter
    let endpointLimiter = endpointLimiters.get(endpoint);
    if (!endpointLimiter) {
      endpointLimiter = new RateLimiter({
        tokensPerInterval: config.tokensPerInterval * 5, // Endpoint limit is more lenient
        interval: config.interval
      });
      endpointLimiters.set(endpoint, endpointLimiter);
    }
    try {
      // Check all limiters
      await Promise.all([
        globalLimiter.removeTokens(1),
        ipLimiter.removeTokens(1),
        endpointLimiter.removeTokens(1)
      ]);
      return { success: true };
    } catch (error) {
      // Calculate retry after based on the most restrictive limiter
      const retryAfter = Math.max(
        await globalLimiter.getTokensRemaining(),
        await ipLimiter.getTokensRemaining(),
        await endpointLimiter.getTokensRemaining()
      );
      return {
        success: false,
        retryAfter: Math.ceil(retryAfter * 1000) // Convert to milliseconds
      };
    }
  }
  // Clean up old IP limiters periodically
  cleanupOldLimiters() {
    const now = Date.now();
    for (const [ip, limiter] of ipLimiters.entries()) {
      if (now - limiter.getTokensRemaining() > 24 * 60 * 60 * 1000) { // 24 hours
        ipLimiters.delete(ip);
      }
    }
  }
}
// Export singleton instance
export const rateLimitManager = RateLimitManager.getInstance();
interface RateLimiterConfig {
  tokensPerInterval: number;
  interval: number;
  burstSize?: number;
}
export class RateLimiter {
  private tokens: number;
  private lastRefill: number;
  private readonly tokensPerInterval: number;
  private readonly interval: number;
  private readonly maxTokens: number;
  constructor(config: RateLimiterConfig) {
    this.tokensPerInterval = config.tokensPerInterval;
    this.interval = config.interval;
    this.maxTokens = config.burstSize || config.tokensPerInterval;
    this.tokens = this.maxTokens;
    this.lastRefill = Date.now();
  }
  private refillTokens() {
    const now = Date.now();
    const timePassed = now - this.lastRefill;
    const tokensToAdd = Math.floor(timePassed / this.interval) * this.tokensPerInterval;
    if (tokensToAdd > 0) {
      this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
      this.lastRefill = now;
    }
  }
  public async waitForToken(): Promise<void> {
    this.refillTokens();
    if (this.tokens > 0) {
      this.tokens--;
      return Promise.resolve();
    }
    // Calculate time until next token
    const timeUntilNextToken = this.interval - ((Date.now() - this.lastRefill) % this.interval);
    return new Promise(resolve => {
      setTimeout(() => {
        this.refillTokens();
        this.tokens--;
        resolve();
      }, timeUntilNextToken);
    });
  }
  public getTokenCount(): number {
    this.refillTokens();
    return this.tokens;
  }
  public hasToken(): boolean {
    this.refillTokens();
    return this.tokens > 0;
  }
}
</file>

<file path="lib/utils/request-validator.ts">
import { NextRequest } from 'next/server';
import { z } from 'zod';
import { APIError } from '../middleware/error-handler';
export async function validateRequest<T>(
  req: NextRequest,
  schema: z.ZodSchema<T>
): Promise<T> {
  try {
    const body = await req.json();
    return schema.parse(body);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw error;
    }
    throw new APIError('Invalid request body', 400, 'INVALID_REQUEST');
  }
}
// Common request schemas
export const PaginationSchema = z.object({
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(10),
});
export const DateRangeSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
});
export const SymbolParamSchema = z.object({
  symbol: z.string().regex(/^[A-Z]{1,5}$/),
});
export const TimeframeSchema = z.enum(['1m', '5m', '15m', '30m', '1h', '4h', '1d']);
// Request schemas for specific endpoints
export const MarketDataRequestSchema = z.object({
  symbols: z.array(z.string()).min(1).max(50),
  timeframe: TimeframeSchema.optional(),
}).merge(PaginationSchema.partial());
export const TechnicalIndicatorRequestSchema = z.object({
  symbol: z.string(),
  indicator: z.enum(['SMA', 'EMA', 'RSI', 'MACD']),
  period: z.number().int().min(1).max(200),
}).merge(DateRangeSchema);
export const NewsRequestSchema = z.object({
  symbols: z.array(z.string()).optional(),
  categories: z.array(z.string()).optional(),
}).merge(PaginationSchema.partial());
// Helper function to validate query parameters
export function validateQueryParams<T>(
  params: URLSearchParams,
  schema: z.ZodSchema<T>
): T {
  const queryObj: Record<string, unknown> = {};
  params.forEach((value, key) => {
    // Handle arrays
    if (key.endsWith('[]')) {
      const arrayKey = key.slice(0, -2);
      if (!queryObj[arrayKey]) {
        queryObj[arrayKey] = [];
      }
      (queryObj[arrayKey] as unknown[]).push(value);
    } else {
      // Handle numbers
      if (/^\d+$/.test(value)) {
        queryObj[key] = parseInt(value, 10);
      } else if (value === 'true' || value === 'false') {
        queryObj[key] = value === 'true';
      } else {
        queryObj[key] = value;
      }
    }
  });
  return schema.parse(queryObj);
}
</file>

<file path="lib/utils/response-formatter.ts">
import { NextResponse } from 'next/server';
interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
}
type MetaExtras = {
  timestamp: number;
  cached?: boolean;
  source?: string;
};
type ResponseMeta = Partial<PaginationMeta> & MetaExtras;
export function formatResponse<T>(
  data: T,
  meta: Partial<ResponseMeta> = { timestamp: Date.now() },
  status: number = 200
): NextResponse {
  const response = {
    success: true,
    data,
    meta: {
      ...meta,
      timestamp: meta.timestamp || Date.now(),
    },
  };
  return NextResponse.json(response, { status });
}
export function formatPaginatedResponse<T>(
  data: T[],
  pagination: PaginationMeta,
  metaExtras: Partial<MetaExtras> = { timestamp: Date.now() },
  status: number = 200
): NextResponse {
  const meta: ResponseMeta = {
    ...pagination,
    timestamp: metaExtras.timestamp || Date.now(),
    ...(metaExtras.cached !== undefined && { cached: metaExtras.cached }),
    ...(metaExtras.source !== undefined && { source: metaExtras.source }),
  };
  return formatResponse(data, meta, status);
}
export function formatErrorResponse(
  error: string,
  code: string = 'INTERNAL_SERVER_ERROR',
  status: number = 500,
  details?: unknown
): NextResponse {
  const response = {
    success: false,
    error,
    code,
    ...(details && { details }),
    meta: {
      timestamp: Date.now(),
    },
  };
  return NextResponse.json(response, { status });
}
export function formatStreamResponse(
  stream: ReadableStream,
  meta: Partial<ResponseMeta> = { timestamp: Date.now() }
): NextResponse {
  return new NextResponse(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
// Helper function to calculate pagination metadata
export function calculatePagination(
  total: number,
  page: number = 1,
  limit: number = 10
): PaginationMeta {
  const totalPages = Math.ceil(total / limit);
  return {
    page,
    limit,
    total,
    totalPages,
  };
}
</file>

<file path="lib/utils/technical-analysis.ts">
import { AggregatesResponse } from '@/lib/api/polygon-service'
export interface TechnicalIndicators {
  sma: number[]
  ema: number[]
  rsi: number[]
  macd: {
    macd: number[]
    signal: number[]
    histogram: number[]
  }
  volume: number[]
  priceChange: number[]
  priceChangePercent: number[]
}
export function calculateSMA(prices: number[], period: number): number[] {
  const sma: number[] = []
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      sma.push(NaN)
      continue
    }
    const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0)
    sma.push(sum / period)
  }
  return sma
}
export function calculateEMA(prices: number[], period: number): number[] {
  const ema: number[] = []
  const multiplier = 2 / (period + 1)
  for (let i = 0; i < prices.length; i++) {
    if (i === 0) {
      ema.push(prices[0])
      continue
    }
    ema.push((prices[i] - ema[i - 1]) * multiplier + ema[i - 1])
  }
  return ema
}
export function calculateRSI(prices: number[], period: number = 14): number[] {
  const rsi: number[] = []
  const gains: number[] = []
  const losses: number[] = []
  // Calculate price changes
  for (let i = 1; i < prices.length; i++) {
    const change = prices[i] - prices[i - 1]
    gains.push(change > 0 ? change : 0)
    losses.push(change < 0 ? -change : 0)
  }
  // Calculate initial averages
  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period
  // Calculate RSI
  for (let i = 0; i < prices.length; i++) {
    if (i < period) {
      rsi.push(NaN)
      continue
    }
    if (i > period) {
      avgGain = (avgGain * (period - 1) + gains[i - 1]) / period
      avgLoss = (avgLoss * (period - 1) + losses[i - 1]) / period
    }
    const rs = avgGain / avgLoss
    rsi.push(100 - (100 / (1 + rs)))
  }
  return rsi
}
export function calculateMACD(
  prices: number[],
  fastPeriod: number = 12,
  slowPeriod: number = 26,
  signalPeriod: number = 9
): { macd: number[], signal: number[], histogram: number[] } {
  const fastEMA = calculateEMA(prices, fastPeriod)
  const slowEMA = calculateEMA(prices, slowPeriod)
  const macd = fastEMA.map((fast, i) => fast - slowEMA[i])
  const signal = calculateEMA(macd, signalPeriod)
  const histogram = macd.map((value, i) => value - signal[i])
  return { macd, signal, histogram }
}
export function calculateTechnicalIndicators(data: AggregatesResponse): TechnicalIndicators {
  const prices = data.results.map(bar => bar.c)
  const volumes = data.results.map(bar => bar.v)
  // Calculate price changes
  const priceChange = prices.map((price, i) => 
    i === 0 ? 0 : price - prices[i - 1]
  )
  const priceChangePercent = prices.map((price, i) => 
    i === 0 ? 0 : ((price - prices[i - 1]) / prices[i - 1]) * 100
  )
  return {
    sma: calculateSMA(prices, 20),
    ema: calculateEMA(prices, 20),
    rsi: calculateRSI(prices),
    macd: calculateMACD(prices),
    volume: volumes,
    priceChange,
    priceChangePercent
  }
}
</file>

<file path="lib/app-state-context.tsx">
"use client"
import type React from "react"
import { createContext, useContext, useState } from "react"
interface AppState {
  theme: "light" | "dark"
  currency: "USD" | "EUR" | "GBP"
}
interface AppStateContextType {
  state: AppState
  updateState: (newState: Partial<AppState>) => void
}
const AppStateContext = createContext<AppStateContextType | undefined>(undefined)
export function AppStateProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<AppState>({
    theme: "light",
    currency: "USD",
  })
  const updateState = (newState: Partial<AppState>) => {
    setState((prevState) => ({ ...prevState, ...newState }))
  }
  return <AppStateContext.Provider value={{ state, updateState }}>{children}</AppStateContext.Provider>
}
export function useAppState() {
  const context = useContext(AppStateContext)
  if (context === undefined) {
    throw new Error("useAppState must be used within an AppStateProvider")
  }
  return context
}
</file>

<file path="lib/db.ts">
import { PrismaClient } from '@prisma/client'
declare global {
  var prisma: PrismaClient | undefined
}
const prisma = global.prisma || new PrismaClient()
if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma
}
export default prisma
</file>

<file path="lib/fetcher.ts">
export const fetcher = async (url: string) => {
  const res = await fetch(url)
  if (!res.ok) {
    const error = new Error("An error occurred while fetching the data.")
    // Attach extra info to the error object.
    error.info = await res.json()
    error.status = res.status
    throw error
  }
  return res.json()
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="lib/websocket-client.ts">
type MessageCallback = (data: any) => void
type ErrorCallback = (error: Error) => void
type StatusCallback = (status: 'connecting' | 'connected' | 'disconnected' | 'error') => void
interface WebSocketOptions {
  onMessage?: MessageCallback
  onError?: ErrorCallback
  onStatusChange?: StatusCallback
  reconnectAttempts?: number
  reconnectDelay?: number
}
export class PolygonWebSocket {
  private ws: WebSocket | null = null
  private token: string | null = null
  private subscriptions: Set<string> = new Set()
  private reconnectAttempts: number
  private reconnectDelay: number
  private reconnectCount: number = 0
  private reconnectTimeout: NodeJS.Timeout | null = null
  private pingInterval: NodeJS.Timeout | null = null
  private onMessage?: MessageCallback
  private onError?: ErrorCallback
  private onStatusChange?: StatusCallback
  constructor(options: WebSocketOptions = {}) {
    this.reconnectAttempts = options.reconnectAttempts || 5
    this.reconnectDelay = options.reconnectDelay || 5000
    this.onMessage = options.onMessage
    this.onError = options.onError
    this.onStatusChange = options.onStatusChange
  }
  async connect(): Promise<void> {
    try {
      this.updateStatus('connecting')
      // Get WebSocket connection details from our API
      const response = await fetch('/api/polygon-stocks/websocket')
      if (!response.ok) {
        throw new Error('Failed to get WebSocket connection details')
      }
      const { wsUrl, token } = await response.json()
      this.token = token
      // Create WebSocket connection
      this.ws = new WebSocket(wsUrl)
      this.ws.onopen = () => {
        this.authenticate()
        this.startPingInterval()
        this.reconnectCount = 0
        this.updateStatus('connected')
      }
      this.ws.onclose = () => {
        this.cleanup()
        this.updateStatus('disconnected')
        this.attemptReconnect()
      }
      this.ws.onerror = (error) => {
        this.handleError(new Error('WebSocket error occurred'))
      }
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          if (data.ev === 'status') {
            // Handle status messages
            console.log('Status:', data)
          } else if (this.onMessage) {
            this.onMessage(data)
          }
        } catch (error) {
          console.error('Error parsing WebSocket message:', error)
        }
      }
    } catch (error) {
      this.handleError(error as Error)
    }
  }
  private authenticate(): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN && this.token) {
      this.ws.send(JSON.stringify({ action: 'auth', params: this.token }))
    }
  }
  subscribe(symbols: string[]): void {
    const newSymbols = symbols.filter(s => !this.subscriptions.has(s))
    if (newSymbols.length === 0) return
    newSymbols.forEach(s => this.subscriptions.add(s))
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: 'subscribe',
        params: `T.${newSymbols.join(',T.')}`
      }))
    }
  }
  unsubscribe(symbols: string[]): void {
    const existingSymbols = symbols.filter(s => this.subscriptions.has(s))
    if (existingSymbols.length === 0) return
    existingSymbols.forEach(s => this.subscriptions.delete(s))
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: 'unsubscribe',
        params: `T.${existingSymbols.join(',T.')}`
      }))
    }
  }
  private startPingInterval(): void {
    this.pingInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ action: 'ping' }))
      }
    }, 30000) // Send ping every 30 seconds
  }
  private cleanup(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval)
      this.pingInterval = null
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout)
      this.reconnectTimeout = null
    }
  }
  private attemptReconnect(): void {
    if (this.reconnectCount >= this.reconnectAttempts) {
      this.handleError(new Error('Maximum reconnection attempts reached'))
      return
    }
    this.reconnectTimeout = setTimeout(() => {
      this.reconnectCount++
      this.connect()
    }, this.reconnectDelay * Math.pow(2, this.reconnectCount)) // Exponential backoff
  }
  private handleError(error: Error): void {
    this.updateStatus('error')
    if (this.onError) {
      this.onError(error)
    }
  }
  private updateStatus(status: 'connecting' | 'connected' | 'disconnected' | 'error'): void {
    if (this.onStatusChange) {
      this.onStatusChange(status)
    }
  }
  disconnect(): void {
    this.cleanup()
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
  }
}
</file>

<file path="lib/websocket.ts">
"use client"
import { useState, useEffect } from "react"
type WebSocketMessage = {
  type: string
  data: any
}
export function useWebSocket(url: string) {
  const [socket, setSocket] = useState<WebSocket | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null)
  useEffect(() => {
    const ws = new WebSocket(url)
    ws.onopen = () => setIsConnected(true)
    ws.onclose = () => setIsConnected(false)
    ws.onmessage = (event) => setLastMessage(JSON.parse(event.data))
    setSocket(ws)
    return () => {
      ws.close()
    }
  }, [url])
  const sendMessage = (message: WebSocketMessage) => {
    if (socket) {
      socket.send(JSON.stringify(message))
    }
  }
  return { isConnected, lastMessage, sendMessage }
}
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User and Authentication
model User {
  id                String            @id @default(cuid())
  email             String            @unique
  name              String?
  password          String            // Hashed password
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  emailVerified     Boolean           @default(false)
  portfolios        Portfolio[]
  watchlists        Watchlist[]
  alerts            Alert[]
  tradeJournals     TradeJournal[]
  sessions          Session[]
  verificationToken VerificationToken?
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Portfolio Management
model Portfolio {
  id          String        @id @default(cuid())
  name        String
  description String?
  userId      String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  positions   Position[]
  orders      Order[]
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  cash        Decimal       @default(0)
  currency    String        @default("USD")
  isDefault   Boolean       @default(false)
  trades      Trade[]
  performance Performance[]
}

model Position {
  id          String   @id @default(cuid())
  portfolioId String
  symbol      String
  quantity    Decimal
  costBasis   Decimal
  openedAt    DateTime @default(now())
  updatedAt   DateTime @updatedAt
  portfolio   Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  trades      Trade[]

  @@unique([portfolioId, symbol])
}

model Order {
  id          String      @id @default(cuid())
  portfolioId String
  symbol      String
  type        OrderType
  side        OrderSide
  quantity    Decimal
  price       Decimal?
  status      OrderStatus
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  expiresAt   DateTime?
  portfolio   Portfolio   @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  trades      Trade[]
}

model Trade {
  id          String    @id @default(cuid())
  portfolioId String
  positionId  String
  orderId     String?
  symbol      String
  quantity    Decimal
  price       Decimal
  side        OrderSide
  executedAt  DateTime  @default(now())
  portfolio   Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  position    Position  @relation(fields: [positionId], references: [id], onDelete: Cascade)
  order       Order?    @relation(fields: [orderId], references: [id])
}

// Watchlists and Alerts
model Watchlist {
  id        String    @id @default(cuid())
  name      String
  userId    String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  symbols   String[]
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Alert {
  id        String      @id @default(cuid())
  userId    String
  symbol    String
  type      AlertType
  condition AlertCondition
  value     Decimal
  active    Boolean     @default(true)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Performance Tracking
model Performance {
  id          String    @id @default(cuid())
  portfolioId String
  date        DateTime  @default(now())
  value       Decimal
  cash        Decimal
  deposits    Decimal
  withdrawals Decimal
  portfolio   Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)

  @@unique([portfolioId, date])
}

// Trade Journal
model TradeJournal {
  id          String   @id @default(cuid())
  userId      String
  title       String
  content     String
  sentiment   String?
  tags        String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Enums
enum OrderType {
  MARKET
  LIMIT
  STOP
  STOP_LIMIT
}

enum OrderSide {
  BUY
  SELL
}

enum OrderStatus {
  PENDING
  FILLED
  CANCELLED
  EXPIRED
  REJECTED
}

enum AlertType {
  PRICE
  VOLUME
  TECHNICAL
  NEWS
}

enum AlertCondition {
  ABOVE
  BELOW
  EQUALS
  CROSSES_ABOVE
  CROSSES_BELOW
}
</file>

<file path="public/placeholder-logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="215" height="48" fill="none"><path fill="#000" d="M57.588 9.6h6L73.828 38h-5.2l-2.36-6.88h-11.36L52.548 38h-5.2l10.24-28.4Zm7.16 17.16-4.16-12.16-4.16 12.16h8.32Zm23.694-2.24c-.186-1.307-.706-2.32-1.56-3.04-.853-.72-1.866-1.08-3.04-1.08-1.68 0-2.986.613-3.92 1.84-.906 1.227-1.36 2.947-1.36 5.16s.454 3.933 1.36 5.16c.934 1.227 2.24 1.84 3.92 1.84 1.254 0 2.307-.373 3.16-1.12.854-.773 1.387-1.867 1.6-3.28l5.12.24c-.186 1.68-.733 3.147-1.64 4.4-.906 1.227-2.08 2.173-3.52 2.84-1.413.667-2.986 1-4.72 1-2.08 0-3.906-.453-5.48-1.36-1.546-.907-2.76-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84 0-2.24.427-4.187 1.28-5.84.88-1.68 2.094-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.68 0 3.227.32 4.64.96 1.414.64 2.56 1.56 3.44 2.76.907 1.2 1.454 2.6 1.64 4.2l-5.12.28Zm11.486-7.72.12 3.4c.534-1.227 1.307-2.173 2.32-2.84 1.04-.693 2.267-1.04 3.68-1.04 1.494 0 2.76.387 3.8 1.16 1.067.747 1.827 1.813 2.28 3.2.507-1.44 1.294-2.52 2.36-3.24 1.094-.747 2.414-1.12 3.96-1.12 1.414 0 2.64.307 3.68.92s1.84 1.52 2.4 2.72c.56 1.2.84 2.667.84 4.4V38h-4.96V25.92c0-1.813-.293-3.187-.88-4.12-.56-.96-1.413-1.44-2.56-1.44-.906 0-1.68.213-2.32.64-.64.427-1.133 1.053-1.48 1.88-.32.827-.48 1.84-.48 3.04V38h-4.56V25.92c0-1.2-.133-2.213-.4-3.04-.24-.827-.626-1.453-1.16-1.88-.506-.427-1.133-.64-1.88-.64-.906 0-1.68.227-2.32.68-.64.427-1.133 1.053-1.48 1.88-.32.827-.48 1.827-.48 3V38h-4.96V16.8h4.48Zm26.723 10.6c0-2.24.427-4.187 1.28-5.84.854-1.68 2.067-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.84 0 3.494.413 4.96 1.24 1.467.827 2.64 2.08 3.52 3.76.88 1.653 1.347 3.693 1.4 6.12v1.32h-15.08c.107 1.813.614 3.227 1.52 4.24.907.987 2.134 1.48 3.68 1.48.987 0 1.88-.253 2.68-.76a4.803 4.803 0 0 0 1.84-2.2l5.08.36c-.64 2.027-1.84 3.64-3.6 4.84-1.733 1.173-3.733 1.76-6 1.76-2.08 0-3.906-.453-5.48-1.36-1.573-.907-2.786-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84Zm15.16-2.04c-.213-1.733-.76-3.013-1.64-3.84-.853-.827-1.893-1.24-3.12-1.24-1.44 0-2.6.453-3.48 1.36-.88.88-1.44 2.12-1.68 3.72h9.92ZM163.139 9.6V38h-5.04V9.6h5.04Zm8.322 7.2.24 5.88-.64-.36c.32-2.053 1.094-3.56 2.32-4.52 1.254-.987 2.787-1.48 4.6-1.48 2.32 0 4.107.733 5.36 2.2 1.254 1.44 1.88 3.387 1.88 5.84V38h-4.96V25.92c0-1.253-.12-2.28-.36-3.08-.24-.8-.64-1.413-1.2-1.84-.533-.427-1.253-.64-2.16-.64-1.44 0-2.573.48-3.4 1.44-.8.933-1.2 2.307-1.2 4.12V38h-4.96V16.8h4.48Zm30.003 7.72c-.186-1.307-.706-2.32-1.56-3.04-.853-.72-1.866-1.08-3.04-1.08-1.68 0-2.986.613-3.92 1.84-.906 1.227-1.36 2.947-1.36 5.16s.454 3.933 1.36 5.16c.934 1.227 2.24 1.84 3.92 1.84 1.254 0 2.307-.373 3.16-1.12.854-.773 1.387-1.867 1.6-3.28l5.12.24c-.186 1.68-.733 3.147-1.64 4.4-.906 1.227-2.08 2.173-3.52 2.84-1.413.667-2.986 1-4.72 1-2.08 0-3.906-.453-5.48-1.36-1.546-.907-2.76-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84 0-2.24.427-4.187 1.28-5.84.88-1.68 2.094-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.68 0 3.227.32 4.64.96 1.414.64 2.56 1.56 3.44 2.76.907 1.2 1.454 2.6 1.64 4.2l-5.12.28Zm11.443 8.16V38h-5.6v-5.32h5.6Z"/><path fill="#171717" fill-rule="evenodd" d="m7.839 40.783 16.03-28.054L20 6 0 40.783h7.839Zm8.214 0H40L27.99 19.894l-4.02 7.032 3.976 6.914H20.02l-3.967 6.943Z" clip-rule="evenodd"/></svg>
</file>

<file path="public/placeholder.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>
</file>

<file path="styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
body {
  font-family: Arial, Helvetica, sans-serif;
}
@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="styles/ticker.css">
@keyframes ticker {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-33.333%);
  }
}
.ticker {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
}
.ticker-track {
  display: flex;
  animation: ticker var(--scroll-speed) linear infinite;
  white-space: nowrap;
}
.ticker-item {
  display: flex;
  align-items: center;
  padding: 0 1rem;
  transition: background-color 0.2s ease;
}
.ticker-item:hover {
  background-color: rgba(0, 0, 0, 0.1);
}
.ticker-item.active {
  background-color: rgba(0, 0, 0, 0.15);
}
/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .ticker-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
  }
  .ticker-item.active {
    background-color: rgba(255, 255, 255, 0.15);
  }
}
</file>

<file path="tests/components/Dashboard.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import Dashboard from '../../components/Dashboard';
import { dashboardService } from '../../lib/services/dashboard-service';
import type { WidgetConfig } from '../../lib/types/market-data';
// Mock dashboard service
jest.mock('../../lib/services/dashboard-service', () => ({
  dashboardService: {
    initialize: jest.fn(),
    addWidget: jest.fn(),
    removeWidget: jest.fn(),
    updateWidget: jest.fn(),
    getAllWidgets: jest.fn(),
    setTheme: jest.fn(),
    setLayout: jest.fn(),
    on: jest.fn(),
    removeListener: jest.fn(),
  },
}));
describe('Dashboard Component', () => {
  const mockWidget: WidgetConfig = {
    id: 'test-widget-1',
    type: 'chart',
    position: {
      x: 0,
      y: 0,
      width: 2,
      height: 2,
    },
    settings: {
      symbol: 'AAPL',
      chartConfig: {
        type: 'line',
        timeframe: '1m',
      },
    },
  };
  beforeEach(() => {
    jest.clearAllMocks();
    (dashboardService.getAllWidgets as jest.Mock).mockReturnValue([]);
  });
  it('should render without crashing', () => {
    render(<Dashboard />);
    expect(screen.getByText('Trading Dashboard')).toBeInTheDocument();
  });
  it('should initialize dashboard service with props', () => {
    render(
      <Dashboard
        defaultLayout="flex"
        defaultTheme="dark"
        refreshInterval={2000}
      />
    );
    expect(dashboardService.initialize).toHaveBeenCalledWith({
      layout: 'flex',
      theme: 'dark',
      refreshInterval: 2000,
    });
  });
  it('should render widgets', () => {
    (dashboardService.getAllWidgets as jest.Mock).mockReturnValue([mockWidget]);
    render(<Dashboard />);
    expect(screen.getByText('AAPL')).toBeInTheDocument();
  });
  it('should handle theme toggle', () => {
    render(<Dashboard defaultTheme="light" />);
    const toggleButton = screen.getByText('Toggle Dark Mode');
    fireEvent.click(toggleButton);
    expect(dashboardService.setTheme).toHaveBeenCalledWith('dark');
  });
  it('should handle layout change', () => {
    render(<Dashboard defaultLayout="grid" />);
    const layoutSelect = screen.getByRole('combobox');
    fireEvent.change(layoutSelect, { target: { value: 'flex' } });
    expect(dashboardService.setLayout).toHaveBeenCalledWith('flex');
  });
  it('should handle widget addition', async () => {
    render(<Dashboard />);
    const addButton = screen.getByText('Add Chart Widget');
    fireEvent.click(addButton);
    await waitFor(() => {
      expect(dashboardService.addWidget).toHaveBeenCalled();
    });
  });
  it('should handle widget removal', async () => {
    (dashboardService.getAllWidgets as jest.Mock).mockReturnValue([mockWidget]);
    render(<Dashboard />);
    const removeButton = screen.getByText('Remove');
    fireEvent.click(removeButton);
    await waitFor(() => {
      expect(dashboardService.removeWidget).toHaveBeenCalledWith(mockWidget.id);
    });
  });
  it('should handle widget expansion', async () => {
    (dashboardService.getAllWidgets as jest.Mock).mockReturnValue([mockWidget]);
    render(<Dashboard />);
    const expandButton = screen.getByText('Expand');
    fireEvent.click(expandButton);
    await waitFor(() => {
      expect(dashboardService.updateWidget).toHaveBeenCalledWith(
        mockWidget.id,
        expect.objectContaining({
          position: expect.objectContaining({
            width: mockWidget.position.width + 1,
          }),
        })
      );
    });
  });
  it('should handle widget data updates', () => {
    (dashboardService.getAllWidgets as jest.Mock).mockReturnValue([mockWidget]);
    render(<Dashboard />);
    // Simulate widget data update
    const handlers: Record<string, Function> = {};
    (dashboardService.on as jest.Mock).mockImplementation((event, handler) => {
      handlers[event] = handler;
    });
    const mockData = {
      data: [{ timestamp: Date.now(), value: 150 }],
      config: mockWidget.settings.chartConfig,
      metadata: {
        symbol: 'AAPL',
        lastUpdated: Date.now(),
        dataPoints: 1,
      },
    };
    handlers['widgetData']({ widgetId: mockWidget.id, data: mockData });
    expect(screen.getByText(JSON.stringify(mockData, null, 2))).toBeInTheDocument();
  });
  it('should clean up event listeners on unmount', () => {
    const { unmount } = render(<Dashboard />);
    unmount();
    expect(dashboardService.removeListener).toHaveBeenCalled();
  });
  it('should handle errors gracefully', async () => {
    (dashboardService.addWidget as jest.Mock).mockRejectedValue(new Error('Test error'));
    render(<Dashboard />);
    const addButton = screen.getByText('Add Chart Widget');
    fireEvent.click(addButton);
    // Verify error is handled (no crash)
    await waitFor(() => {
      expect(dashboardService.addWidget).toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/services/analytics-service.test.ts">
import { analyticsService } from '../../lib/services/analytics-service';
import type { MarketData } from '../../lib/types/market-data';
describe('AnalyticsService', () => {
  const mockMarketData: MarketData[] = [
    {
      symbol: 'AAPL',
      price: 150.0,
      change: 2.5,
      changePercent: 1.67,
      volume: 1000000,
      lastUpdated: Date.now(),
      metadata: {
        source: 'websocket',
        reliability: 1,
        staleness: 0,
      },
    },
    {
      symbol: 'AAPL',
      price: 152.5,
      change: 2.5,
      changePercent: 1.67,
      volume: 1200000,
      lastUpdated: Date.now() + 60000,
      metadata: {
        source: 'websocket',
        reliability: 1,
        staleness: 0,
      },
    },
  ];
  describe('calculateVolatility', () => {
    it('should calculate volatility correctly', async () => {
      const result = await analyticsService.calculateVolatility(mockMarketData, {
        period: 2,
      });
      expect(result).toHaveProperty('value');
      expect(result).toHaveProperty('confidence');
      expect(result).toHaveProperty('metadata');
      expect(result.value).toBeGreaterThan(0);
      expect(result.confidence).toBeGreaterThan(0);
      expect(result.confidence).toBeLessThanOrEqual(1);
    });
    it('should handle single data point', async () => {
      const result = await analyticsService.calculateVolatility([mockMarketData[0]], {
        period: 1,
      });
      expect(result.value).toBe(0);
      expect(result.confidence).toBeLessThan(1);
    });
  });
  describe('calculateMomentum', () => {
    it('should calculate momentum correctly', async () => {
      const result = await analyticsService.calculateMomentum(mockMarketData, {
        period: 2,
        smoothing: 0.2,
      });
      expect(result).toHaveProperty('value');
      expect(result).toHaveProperty('confidence');
      expect(result).toHaveProperty('metadata');
      expect(typeof result.value).toBe('number');
      expect(result.metadata.method).toBe('exponential_average');
    });
    it('should use default smoothing if not provided', async () => {
      const result = await analyticsService.calculateMomentum(mockMarketData, {
        period: 2,
      });
      expect(result.value).toBeDefined();
    });
  });
  describe('calculateCorrelation', () => {
    const mockData2: MarketData[] = [
      {
        ...mockMarketData[0],
        price: 145.0,
      },
      {
        ...mockMarketData[1],
        price: 147.5,
      },
    ];
    it('should calculate correlation correctly', async () => {
      const result = await analyticsService.calculateCorrelation(
        mockMarketData,
        mockData2,
        { period: 2 }
      );
      expect(result).toHaveProperty('value');
      expect(result.value).toBeGreaterThanOrEqual(-1);
      expect(result.value).toBeLessThanOrEqual(1);
      expect(result.metadata.method).toBe('pearson');
    });
    it('should handle perfectly correlated data', async () => {
      const result = await analyticsService.calculateCorrelation(
        mockMarketData,
        mockMarketData,
        { period: 2 }
      );
      expect(result.value).toBeCloseTo(1);
    });
  });
  describe('calculateStatistics', () => {
    it('should calculate basic statistics correctly', async () => {
      const result = await analyticsService.calculateStatistics(mockMarketData);
      expect(result).toHaveProperty('mean');
      expect(result).toHaveProperty('median');
      expect(result).toHaveProperty('standardDeviation');
      expect(result).toHaveProperty('skewness');
      expect(result).toHaveProperty('kurtosis');
      expect(result).toHaveProperty('min');
      expect(result).toHaveProperty('max');
      expect(result.mean).toBe((150.0 + 152.5) / 2);
      expect(result.min).toBe(150.0);
      expect(result.max).toBe(152.5);
    });
    it('should handle single data point', async () => {
      const result = await analyticsService.calculateStatistics([mockMarketData[0]]);
      expect(result.mean).toBe(150.0);
      expect(result.median).toBe(150.0);
      expect(result.standardDeviation).toBe(0);
      expect(result.min).toBe(150.0);
      expect(result.max).toBe(150.0);
    });
  });
  describe('detectOutliers', () => {
    it('should detect outliers correctly', async () => {
      const dataWithOutlier = [
        ...mockMarketData,
        {
          ...mockMarketData[0],
          price: 300.0, // Significant outlier
        },
      ];
      const result = await analyticsService.detectOutliers(dataWithOutlier, {
        period: 3,
        outlierThreshold: 2,
      });
      expect(result).toContain(2); // Index of the outlier
    });
    it('should handle no outliers case', async () => {
      const result = await analyticsService.detectOutliers(mockMarketData, {
        period: 2,
        outlierThreshold: 2,
      });
      expect(result).toHaveLength(0);
    });
    it('should use default threshold if not provided', async () => {
      const result = await analyticsService.detectOutliers(mockMarketData, {
        period: 2,
      });
      expect(Array.isArray(result)).toBe(true);
    });
  });
});
</file>

<file path="tests/services/dashboard-service.test.ts">
import { dashboardService } from '../../lib/services/dashboard-service';
import type { WidgetConfig, MarketData } from '../../lib/types/market-data';
describe('DashboardService', () => {
  const mockWidget: WidgetConfig = {
    id: 'test-widget-1',
    type: 'chart',
    position: {
      x: 0,
      y: 0,
      width: 2,
      height: 2,
    },
    settings: {
      symbol: 'AAPL',
      chartConfig: {
        type: 'line',
        timeframe: '1m',
      },
    },
  };
  const mockMarketData: MarketData = {
    symbol: 'AAPL',
    price: 150.0,
    change: 2.5,
    changePercent: 1.67,
    volume: 1000000,
    lastUpdated: Date.now(),
    metadata: {
      source: 'websocket',
      reliability: 1,
      staleness: 0,
    },
  };
  beforeEach(async () => {
    // Reset dashboard state
    await dashboardService.initialize({
      layout: 'grid',
      theme: 'light',
      refreshInterval: 1000,
      maxWidgets: 12,
    });
  });
  describe('initialization', () => {
    it('should initialize with default config', async () => {
      const state = dashboardService.getDashboardState();
      expect(state.layout).toBe('grid');
      expect(state.theme).toBe('light');
      expect(state.widgets.size).toBe(0);
      expect(state.activeSymbols.size).toBe(0);
    });
    it('should handle custom config', async () => {
      await dashboardService.initialize({
        layout: 'flex',
        theme: 'dark',
        refreshInterval: 2000,
        maxWidgets: 6,
      });
      const state = dashboardService.getDashboardState();
      expect(state.layout).toBe('flex');
      expect(state.theme).toBe('dark');
    });
  });
  describe('widget management', () => {
    it('should add widget correctly', async () => {
      await dashboardService.addWidget(mockWidget);
      const widgets = dashboardService.getAllWidgets();
      expect(widgets).toHaveLength(1);
      expect(widgets[0]).toEqual(mockWidget);
    });
    it('should enforce maximum widget limit', async () => {
      const maxWidgets = 2;
      await dashboardService.initialize({ maxWidgets });
      // Add widgets up to limit
      await dashboardService.addWidget({ ...mockWidget, id: 'widget-1' });
      await dashboardService.addWidget({ ...mockWidget, id: 'widget-2' });
      // Try to add one more
      await expect(
        dashboardService.addWidget({ ...mockWidget, id: 'widget-3' })
      ).rejects.toThrow('Maximum number of widgets reached');
    });
    it('should remove widget correctly', async () => {
      await dashboardService.addWidget(mockWidget);
      await dashboardService.removeWidget(mockWidget.id);
      const widgets = dashboardService.getAllWidgets();
      expect(widgets).toHaveLength(0);
    });
    it('should update widget correctly', async () => {
      await dashboardService.addWidget(mockWidget);
      const updates: Partial<WidgetConfig> = {
        position: {
          ...mockWidget.position,
          width: 3,
        },
      };
      await dashboardService.updateWidget(mockWidget.id, updates);
      const widget = dashboardService.getWidgetConfig(mockWidget.id);
      expect(widget?.position.width).toBe(3);
    });
  });
  describe('theme management', () => {
    it('should change theme correctly', () => {
      dashboardService.setTheme('dark');
      const state = dashboardService.getDashboardState();
      expect(state.theme).toBe('dark');
    });
  });
  describe('layout management', () => {
    it('should change layout correctly', () => {
      dashboardService.setLayout('flex');
      const state = dashboardService.getDashboardState();
      expect(state.layout).toBe('flex');
    });
  });
  describe('event handling', () => {
    it('should emit events on widget changes', async () => {
      const widgetAddedHandler = jest.fn();
      const widgetRemovedHandler = jest.fn();
      const widgetUpdatedHandler = jest.fn();
      dashboardService.on('widgetAdded', widgetAddedHandler);
      dashboardService.on('widgetRemoved', widgetRemovedHandler);
      dashboardService.on('widgetUpdated', widgetUpdatedHandler);
      // Test add
      await dashboardService.addWidget(mockWidget);
      expect(widgetAddedHandler).toHaveBeenCalledWith(mockWidget);
      // Test update
      const updates: Partial<WidgetConfig> = {
        position: { ...mockWidget.position, width: 3 },
      };
      await dashboardService.updateWidget(mockWidget.id, updates);
      expect(widgetUpdatedHandler).toHaveBeenCalled();
      // Test remove
      await dashboardService.removeWidget(mockWidget.id);
      expect(widgetRemovedHandler).toHaveBeenCalledWith(mockWidget.id);
    });
    it('should emit events on theme and layout changes', () => {
      const themeChangedHandler = jest.fn();
      const layoutChangedHandler = jest.fn();
      dashboardService.on('themeChanged', themeChangedHandler);
      dashboardService.on('layoutChanged', layoutChangedHandler);
      dashboardService.setTheme('dark');
      expect(themeChangedHandler).toHaveBeenCalledWith('dark');
      dashboardService.setLayout('flex');
      expect(layoutChangedHandler).toHaveBeenCalledWith('flex');
    });
  });
});
</file>

<file path="tests/services/visualization-service.test.ts">
import { visualizationService } from '../../lib/services/visualization-service';
import type { MarketData, ChartConfig } from '../../lib/types/market-data';
describe('VisualizationService', () => {
  const mockMarketData: MarketData[] = [
    {
      symbol: 'AAPL',
      price: 150.0,
      change: 2.5,
      changePercent: 1.67,
      volume: 1000000,
      lastUpdated: Date.now(),
      metadata: {
        source: 'websocket',
        reliability: 1,
        staleness: 0,
      },
    },
    {
      symbol: 'AAPL',
      price: 152.5,
      change: 2.5,
      changePercent: 1.67,
      volume: 1200000,
      lastUpdated: Date.now() + 60000,
      metadata: {
        source: 'websocket',
        reliability: 1,
        staleness: 0,
      },
    },
  ];
  const mockChartConfig: ChartConfig = {
    type: 'line',
    timeframe: '1m',
    indicators: ['SMA-20'],
    overlay: false,
    theme: 'light',
  };
  describe('prepareChartData', () => {
    it('should transform market data into chart data', async () => {
      const result = await visualizationService.prepareChartData(mockMarketData, mockChartConfig);
      expect(result).toHaveProperty('data');
      expect(result).toHaveProperty('config');
      expect(result).toHaveProperty('metadata');
      expect(result.data).toHaveLength(2);
      expect(result.config).toEqual(mockChartConfig);
      expect(result.metadata.symbol).toBe('AAPL');
    });
    it('should handle different chart types', async () => {
      // Test line chart
      const lineResult = await visualizationService.prepareChartData(mockMarketData, {
        ...mockChartConfig,
        type: 'line',
      });
      expect(lineResult.data[0]).toHaveProperty('value');
      expect(lineResult.data[0]).toHaveProperty('timestamp');
      // Test candlestick chart
      const candlestickResult = await visualizationService.prepareChartData(mockMarketData, {
        ...mockChartConfig,
        type: 'candlestick',
      });
      expect(candlestickResult.data[0]).toHaveProperty('open');
      expect(candlestickResult.data[0]).toHaveProperty('close');
      expect(candlestickResult.data[0]).toHaveProperty('high');
      expect(candlestickResult.data[0]).toHaveProperty('low');
      // Test bar chart
      const barResult = await visualizationService.prepareChartData(mockMarketData, {
        ...mockChartConfig,
        type: 'bar',
      });
      expect(barResult.data[0]).toHaveProperty('value');
      expect(barResult.data[0].value).toBe(mockMarketData[0].volume);
    });
    it('should aggregate data based on timeframe', async () => {
      const result = await visualizationService.prepareChartData(mockMarketData, {
        ...mockChartConfig,
        timeframe: '5m',
      });
      // Since our mock data points are within 5 minutes, they should be aggregated
      expect(result.data).toHaveLength(1);
      if (result.config.type === 'line') {
        expect(result.data[0].value).toBe(mockMarketData[1].price);
      }
    });
    it('should add technical indicators when requested', async () => {
      const result = await visualizationService.prepareChartData(mockMarketData, {
        ...mockChartConfig,
        indicators: ['SMA-20', 'RSI-14'],
      });
      expect(result.data[0]).toHaveProperty('SMA-20');
      expect(result.data[0]).toHaveProperty('RSI-14');
    });
    it('should handle empty data array', async () => {
      const result = await visualizationService.prepareChartData([], mockChartConfig);
      expect(result.data).toHaveLength(0);
      expect(result.metadata.symbol).toBe('unknown');
    });
    it('should throw error for invalid chart type', async () => {
      await expect(
        visualizationService.prepareChartData(mockMarketData, {
          ...mockChartConfig,
          type: 'invalid' as any,
        })
      ).rejects.toThrow('Unsupported chart type: invalid');
    });
  });
  describe('getDefaultConfig', () => {
    it('should return default configuration', () => {
      const config = visualizationService.getDefaultConfig();
      expect(config).toHaveProperty('type', 'line');
      expect(config).toHaveProperty('timeframe', '1m');
      expect(config).toHaveProperty('indicators');
      expect(config).toHaveProperty('overlay', false);
      expect(config).toHaveProperty('theme', 'light');
    });
    it('should allow overriding chart type', () => {
      const config = visualizationService.getDefaultConfig('candlestick');
      expect(config.type).toBe('candlestick');
    });
  });
});
</file>

<file path="tests/jest.setup.ts">
import '@testing-library/jest-dom';
import { TextEncoder, TextDecoder } from 'util';
// Set up global mocks
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
// Mock WebSocket
class MockWebSocket {
  public readyState: number = 0;
  public url: string = '';
  public onopen: (() => void) | null = null;
  public onclose: (() => void) | null = null;
  public onmessage: ((event: { data: string }) => void) | null = null;
  public onerror: ((error: Error) => void) | null = null;
  constructor(url: string) {
    this.url = url;
    this.readyState = 1; // Connected
    setTimeout(() => this.onopen?.(), 0);
  }
  send(data: string): void {
    setTimeout(() => {
      this.onmessage?.({ data });
    }, 0);
  }
  close(): void {
    this.readyState = 3; // Closed
    setTimeout(() => this.onclose?.(), 0);
  }
}
global.WebSocket = MockWebSocket as any;
// Mock Redis for cache manager
jest.mock('../lib/utils/cache-manager', () => ({
  cacheManager: {
    get: jest.fn(),
    set: jest.fn(),
    invalidate: jest.fn(),
    invalidateByTag: jest.fn(),
    getStats: jest.fn(),
  },
}));
// Mock metrics
jest.mock('../lib/utils/metrics', () => ({
  metrics: {
    register: jest.fn(),
    record: jest.fn(),
  },
}));
// Mock logger
jest.mock('../lib/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  },
}));
// Set up test environment variables
process.env.NODE_ENV = 'test';
process.env.POLYGON_API_KEY = 'test_api_key';
process.env.JWT_SECRET = 'test_jwt_secret';
// Increase test timeout
jest.setTimeout(10000);
// Clean up after each test
afterEach(() => {
  jest.clearAllMocks();
});
</file>

<file path="tests/setup.ts">
import { TextEncoder, TextDecoder } from 'util';
import { EventEmitter } from 'events';
// Set up global mocks
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
// Mock WebSocket
class MockWebSocket extends EventEmitter {
  public readyState: number = 0;
  public url: string = '';
  constructor(url: string) {
    super();
    this.url = url;
    this.readyState = 1; // Connected
  }
  send(data: string): void {
    this.emit('message', { data });
  }
  close(): void {
    this.readyState = 3; // Closed
    this.emit('close');
  }
}
global.WebSocket = MockWebSocket as any;
// Mock Redis for cache manager
jest.mock('ioredis', () => {
  return jest.fn().mockImplementation(() => ({
    get: jest.fn(),
    set: jest.fn(),
    del: jest.fn(),
    flushdb: jest.fn(),
    quit: jest.fn(),
    on: jest.fn(),
  }));
});
// Mock metrics
jest.mock('../lib/utils/metrics', () => ({
  metrics: {
    register: jest.fn(),
    record: jest.fn(),
  },
}));
// Mock logger
jest.mock('../lib/utils/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    debug: jest.fn(),
  },
}));
// Set up test environment variables
process.env.NODE_ENV = 'test';
process.env.POLYGON_API_KEY = 'test_api_key';
process.env.JWT_SECRET = 'test_jwt_secret';
// Increase test timeout
jest.setTimeout(10000);
// Clean up after each test
afterEach(() => {
  jest.clearAllMocks();
});
</file>

<file path="types/ai-researcher.ts">
export interface ResearchReport {
  id: string
  title: string
  summary: string
  category: string
  content: string
  date: string
  author: string
}
export interface RiskAssessmentData {
  recessionRisk: number
  marketVolatility: number
  creditRisk: number
  liquidityRisk: number
}
export interface GeopoliticalRisk {
  trends: Array<{
    name: string
    impact: "positive" | "negative" | "neutral"
    description: string
  }>
}
export interface EconomicCyclePoint {
  date: string
  value: number
  phase: string
}
export interface EconomicData {
  gdpGrowth: number
  gdpGrowthChange: number
  inflation: number
  inflationChange: number
  interestRate: number
  interestRateChange: number
  unemploymentRate: number
  unemploymentRateChange: number
  riskAssessment: RiskAssessmentData
  economicCycle: EconomicCyclePoint[]
  geopoliticalRisk: GeopoliticalRisk
  researchReports: ResearchReport[]
}
export interface Alert {
  title: string
  description: string
}
</file>

<file path="types/asset-screener.ts">
export interface Fundamentals {
  peRatioMin: number
  peRatioMax: number
  epsGrowthMin: number
  debtToEquityMax: number
  dividendYieldMin: number
  marketCapMin: number
}
export interface Technicals {
  rsiMin: number
  rsiMax: number
  macdSignal: string
  movingAveragePeriod: number
  movingAverageType: string
}
export interface Sentiment {
  analystRatingMin: number
  newsScore: string
  insiderBuying: boolean
}
export interface ScreeningCriteria {
  assetClass: string
  fundamentals: Fundamentals
  technicals: Technicals
  sentiment: Sentiment
}
export interface Asset {
  id: string
  symbol: string
  name: string
  assetClass: string
  price: number
  change: number
  score: number
  volume: number
  marketCap: number
  peRatio: number
}
</file>

<file path="types/asset.ts">
export interface Asset {
  id: string
  symbol: string
  name: string
  assetClass: string
  price: number
  change: number
  score: number
}
export interface AssetDetails {
  name: string
  description: string
  sector: string
  industry: string
  marketCap: number
  peRatio: number
  dividendYield: number
  beta: number
  eps: number
  high52Week: number
  low52Week: number
  volume: number
  price: number
  relatedAssets: Asset[]
  newsItems: NewsItem[]
}
export interface NewsItem {
  id: string
  title: string
  summary: string
  url: string
  publishedAt: string
  source: string
}
export interface ChartDataPoint {
  date: string
  price: number
}
</file>

<file path="types/backtesting.ts">
export interface Asset {
  symbol: string
  name: string
  type: "stock" | "crypto" | "forex" | "commodity" | "derivative"
}
export interface DateRange {
  from: Date | null
  to: Date | null
}
export type Strategy = "momentum" | "meanReversion" | "trendFollowing"
export interface StrategyParameters {
  [key: string]: number
}
export interface PerformanceDataPoint {
  date: string
  strategy: number
  benchmark: number
}
export interface BacktestMetrics {
  totalReturn: number
  annualizedReturn: number
  sharpeRatio: number
  sortinoRatio: number
  maxDrawdown: number
  winRate: number
}
export interface BenchmarkComparison {
  name: string
  return: number
  sharpeRatio: number
  maxDrawdown: number
}
export interface BacktestParameters {
  assets: string[]
  strategy: Strategy
  startDate: Date
  endDate: Date
}
export interface BacktestResults {
  returns: number[]
  dates: string[]
  metrics: {
    totalReturn: number
    annualizedReturn: number
    sharpeRatio: number
    maxDrawdown: number
    volatility: number
  }
  trades: {
    date: string
    type: "buy" | "sell"
    asset: string
    price: number
    quantity: number
  }[]
}
</file>

<file path="types/due-diligence.ts">
export interface SECFiling {
  type: string
  date: string
  keyInsights: string
  sentiment: "Positive" | "Negative" | "Neutral"
}
export interface FinancialMetric {
  value: string
  yoyChange: string
}
export interface FinancialStatements {
  keyMetrics: {
    [key: string]: FinancialMetric
  }
  revenueEarningsTrend: {
    year: string
    revenue: number
    earnings: number
  }[]
}
export interface EarningsCall {
  keyTakeaways: string[]
  sentiment: "Positive" | "Negative" | "Neutral"
  notableQuotes: string[]
}
export interface InsiderTransaction {
  date: string
  insider: string
  type: "Buy" | "Sell"
  shares: number
  value: number
}
export interface InsiderTransactions {
  transactions: InsiderTransaction[]
  aiAnalysis: string
}
export interface Valuation {
  dcf: {
    intrinsicValue: number
    currentPrice: number
    upside: number
  }
  evEbitda: {
    companyRatio: number
    industryAverage: number
    valuation: "Undervalued" | "Overvalued" | "Fair Valued"
  }
  peerBenchmarking: {
    [key: string]: {
      company: number
      peerAverage: number
      valuation: "Undervalued" | "Overvalued" | "Fair Valued"
    }
  }
}
export interface RiskFactor {
  name: string
  risk: "Low" | "Medium" | "High"
  description: string
}
export interface EarningsManipulation {
  overallRisk: "Low" | "Medium" | "High"
  overallAssessment: string
  riskFactors: RiskFactor[]
  redFlags: string[]
}
export interface AIReport {
  hedgeFund: string
  retail: string
  institutional: string
}
export interface DueDiligenceData {
  secFilings: SECFiling[]
  financialStatements: FinancialStatements
  earningsCalls: EarningsCall
  insiderTransactions: InsiderTransactions
  valuation: Valuation
  earningsManipulation: EarningsManipulation
  aiReport: AIReport
}
</file>

<file path="types/economic-events.ts">
export interface EconomicEvent {
  date: string
  name: string
  country: string
  impact: "High" | "Medium" | "Low"
  previous: string
  forecast: string
}
export interface HighImpactEvent {
  name: string
  date: string
  marketImplications: {
    direction: "up" | "down" | "neutral"
    description: string
  }
  affectedSectors: string[]
}
export interface AIRecommendation {
  asset: string
  type: "Buy" | "Sell"
  recommendation: string
  rationale: string
  timeHorizon: string
}
export interface EconomicTrend {
  name: string
  direction: "up" | "down"
  duration: string
  confidence: number
  opportunities: string[]
}
export interface EconomicEventData {
  upcomingEvents: EconomicEvent[]
  highImpactEvents: HighImpactEvent[]
  aiRecommendations: AIRecommendation[]
  economicTrends: EconomicTrend[]
}
</file>

<file path="types/market.ts">
export interface MarketIndex {
  name: string;
  symbol: string;
  value: number;
  change: number;
  changePercent: number;
  lastUpdated: number;
  error?: string;
}
</file>

<file path="types/polygon.ts">
// Common response type
export interface PolygonResponse<T> {
  status: string;
  request_id: string;
  count?: number;
  next_url?: string;
  results: T;
}
// Aggregates (bars) types
export interface AggregateBar {
  o: number;  // Open price
  h: number;  // High price
  l: number;  // Low price
  c: number;  // Close price
  v: number;  // Volume
  vw: number; // Volume weighted average price
  t: number;  // Timestamp (Unix MS)
  n: number;  // Number of transactions
}
export interface AggregatesResponse extends PolygonResponse<AggregateBar[]> {
  ticker: string;
  queryCount: number;
  resultsCount: number;
  adjusted: boolean;
}
// Ticker details types
export interface TickerDetails {
  ticker: string;
  name: string;
  market: string;
  locale: string;
  primary_exchange: string;
  type: string;
  active: boolean;
  currency_name: string;
  cik?: string;
  composite_figi?: string;
  share_class_figi?: string;
  last_updated_utc?: string;
  delisted_utc?: string;
  market_cap?: number;
  description?: string;
  homepage_url?: string;
  total_employees?: number;
  phone_number?: string;
  address?: {
    address1?: string;
    address2?: string;
    city?: string;
    state?: string;
    postal_code?: string;
  };
  branding?: {
    logo_url?: string;
    icon_url?: string;
  };
}
// Quote types
export interface LastQuote {
  P: number;  // Ask price
  S: number;  // Ask size
  p: number;  // Bid price
  s: number;  // Bid size
  t: number;  // Timestamp
  q: number;  // Sequence number
  z: number;  // Tape
  X: number;  // Ask exchange
  x: number;  // Bid exchange
}
// News types
export interface NewsItem {
  id: string;
  publisher: {
    name: string;
    homepage_url: string;
    logo_url: string;
    favicon_url: string;
  };
  title: string;
  author: string;
  published_utc: string;
  article_url: string;
  tickers: string[];
  description?: string;
  keywords?: string[];
  image_url?: string;
}
// Market status types
export interface MarketStatus {
  market: string;
  serverTime: string;
  exchanges: {
    nasdaq: string;
    nyse: string;
    otc: string;
  };
  currencies: {
    fx: string;
    crypto: string;
  };
  earlyHours: boolean;
  afterHours: boolean;
}
// WebSocket message types
export interface WebSocketMessage {
  ev: string;  // Event type
  sym: string; // Symbol
  [key: string]: any;
}
export interface TradeMessage extends WebSocketMessage {
  ev: 'T';
  p: number;  // Price
  s: number;  // Size
  t: number;  // Timestamp
  x: number;  // Exchange ID
  c: number[]; // Conditions
}
export interface QuoteMessage extends WebSocketMessage {
  ev: 'Q';
  bp: number; // Bid price
  bs: number; // Bid size
  ap: number; // Ask price
  as: number; // Ask size
  t: number;  // Timestamp
  bx: number; // Bid exchange
  ax: number; // Ask exchange
}
export interface AggregateMessage extends WebSocketMessage {
  ev: 'AM';
  sym: string;  // Symbol
  v: number;    // Volume
  av: number;   // Accumulated volume
  op: number;   // Open price
  vw: number;   // Volume weighted average price
  o: number;    // Open price
  h: number;    // High price
  l: number;    // Low price
  c: number;    // Close price
  a: number;    // Average price
  s: number;    // Start timestamp
  e: number;    // End timestamp
  z: number;    // Average trade size
}
// Snapshot types
export interface SnapshotTicker {
  ticker: string;
  day?: {
    o: number;  // Open price
    h: number;  // High price
    l: number;  // Low price
    c: number;  // Close price
    v: number;  // Volume
    vw: number; // Volume weighted average price
  };
  lastTrade?: {
    p: number;  // Price
    s: number;  // Size
    t: number;  // Timestamp
    c: number[]; // Conditions
  };
  min?: {
    av: number;  // Accumulated volume
    vw: number;  // Volume weighted average price
    o: number;   // Open price
    c: number;   // Close price
    h: number;   // High price
    l: number;   // Low price
    v: number;   // Volume
    t: number;   // Timestamp
  };
  prevDay?: {
    o: number;  // Open price
    h: number;  // High price
    l: number;  // Low price
    c: number;  // Close price
    v: number;  // Volume
    vw: number; // Volume weighted average price
  };
  todaysChange?: number;
  todaysChangePerc?: number;
  updated: number;
}
export interface SnapshotResponse {
  status: string;
  tickers: SnapshotTicker[];
}
</file>

<file path="types/portfolio-analytics.ts">
export interface AssetAllocation {
  name: string
  value: number
}
export interface PortfolioOverview {
  assetAllocation: AssetAllocation[]
  totalValue: number
  dailyChange: number
  totalReturn: number
  riskLevel: string
}
export interface PerformanceHistoryPoint {
  date: string
  value: number
  benchmark: number
}
export interface AssetClassPerformance {
  name: string
  currentValue: number
  dailyChange: number
  totalReturn: number
}
export interface PerformanceData {
  performanceHistory: PerformanceHistoryPoint[]
  assetClassPerformance: AssetClassPerformance[]
}
export interface BenchmarkComparisonPoint {
  name: string
  portfolio: number
  benchmark: number
}
export interface HedgeFundComparison {
  name: string
  portfolioPerformance: number
  strategyAverage: number
  difference: number
}
export interface BenchmarkingData {
  benchmarkComparison: BenchmarkComparisonPoint[]
  hedgeFundComparison: HedgeFundComparison[]
}
export interface Recommendation {
  type: "buy" | "sell" | "rebalance"
  asset: string
  reason: string
  action: string
}
export interface TaxOptimizationOpportunity {
  strategy: string
  potentialSavings: number
  impact: number
  action: string
}
export interface TaxLossHarvesting {
  asset: string
  currentLoss: number
  potentialTaxBenefit: number
  recommendedAction: string
}
export interface TaxOptimizationData {
  opportunities: TaxOptimizationOpportunity[]
  taxLossHarvesting: TaxLossHarvesting[]
  annualTaxSavings: number
}
export interface PortfolioData {
  overview: PortfolioOverview
  performance: PerformanceData
  benchmarking: BenchmarkingData
  recommendations: Recommendation[]
  taxOptimization: TaxOptimizationData
}
export interface PortfolioAnalytics {
  performance: {
    totalReturn: number
    annualizedReturn: number
    sharpeRatio: number
    volatility: number
    maxDrawdown: number
    alpha: number
    beta: number
  }
  allocation: {
    byAsset: Array<{ name: string; value: number }>
    bySector: Array<{ name: string; value: number }>
  }
  risk: {
    riskScore: number
    riskLevel: string
    concentrationRisk: string
    marketRisk: string
    currencyRisk: string
  }
}
</file>

<file path="types/portfolio-optimizer.ts">
export interface AllocationData {
  name: string
  value: number
}
export interface CorrelationData {
  [key: string]: {
    [key: string]: number
  }
}
export interface PerformanceData {
  date: string
  value: number
}
export interface TradeOrder {
  asset: string
  action: "Buy" | "Sell" | "Hold"
  quantity: number
  price: number
  reason: string
}
export interface PortfolioData {
  allocation: AllocationData[]
  correlation: CorrelationData
  performance: {
    returns: PerformanceData[]
    riskAdjustedReturns: PerformanceData[]
    drawdowns: PerformanceData[]
  }
  tradeSuggestions: TradeOrder[]
}
export interface OptimizationSettings {
  riskTolerance: number
  rebalanceFrequency: string
}
</file>

<file path="types/stock.ts">
export interface StockData {
  symbol: string;
  name: string | null;
  price: number | null;
  previousClose: number | null;
  change: number | null;
  changePercent: number | null;
  volume: number | null;
  dayOpen: number | null;
  dayHigh: number | null;
  dayLow: number | null;
  marketCap: number | null;
  exchange: string | null;
  type: string | null;
  lastUpdated: number | null;
}
</file>

<file path="types/technical-analysis.ts">
export interface TechnicalAnalysisData {
  priceData: {
    date: string
    price: number
  }[]
  detectedPatterns: {
    name: string
    description: string
    confidence: number
  }[]
  trendlines: {
    startDate: string
    endDate: string
    startValue: number
    endValue: number
  }[]
  fibonacciLevels: {
    level: number
    value: number
  }[]
  sentimentData: {
    bullishPercentage: number
    bearishPercentage: number
    neutralPercentage: number
  }
}
export interface TradeSignal {
  type: "buy" | "sell"
  symbol: string
  price: number
  confidence: number
  timestamp: string
}
</file>

<file path="types/trading-journal.ts">
export interface Trade {
  date: string
  symbol: string
  type: "Buy" | "Sell"
  entryPrice: number
  exitPrice: number
  quantity: number
  profitLoss: number
}
export interface BehaviorAnalysis {
  [behavior: string]: {
    score: number
    description: string
  }
}
export interface PerformanceMetrics {
  [metric: string]: number | string
}
export interface EquityPoint {
  date: string
  equity: number
}
export interface PerformanceReview {
  metrics: PerformanceMetrics
  equityCurve: EquityPoint[]
  improvementStrategies: string[]
}
export interface RealtimeFeedback {
  type: "warning" | "success" | "info"
  category: string
  title: string
  description: string
}
export interface TradeData {
  trades: Trade[]
  behaviorAnalysis: BehaviorAnalysis
  performanceReview: PerformanceReview
  realtimeFeedback: RealtimeFeedback[]
}
</file>

<file path=".cursorrules">
<cursor-tools Integration>
# Instructions
Use the following commands to get AI assistance:

**Web Search:**
`cursor-tools web "<your question>"` - Get answers from the web using Perplexity AI (e.g., `cursor-tools web "latest weather in London"`)
when using web for complex queries suggest writing the output to a file somewhere like local-research/<query summary>.md.

**Repository Context:**
`cursor-tools repo "<your question>"` - Get context-aware answers about this repository using Google Gemini (e.g., `cursor-tools repo "explain authentication flow"`)

**Documentation Generation:**
`cursor-tools doc [options]` - Generate comprehensive documentation for this repository (e.g., `cursor-tools doc --output docs.md`)
when using doc for remote repos suggest writing the output to a file somewhere like local-docs/<repo-name>.md.

**GitHub Information:**
`cursor-tools github pr [number]` - Get the last 10 PRs, or a specific PR by number (e.g., `cursor-tools github pr 123`)
`cursor-tools github issue [number]` - Get the last 10 issues, or a specific issue by number (e.g., `cursor-tools github issue 456`)

**Browser Automation (Stateless):**
`cursor-tools browser open <url> [options]` - Open a URL and capture page content, console logs, and network activity (e.g., `cursor-tools browser open "https://example.com" --html`)
`cursor-tools browser act "<instruction>" --url=<url> [options]` - Execute actions on a webpage using natural language instructions (e.g., `cursor-tools browser act "Click Login" --url=https://example.com`)
`cursor-tools browser observe "<instruction>" --url=<url> [options]` - Observe interactive elements on a webpage and suggest possible actions (e.g., `cursor-tools browser observe "interactive elements" --url=https://example.com`)
`cursor-tools browser extract "<instruction>" --url=<url> [options]` - Extract data from a webpage based on natural language instructions (e.g., `cursor-tools browser extract "product names" --url=https://example.com/products`)

**Notes on Browser Commands:**
- All browser commands are stateless: each command starts with a fresh browser instance and closes it when done.
- When using `--connect-to`, special URL values are supported:
  - `current`: Use the existing page without reloading
  - `reload-current`: Use the existing page and refresh it (useful in development)
- Multi step workflows involving state or combining multiple actions are supported in the `act` command using the pipe (|) separator (e.g., `cursor-tools browser act "Click Login | Type 'user@example.com' into email | Click Submit" --url=https://example.com`)
- Video recording is available for all browser commands using the `--video=<directory>` option. This will save a video of the entire browser interaction at 1280x720 resolution. The video file will be saved in the specified directory with a timestamp.
- DO NOT ask browser act to "wait" for anything, the wait command is currently disabled in Stagehand.

**Tool Recommendations:**
- `cursor-tools web` is best for general web information not specific to the repository.
- `cursor-tools repo` is ideal for repository-specific questions, planning, code review and debugging.
- `cursor-tools doc` generates documentation for local or remote repositories.
- `cursor-tools browser` is useful for testing and debugging web apps.

**Running Commands:**
1. **Installed version:** Use `cursor-tools <command>` (if in PATH) or `npm exec cursor-tools "<command>"`, `yarn cursor-tools "<command>"`, `pnpm cursor-tools "<command>"`.
2. **Without installation:** Use `npx -y cursor-tools@latest "<command>"` or `bunx -y cursor-tools@latest "<command>"`.

**General Command Options (Supported by all commands):**
--model=<model name>: Specify an alternative AI model to use
--max-tokens=<number>: Control response length
--save-to=<file path>: Save command output to a file (in *addition* to displaying it)
--help: View all available options (help is not fully implemented yet)

**Documentation Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Generate documentation for a remote GitHub repository

**GitHub Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Access PRs/issues from a specific GitHub repository

**Browser Command Options (for 'open', 'act', 'observe', 'extract'):**
--console: Capture browser console logs (enabled by default, use --no-console to disable)
--html: Capture page HTML content
--network: Capture network activity (enabled by default, use --no-network to disable)
--screenshot=<file path>: Save a screenshot of the page
--timeout=<milliseconds>: Set navigation timeout (default: 30000ms)
--viewport=<width>x<height>: Set viewport size (e.g., 1280x720). When using --connect-to, viewport is only changed if this option is explicitly provided
--headless: Run browser in headless mode (default: true)
--no-headless: Show browser UI (non-headless mode) for debugging
--connect-to=<port>: Connect to existing Chrome instance
--wait=<duration or selector>: Wait after page load (e.g., '5s', '#element-id', 'selector:.my-class')
--video=<directory>: Save a video recording of the browser interaction to the specified directory (1280x720 resolution). Not available when using --connect-to

**Additional Notes:**
- For detailed information, see `node_modules/cursor-tools/README.md` (if installed locally).
- Configuration is in `cursor-tools.config.json` (or `~/.cursor-tools/config.json`).
- API keys are loaded from `.cursor-tools.env` (or `~/.cursor-tools/.env`).
- Browser commands require separate installation of Playwright: `npm install --save-dev playwright` or `npm install -g playwright`.
- **Remember:** You're part of a team of superhuman expert AIs. Work together to solve complex problems.
<!-- cursor-tools-version: 0.5.0 -->
</cursor-tools Integration>
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
.nyc_output

# next.js
/.next/
/out/
/build
.next

# production
/build
/dist

# misc
.DS_Store
*.pem
Thumbs.db

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env*.local
.env.production

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea
.vscode
*.swp
*.swo

# logs
logs
*.log

# docker
docker-compose.override.yml

# cache
.npm
.eslintcache
.cache

# Redis
dump.rdb
*.rdb

# System Files
.DS_Store
Thumbs.db
</file>

<file path="AI_AGENT_PROMPT.md">
# AI Agent Instructions for Trading Dashboard Implementation

## Documentation Suite
When implementing or modifying features in the trading dashboard, refer to these documents in the following order:

1. **API_Architecture.md**
   - Primary reference for overall system design
   - Defines centralized data store and state management
   - Details the Zustand-based market data store
   - Outlines how to avoid redundant state and API calls

2. **Integration_Guide.md**
   - General integration patterns and best practices
   - Frontend-Backend connection guidelines
   - Data contract definitions
   - Error handling patterns
   - Testing requirements checklist

3. **POLYGON_INTEGRATION.md**
   - Specific Polygon.io implementation details
   - WebSocket and REST API integration patterns
   - Concrete code examples and patterns
   - Security and monitoring guidelines

## Implementation Rules

### 1. Data Management
- ALWAYS use the centralized market data store via `useMarketData` hook
- NEVER maintain separate market data state in components
- ALWAYS handle data staleness as defined in API_Architecture.md
- USE the WebSocket manager for real-time updates through the store

### 2. State Updates
- IMPLEMENT all state update patterns from MODIFICATION_PATTERNS.md
- USE batch updates when handling multiple symbols
- INCLUDE proper data freshness checks
- FOLLOW the store update patterns for real-time data

### 3. Error Handling
- IMPLEMENT all error handling patterns from Integration_Guide.md
- USE fallback mechanisms when API calls fail
- INCLUDE proper error boundaries in React components
- FOLLOW the retry strategies for failed requests

### 4. Security
- NEVER expose API keys in client-side code
- ALWAYS use environment variables for sensitive data
- IMPLEMENT proper authentication checks
- FOLLOW rate limiting guidelines

### 5. Testing
- VERIFY against the Integration Checklist before completing implementation
- TEST both success and error scenarios
- INCLUDE performance testing for data-heavy operations
- VALIDATE WebSocket reconnection logic

## Implementation Process

1. **Planning Phase**
   - Review API_Architecture.md for system design patterns
   - Check Integration_Guide.md for relevant integration patterns
   - Reference POLYGON_INTEGRATION.md for specific implementation details

2. **Development Phase**
   - Follow the centralized service pattern
   - Implement proper error handling
   - Use provided TypeScript interfaces and types
   - Follow WebSocket management patterns

3. **Testing Phase**
   - Use the Integration Checklist from Integration_Guide.md
   - Verify error handling scenarios
   - Test WebSocket reconnection
   - Validate caching behavior

4. **Review Phase**
   - Ensure compliance with all architectural patterns
   - Verify security considerations
   - Check performance metrics
   - Validate documentation updates

## Example Usage

When implementing a new feature that requires market data:

1. Check API_Architecture.md for:
   - Market data store structure
   - Data flow patterns
   - State management patterns

2. Reference MODIFICATION_PATTERNS.md for:
   - State update patterns
   - Data freshness management
   - Real-time update patterns

3. Use Integration_Guide.md for:
   - Component integration patterns
   - Store usage examples
   - Error handling patterns

## Implementation Examples

### 1. Basic Market Data Usage
```typescript
// ✅ Do: Use the centralized store
const GoodComponent = () => {
  const { data, isLoading } = useMarketData('AAPL')
  return <Display data={data.AAPL} />
}

// ❌ Don't: Maintain separate state
const BadComponent = () => {
  const [data, setData] = useState(null)
  useEffect(() => {
    fetch('/api/market/AAPL').then(setData)
  }, [])
}
```

### 2. Real-time Updates
```typescript
// ✅ Do: Update through the store
const GoodLiveComponent = () => {
  const { data, updateData } = useMarketData('AAPL')
  useStockWebSocket({
    symbols: ['AAPL'],
    onUpdate: (update) => updateData('AAPL', update)
  })
}

// ❌ Don't: Manage WebSocket state separately
const BadLiveComponent = () => {
  const [data, setData] = useState(null)
  useWebSocket(/* ... */)
}
```

### 3. Batch Operations
```typescript
// ✅ Do: Use batch updates
const GoodBatchComponent = ({ symbols }) => {
  const { data, updateBatchData } = useMarketData(symbols)
  const { fetchData } = useMarketDataFetcher(symbols)
  
  useEffect(() => {
    fetchData()
    const interval = setInterval(fetchData, 30000)
    return () => clearInterval(interval)
  }, [symbols])
}
```

## Error Resolution

If encountering issues:

1. Check Integration_Guide.md for common integration patterns
2. Reference POLYGON_INTEGRATION.md for specific error handling examples
3. Verify against API_Architecture.md for architectural compliance

## Maintenance

When updating existing features:

1. Review API_Architecture.md for architectural impact
2. Check Integration_Guide.md for breaking changes
3. Update according to POLYGON_INTEGRATION.md patterns

## Documentation Updates

When making changes:

1. Update relevant sections in all three documents
2. Maintain version history
3. Add new patterns or examples as needed

Remember: These documents work together as a complete reference system. No implementation should bypass the patterns and practices defined in these guides.
</file>

<file path="API_Architecture.md">
# API Architecture and Data Aggregation Guide

## 1. Overview
This document outlines the architecture and implementation guide for a centralized system to fetch and distribute market data from the Polygon.io API. The system is designed to:
- Avoid duplicate API calls by centralizing data fetching.
- Cache common data (e.g., ticker information such as Apple's stock price) for distribution to multiple widgets or modules.
- Scale efficiently from a single user to millions of users without overloading the API.
- Leverage Polygon.io API's authentication and custom headers to secure and monitor API use.

## 2. Objectives
- **Centralization:** Make a single API call per refresh cycle instead of multiple calls from each widget.
- **Caching:** Store the fetched data in a caching layer to serve all widgets with the same data.
- **Scalability:** Enable the system to handle high volume traffic by avoiding redundant external API calls.
- **Reliability:** Ensure error handling, retries, and logging to maintain system robustness.

## 3. Architectural Components
### 3.1 Centralized API Service
- A backend service responsible for making all Polygon.io API calls.
- Handles API authentication via query parameters (using the API key) and sends required custom headers (e.g., X-Polygon-Edge-ID, X-Polygon-Edge-IP-Address, X-Polygon-Edge-User-Agent).

### 3.2 Caching Layer
- Stores fetched ticker data temporarily using a cache (e.g., Redis, in-memory cache).
- Implements a TTL (Time-To-Live) mechanism to ensure data is refreshed regularly.
- Serves cached data to multiple client widgets, minimizing API call frequency.

### 3.3 Client Widget Module
- Frontend or UI components that require ticker data display (e.g., Apple's ticker data).
- Instead of each widget calling the Polygon API, widgets query the centralized service for cached data.

## 4. Workflow and Data Flow
1. **Client Request:** Widgets or pages request ticker data from the Centralized API Service.
2. **Cache Check:** The service checks the caching layer:
   - If the data is valid (fresh within the TTL), it returns the cached data.
   - If the data is missing or expired, it fetches updated data from the Polygon.io API.
3. **Fetch & Cache Update:** When needed, a single API call is made to fetch the data, which is then cached for subsequent requests.
4. **Data Distribution:** All client widgets receive the same updated ticker data from the centralized service.
5. **Repeat:** The process repeats based on a configurable refresh interval (e.g., every minute).

## 5. Detailed Implementation Steps
### Step 1: Setting Up the Centralized Service
- Develop the backend service (using Node.js/Express, Python, etc.).
- Load configuration parameters (Polygon API key, refresh interval, cache settings) from the environment or config files.

### Step 2: Configuring API Authentication
- Pass the API key as a query string parameter as per Polygon.io documentation.
- Include required headers in each API request:
  - **X-Polygon-Edge-ID:** A unique user identifier.
  - **X-Polygon-Edge-IP-Address:** The IP address of the user making the request.
  - **X-Polygon-Edge-User-Agent:** The user agent string of the client.

### Step 3: Implementing the Caching System
- Choose a caching solution (e.g., Redis, in-memory cache).
- Define unique keys for each ticker (e.g., `ticker:AAPL`).
- Set a TTL value (e.g., 60 seconds) to balance freshness and API load.
- Write functions to:
  - Check if valid cached data exists for a given ticker.
  - Fetch fresh data from Polygon.io if the cache is missing or expired.
  - Update the cache with the new data.

### Step 4: Data Fetching and Distribution
- Develop a routine (such as a cron job or setInterval) to trigger API calls at regular intervals.
- On-demand fetching: If a widget requests data and the cache is stale, trigger an immediate update.
- Use asynchronous processing to handle API calls without blocking incoming requests.

### Step 5: Error Handling and Monitoring
- Implement error capture and logging mechanisms for API failures.
- Use fallbacks such as serving the last known good data if the API call fails.
- Consider retry strategies with exponential backoff for transient errors.
- Monitor API usage to ensure compliance with rate limits and usage analytics.

## 6. Scalability Considerations
- **Load Balancing:** Ensure that the centralized service can scale horizontally to handle a large number of requests.
- **Distributed Caching:** Consider using a distributed caching solution like a Redis cluster for high availability.
- **Efficient API Usage:** By centralizing and caching API calls, even millions of users can be served without overwhelming the Polygon API.

## 7. Best Practices
- **Separation of Concerns:** Isolate API call logic, caching mechanisms, and client data serving into separate modules or services.
- **Configuration Management:** Use environment-specific configurations for API keys, refresh intervals, and cache settings.
- **Testing:** Write unit and integration tests for each module to ensure system reliability and performance.
- **Documentation:** Keep this document and code comments up-to-date with system changes.

## 8. Example Code Outline (Pseudo-code)
Below is a high-level pseudo-code outline using Node.js/Express:

/*
// Centralized API Service
async function fetchTickerData(ticker) {
  // Check cache first
  let data = cache.get(`ticker:${ticker}`);
  if (data && isValid(data)) {
    return data;
  }
  
  // Construct API URL with authentication
  const url = `https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/day/2023-01-01/2023-04-14?apiKey=${process.env.POLY_API_KEY}`;

  // Define required headers
  const headers = {
    "X-Polygon-Edge-ID": generateEdgeId(),
    "X-Polygon-Edge-IP-Address": getClientIp(),
    "X-Polygon-Edge-User-Agent": getUserAgent()
  };

  // Fetch data from Polygon.io
  data = await http.get(url, { headers });

  // Update cache with TTL
  cache.set(`ticker:${ticker}`, data, ttl);
  return data;
}

// Express Route Handler
app.get('/ticker/:symbol', async (req, res) => {
  try {
    const ticker = req.params.symbol;
    const data = await fetchTickerData(ticker);
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: "Failed to retrieve data" });
  }
});
*/

## 9. Conclusion
By centralizing the process of fetching data from Polygon.io and caching the results, the system minimizes redundant API calls and reduces latency for users. This architecture supports scalability from a few users to millions by serving shared data across all widgets efficiently, ensuring compliance with API limits and authentication protocols.

---
This document serves as a comprehensive guide for developers to design, implement, and maintain a robust and scalable data aggregation system using Polygon.io API.
</file>

<file path="CODEBASE_GUIDE.md">
# Trading Dashboard Codebase Guide

## Project Structure Overview

### Core Directories

1. **/app**
   - Next.js app router structure
   - Key API routes and page components
   ```
   /app
   ├── api/                    # Backend API endpoints
   │   ├── polygon-stocks/     # Polygon.io stock endpoints
   │   ├── stock/             # Stock-related endpoints
   │   └── polygon-news/      # News API endpoints
   ├── layout.tsx             # Root layout
   └── page.tsx               # Main dashboard page
   ```

2. **/components**
   - Reusable UI components
   - Feature-specific components
   ```
   /components
   ├── live-ticker-bar/       # Real-time stock ticker display
   ├── market-overview/       # Market overview dashboard
   ├── market-status-header/  # Market status information
   └── live-market-data/      # Real-time market data display
   ```

3. **/lib**
   - Core business logic
   - Utility functions
   - Custom hooks
   ```
   /lib
   ├── api/                   # API service implementations
   │   ├── polygon-service.ts # Polygon.io service
   │   └── polygon-websocket.ts # WebSocket implementation
   ├── hooks/                 # Custom React hooks
   │   ├── use-market-data.ts  # Centralized market data store
   │   ├── use-market-indices.ts
   │   └── use-stock-websocket.ts
   └── utils/                 # Utility functions
       └── rate-limiter.ts
   ```

4. **/types**
   - TypeScript type definitions
   ```
   /types
   ├── polygon.ts             # Polygon.io related types
   └── api.ts                 # General API types
   ```

## Key Files and Their Purposes

### API Integration
- `lib/api/polygon-service.ts`
  - Central service for Polygon.io REST API calls
  - Implements caching and rate limiting
  - Used for historical and snapshot data

- `lib/api/polygon-websocket.ts`
  - WebSocket connection management
  - Real-time data streaming
  - Connection resilience

### State Management
- `lib/hooks/use-market-data.ts`
  - Centralized Zustand store for market data
  - Handles data caching and updates
  - Provides hooks for components to access data
  - Manages data freshness and updates

### Frontend Components
- `components/live-ticker-bar.tsx`
  - Real-time stock ticker display
  - Uses centralized market data store
  - Implements WebSocket updates
  - Handles data staleness

- `components/market-overview.tsx`
  - Market overview dashboard
  - Aggregates multiple data sources
  - Implements caching strategies

### Backend Routes
- `app/api/polygon-stocks/batch/route.ts`
  - Batch stock data retrieval
  - Implements rate limiting
  - Caches responses

- `app/api/stock/prev/[symbol]/route.ts`
  - Previous day's stock data
  - Symbol-specific caching
  - Error handling implementation

## Common Modification Patterns

### Adding a New Feature

1. **New UI Component**
   - Add to `/components`
   - Use existing hooks from `/lib/hooks`
   - Follow patterns in similar components

2. **New API Endpoint**
   - Add to `/app/api`
   - Use PolygonService from `/lib/api`
   - Implement caching and rate limiting

3. **New Data Type**
   - Add to `/types`
   - Update relevant service interfaces

### Modifying Existing Features

1. **UI Changes**
   - Locate component in `/components`
   - Check for shared components
   - Update related tests

2. **API Changes**
   - Check `/app/api` for endpoint
   - Review caching strategy
   - Update error handling

3. **Data Flow Changes**
   - Review affected hooks in `/lib/hooks`
   - Update WebSocket subscriptions if needed
   - Verify cache invalidation

## Common Implementation Scenarios

### 1. Adding Real-time Stock Data
```typescript
// 1. Access market data in component
import { useMarketData } from '@/lib/hooks/use-market-data'

const StockDisplay = ({ symbol }: { symbol: string }) => {
  const { data, isLoading } = useMarketData(symbol)
  return <PriceDisplay data={data[symbol]} />
}

// 2. Handle real-time updates
const LiveStockData = ({ symbol }: { symbol: string }) => {
  const { data, updateData } = useMarketData(symbol)
  useStockWebSocket({
    symbols: [symbol],
    onUpdate: (update) => updateData(symbol, update)
  })
  return <LiveDisplay data={data[symbol]} />
}
```

### 2. Batch Data Management
```typescript
// 1. Fetch multiple symbols
const MarketOverview = ({ symbols }: { symbols: string[] }) => {
  const { data, isLoading } = useMarketData(symbols)
  const { fetchData } = useMarketDataFetcher(symbols)

  useEffect(() => {
    fetchData()
    const interval = setInterval(fetchData, 30000)
    return () => clearInterval(interval)
  }, [symbols])

  return <Overview data={data} />
}
```

### 3. Enhanced Error Handling
```typescript
// 1. Update error boundaries in components
// 2. Enhance error handling in services
// 3. Implement fallback UI states
```

## Testing Considerations

### Unit Tests
- Component tests in `__tests__` directories
- Service tests alongside implementations
- Mock WebSocket connections

### Integration Tests
- API route testing
- WebSocket integration
- Cache behavior verification

## Performance Optimization

### Caching Strategy
- REST API responses cached in PolygonService
- WebSocket data managed through subscriptions
- Browser caching for static assets

### Rate Limiting
- Implemented in PolygonService
- Batch requests when possible
- Queue management for concurrent requests

## Troubleshooting Guide

### WebSocket Issues
1. Check connection in polygon-websocket.ts
2. Verify subscription patterns
3. Review error handling

### API Issues
1. Check rate limiting in PolygonService
2. Verify cache implementation
3. Review error handling patterns

### UI Issues
1. Check component error boundaries
2. Verify data flow through hooks
3. Review loading states

## Documentation Updates

When modifying the codebase:
1. Update relevant README files
2. Document new patterns
3. Update type definitions
4. Maintain API documentation

## Best Practices

1. **Code Organization**
   - Follow established directory structure
   - Maintain separation of concerns
   - Use appropriate file naming conventions

2. **Data Management**
   - Use centralized services
   - Implement proper caching
   - Handle errors gracefully

3. **Performance**
   - Optimize bundle size
   - Implement efficient caching
   - Use proper memoization

4. **Security**
   - Keep API keys secure
   - Validate input data
   - Implement proper authentication

Remember: This guide should be used in conjunction with API_Architecture.md, Integration_Guide.md, and POLYGON_INTEGRATION.md for a complete understanding of the system.
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        - POLYGON_API_KEY=${POLYGON_API_KEY}
        - JWT_SECRET=${JWT_SECRET}
        - REDIS_URL=redis://redis:6379
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - POLYGON_API_KEY=${POLYGON_API_KEY}
      - JWT_SECRET=${JWT_SECRET}
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
networks:
  app-network:
    driver: bridge
volumes:
  redis-data:
    driver: local
</file>

<file path="Dockerfile">
# Use Node.js LTS version
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Environment variables must be present at build time
ARG POLYGON_API_KEY
ARG JWT_SECRET
ARG REDIS_URL
ENV POLYGON_API_KEY=$POLYGON_API_KEY
ENV JWT_SECRET=$JWT_SECRET
ENV REDIS_URL=$REDIS_URL
ENV NEXT_TELEMETRY_DISABLED 1

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

# Create a non-root user
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy built application
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Switch to non-root user
USER nextjs

# Expose port
EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

# Start the application
CMD ["node", "server.js"]
</file>

<file path="Integration_Guide.md">
# Integration Guide: Connecting Frontend UI and Backend Components

## 1. Overview
This guide serves as the central reference for connecting the frontend UI with backend components in our application. It provides detailed instructions and best practices to ensure that as new features are added, edited, or created, the integration is seamless, robust, and maintains the overall stability of the application.

## 2. Objectives
- **Consistency:** Ensure that all components, both frontend and backend, communicate using consistent interfaces and standardized data contracts.
- **Seamless Integration:** Provide guidelines to integrate UI elements with backend functionalities without duplicating API calls or introducing errors.
- **Scalability:** Maintain the ability for the system to scale effectively, as described in the API Architecture, by using centralized services and caching mechanisms.
- **Maintainability:** Create clear documentation and processes that aid in the long-term maintenance and upgrade of the system.

## 3. Core Integration Principles
### 3.1 Clear Separation of Concerns
- **Frontend:** Focus on rendering data, user interactions, and calling backend endpoints for data retrieval. UI components should not directly call external APIs.
- **Backend:** Centralize all API communications, data processing, caching, and business logic. New features should interact with these services through well-defined endpoints.

### 3.2 Use of Centralized Market Data Store
- **Reference the API Architecture:** Follow the guidelines in `API_Architecture.md` for implementing backend services and use the centralized market data store for all market data needs.
- **Avoid Redundant State:** Ensure that components use the shared market data store instead of maintaining their own state.
- **Data Flow Pattern:**
```typescript
// ❌ Don't: Maintain separate state in each component
const BadComponent = () => {
  const [data, setData] = useState<MarketData>(null)
  useEffect(() => {
    fetch('/api/market-data').then(setData)
  }, [])
}

// ✅ Do: Use the centralized market data store
const GoodComponent = () => {
  const { data, isLoading } = useMarketData('AAPL')
  // Data is automatically managed and shared
}
```

### 3.3 Standardized Data Contracts
```typescript
// Market Data Contract
interface MarketData {
  symbol: string
  price: number
  change: number
  changePercent: number
  volume: number
  lastUpdated: number
}

// Store Contract
interface MarketDataState {
  data: Record<string, MarketData>
  isLoading: boolean
  error: string | null
  updateData: (symbol: string, data: MarketData) => void
  updateBatchData: (updates: Record<string, MarketData>) => void
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
}

// Hook Usage Contract
interface UseMarketDataResult {
  data: Record<string, MarketData>
  isLoading: boolean
  error: string | null
  needsUpdate: boolean
  updateData: (symbol: string, data: MarketData) => void
  updateBatchData: (updates: Record<string, MarketData>) => void
}
```

### 3.4 Error Handling and Fallback Mechanisms
- Follow error handling guidelines as outlined in the API Architecture and Error Handling sections. This includes logging errors, using fallback data when appropriate, and implementing retry mechanisms.
- Frontend components should be designed to gracefully handle backend errors, such as displaying user-friendly messages or triggering alternative flows.

## 4. Development and Integration Workflow
### 4.1 New Feature Integration
- **Planning:** Before introducing a new feature, refer to this integration guide and the API Architecture document to plan how the feature will connect with existing components.
- **Design:** Create detailed design sketches that include both UI changes and backend changes. Ensure data flows are clearly documented.
- **Implementation:** Start by developing backend endpoints that adhere to standardized data contracts. Next, update frontend components to request and display data from these endpoints.
- **Testing:** Implement both unit and integration tests to ensure that the modifications work as expected without breaking existing functionalities.

### 4.2 Continuous Integration and Deployment
- Set up a CI/CD pipeline that runs integration tests, ensuring that every change does not break the connection between frontend and backend components.
- Regularly update documentation (this guide and related documents) with any changes or new endpoint details.

## 5. Maintenance and Updates
- **Documentation:** Always update this guide when new integration patterns or significant changes in the architecture occur.
- **Monitoring:** Deploy logging and monitoring tools to track the performance and integration of frontend and backend systems. Use the logs to diagnose issues quickly and maintain system reliability.
- **Version Control:** Use semantic versioning for API endpoints and integration modifications. Provide deprecation notices well in advance if major changes are required.

## 6. References and Complementary Guides
- **API_Architecture.md:** Detailed guide on centralized data fetching, caching, and data distribution from the Polygon.io API.
- **Configuration_Guide.md (Optional):** Document detailing environment variables and configuration settings across different environments.
- **API_Deployment_Guide.md (Optional):** Instructions on deploying and scaling the backend services effectively.
- **Error_Handling_Guide.md (Optional):** Further details on error logging, fallback mechanisms, and retry strategies.

## 7. Conclusion
This Integration Guide is designed to be a living document. It should be consulted for every new UI or backend feature development to ensure that integration remains efficient, controlled, and scalable. Regular updates to this document will help all teams stay aligned and maintain a robust system architecture over time.

## 8. Integration Checklist
Before implementing any new feature or modification, ensure the following:

### 8.1 Frontend Integration
- [ ] Component uses centralized market data store via `useMarketData` hook
- [ ] Real-time updates are handled through the store
- [ ] Data staleness is properly managed
- [ ] Error states are properly handled and displayed
- [ ] Loading states are implemented
- [ ] Component subscribes to relevant store updates

### 8.2 Backend Integration
- [ ] Endpoint follows RESTful conventions
- [ ] Response format matches defined data contracts
- [ ] Caching strategy is implemented
- [ ] Rate limiting is considered
- [ ] Error handling follows standard format
- [ ] Logging is implemented
- [ ] Authentication/Authorization is properly handled

### 8.3 Testing Requirements
- [ ] Unit tests for new components/functions
- [ ] Integration tests for API endpoints
- [ ] Error handling tests
- [ ] Cache behavior tests
- [ ] Load/Performance tests for critical paths

### 8.4 Documentation
- [ ] API endpoints documented
- [ ] Data contracts updated
- [ ] README updated if needed
- [ ] Changelog entry added
- [ ] Breaking changes noted

## 9. Example Implementation Patterns

### 9.1 Frontend Data Fetching
```typescript
// Custom hook example
const useStockData = (symbol: string) => {
  const [data, setData] = useState<TickerData | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(`/api/stock/ticker/${symbol}`);
        const json = await response.json();
        if (!json.success) throw new Error(json.error.message);
        setData(json.data);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [symbol]);

  return { data, error, loading };
};
```

### 9.2 Backend Caching Implementation
```typescript
// Example of implementing caching middleware
const cacheMiddleware = async (req: Request, res: Response, next: NextFunction) => {
  const cacheKey = `ticker:${req.params.symbol}`;
  const cachedData = await cache.get(cacheKey);
  
  if (cachedData) {
    return res.json({
      success: true,
      data: cachedData
    });
  }
  
  next();
};
```

## 10. Conclusion
This Integration Guide is designed to be a living document. It should be consulted for every new UI or backend feature development to ensure that integration remains efficient, controlled, and scalable. Regular updates to this document will help all teams stay aligned and maintain a robust system architecture over time.

## 11. Version History
- v1.0.0: Initial guide creation
- v1.1.0: Added Integration Checklist and Example Implementation Patterns
</file>

<file path="jest.config.ts">
import type { Config } from '@jest/types';
const config: Config.InitialOptions = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  collectCoverage: true,
  collectCoverageFrom: [
    'lib/**/*.{ts,tsx}',
    '!lib/**/*.d.ts',
    '!lib/**/index.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  verbose: true,
  testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.test.json',
    },
  },
};
export default config;
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Trading Dashboard

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="MODIFICATION_PATTERNS.md">
# Trading Dashboard Modification Patterns

## UI Modifications

### 1. Component Styling Updates
```typescript
// Location: /components/{component-name}
// Example: Updating Market Overview styling

// 1. Locate the component
// components/market-overview.tsx
// components/market-overview.module.css

// 2. Identify shared styles
// Check for common styles in:
// - styles/common.css
// - components/shared/styles/

// 3. Update pattern:
const MarketOverview = () => {
  return (
    <div className={styles.container}>
      {/* Update className or style props */}
      <div className={clsx(styles.card, styles.elevated)}>
        {/* Component content */}
      </div>
    </div>
  );
};
```

### 2. Layout Improvements
```typescript
// 1. Check responsive behavior
// - Update breakpoints in tailwind.config.js
// - Modify responsive classes
// - Test across device sizes

// 2. Component structure
const ImprovedLayout = () => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      <MarketSection />
      <NewsSection />
      <TradingSection />
    </div>
  );
};

// 3. Performance optimization
const OptimizedComponent = memo(({ data }) => {
  // Implement useMemo for expensive calculations
  const processedData = useMemo(() => processData(data), [data]);
  
  return <ComponentContent data={processedData} />;
});
```

## Feature Enhancements

### 1. Adding New Functionality
```typescript
// 1. Extend existing components
// components/market-overview.tsx
interface EnhancedProps extends BaseProps {
  newFeature: boolean;
  additionalData?: MarketData;
}

// 2. Add new hooks
// lib/hooks/use-enhanced-market-data.ts
const useEnhancedMarketData = (symbol: string) => {
  const baseData = useMarketData(symbol);
  const additionalData = useAdditionalData(symbol);
  
  return useMemo(() => ({
    ...baseData,
    ...additionalData,
    enhanced: combineData(baseData, additionalData)
  }), [baseData, additionalData]);
};

// 3. Update types
// types/market-data.ts
interface EnhancedMarketData extends MarketData {
  newFeatures: NewFeatureType;
  additionalMetrics: Metrics;
}
```

### 2. Performance Improvements
```typescript
// 1. Implement data memoization
const MemoizedComponent = () => {
  const memoizedValue = useMemo(() => 
    expensiveCalculation(props.data),
    [props.data]
  );

  // 2. Add suspense boundaries
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <DataComponent data={memoizedValue} />
    </Suspense>
  );
};

// 3. Optimize re-renders
const OptimizedList = memo(({ items }) => {
  return items.map(item => (
    <ListItem 
      key={item.id}
      item={item}
      onUpdate={useCallback(
        () => handleUpdate(item.id),
        [item.id]
      )}
    />
  ));
});
```

## Data Flow Improvements

### 1. Caching Enhancements
```typescript
// 1. Implement advanced caching
// lib/api/enhanced-cache.ts
class EnhancedCache {
  private cache: Map<string, CacheEntry>;
  
  set(key: string, value: any, ttl: number) {
    this.cache.set(key, {
      value,
      expiry: Date.now() + ttl,
      lastAccessed: Date.now()
    });
  }
  
  get(key: string) {
    const entry = this.cache.get(key);
    if (this.isValid(entry)) {
      entry.lastAccessed = Date.now();
      return entry.value;
    }
    return null;
  }
}

// 2. Implement cache invalidation
const invalidateRelatedCaches = (symbol: string) => {
  const patterns = [
    `ticker:${symbol}`,
    `market:${symbol}`,
    `news:${symbol}`
  ];
  patterns.forEach(pattern => cache.invalidatePattern(pattern));
};
```

### 2. WebSocket Optimization
```typescript
// 1. Implement smart subscriptions
class SmartWebSocketManager extends BaseWebSocketManager {
  private activeSubscriptions: Set<string>;
  
  subscribe(symbol: string) {
    if (!this.activeSubscriptions.has(symbol)) {
      this.activeSubscriptions.add(symbol);
      this.batchSubscribe();
    }
  }
  
  private batchSubscribe() {
    // Batch multiple subscriptions into one message
    const batch = Array.from(this.activeSubscriptions);
    this.ws.send(JSON.stringify({
      action: "subscribe",
      params: batch.join(",")
    }));
  }
}

// 2. Implement reconnection with state recovery
class ResilientWebSocket {
  private messageQueue: Message[] = [];
  
  reconnect() {
    this.connect().then(() => {
      this.replayMessages();
      this.resubscribeAll();
    });
  }
}
```

## Error Handling Improvements

### 1. Enhanced Error Boundaries
```typescript
// 1. Create specialized error boundaries
class MarketDataErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <ErrorDisplay 
          error={this.state.error}
          retry={this.resetError}
        />
      );
    }
    return this.props.children;
  }
}

// 2. Implement fallback states
const FallbackComponent = ({ error, retry }) => {
  const errorType = categorizeError(error);
  
  switch (errorType) {
    case 'network':
      return <NetworkErrorDisplay retry={retry} />;
    case 'data':
      return <DataErrorDisplay retry={retry} />;
    default:
      return <GenericErrorDisplay retry={retry} />;
  }
};
```

### 2. API Error Handling
```typescript
// 1. Implement retry logic
const fetchWithRetry = async (url: string, options: Options) => {
  const maxRetries = 3;
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetch(url, options);
    } catch (error) {
      lastError = error;
      if (!shouldRetry(error)) throw error;
      await delay(Math.pow(2, i) * 1000);
    }
  }
  throw lastError;
};

// 2. Implement graceful degradation
const fetchMarketData = async (symbol: string) => {
  try {
    return await fetchPrimaryData(symbol);
  } catch (error) {
    console.error('Primary data source failed:', error);
    try {
      return await fetchFallbackData(symbol);
    } catch (fallbackError) {
      return getLastKnownGoodData(symbol);
    }
  }
};
```

## Testing Improvements

### 1. Enhanced Test Coverage
```typescript
// 1. Component testing
describe('MarketOverview', () => {
  it('handles data updates correctly', () => {
    const { rerender } = render(<MarketOverview symbol="AAPL" />);
    
    // Test initial render
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
    
    // Test data loaded state
    rerender(<MarketOverview symbol="AAPL" data={mockData} />);
    expect(screen.getByText(/AAPL/)).toBeInTheDocument();
    
    // Test error state
    rerender(<MarketOverview symbol="AAPL" error={new Error()} />);
    expect(screen.getByText(/error/i)).toBeInTheDocument();
  });
});

// 2. Integration testing
describe('MarketDataFlow', () => {
  it('integrates with WebSocket correctly', async () => {
    const mockWebSocket = new MockWebSocket();
    render(<MarketDataComponent ws={mockWebSocket} />);
    
    // Test subscription
    expect(mockWebSocket.subscriptions).toContain('AAPL');
    
    // Test data flow
    mockWebSocket.emit('message', mockData);
    await waitFor(() => {
      expect(screen.getByText(mockData.price)).toBeInTheDocument();
    });
  });
});
```

## Documentation Improvements

### 1. Code Documentation
```typescript
/**
 * MarketDataProvider manages the real-time market data flow
 * @param {string} symbol - The stock symbol to track
 * @param {WebSocketOptions} options - Configuration options
 * @returns {MarketData} Real-time market data
 * 
 * @example
 * ```tsx
 * const MarketComponent = () => {
 *   const data = useMarketData('AAPL');
 *   return <Display data={data} />;
 * };
 * ```
 */
```

### 2. API Documentation
```typescript
/**
 * @api {get} /api/market/:symbol Get Market Data
 * @apiName GetMarketData
 * @apiGroup Market
 * 
 * @apiParam {String} symbol Stock symbol
 * 
 * @apiSuccess {Object} data Market data
 * @apiSuccess {Number} data.price Current price
 * @apiSuccess {Number} data.change Price change
 * 
 * @apiError {Object} error Error information
 */
```

## State Management Patterns

### 1. Centralized Market Data Store

The market data store is the single source of truth for all market data:

```typescript
// ✅ Do: Use the centralized store
const { data, isLoading } = useMarketData('AAPL')

// ❌ Don't: Create local state
const [data, setData] = useState(null)
```

### 2. Data Updates

#### Single Symbol Updates
```typescript
// ✅ Do: Update through the store
const { updateData } = useMarketData()
updateData('AAPL', newData)

// ❌ Don't: Update state directly
setLocalState(newData)
```

#### Batch Updates
```typescript
// ✅ Do: Use batch updates
const { updateBatchData } = useMarketData()
updateBatchData({
  AAPL: newData1,
  MSFT: newData2
})

// ❌ Don't: Update multiple symbols individually
symbols.forEach(sym => updateData(sym, newData))
```

### 3. Real-time Updates

```typescript
// ✅ Do: Use WebSocket through store
const { data } = useMarketData(['AAPL', 'MSFT'])
useStockWebSocket({
  symbols: ['AAPL', 'MSFT'],
  onUpdate: (update) => updateData(update.symbol, update)
})

// ❌ Don't: Manage WebSocket separately
const ws = new WebSocket('wss://...')
```

## Component Patterns

### 1. Data Access

```typescript
// ✅ Do: Access data through hooks
function StockDisplay({ symbol }: { symbol: string }) {
  const { data, isLoading, error } = useMarketData(symbol)
  
  if (isLoading) return <LoadingSpinner />
  if (error) return <ErrorDisplay error={error} />
  
  return <PriceDisplay price={data[symbol].price} />
}

// ❌ Don't: Fetch data directly
function BadStockDisplay({ symbol }: { symbol: string }) {
  const [data, setData] = useState(null)
  useEffect(() => {
    fetch(`/api/stocks/${symbol}`).then(setData)
  }, [symbol])
}
```

### 2. Data Freshness

```typescript
// ✅ Do: Use the store's freshness checks
function StockList({ symbols }: { symbols: string[] }) {
  const { data, fetchData } = useMarketDataFetcher(symbols)
  
  useEffect(() => {
    fetchData()
    const interval = setInterval(fetchData, 30000)
    return () => clearInterval(interval)
  }, [symbols])
}

// ❌ Don't: Implement separate freshness logic
function BadStockList({ symbols }: { symbols: string[] }) {
  const [lastUpdate, setLastUpdate] = useState(Date.now())
  // ... custom freshness logic
}
```

### 3. Error Handling

```typescript
// ✅ Do: Use store's error handling
function StockWidget({ symbol }: { symbol: string }) {
  const { data, error } = useMarketData(symbol)
  
  if (error?.includes('RATE_LIMIT')) {
    return <RetryButton onRetry={() => fetchData()} />
  }
}

// ❌ Don't: Implement separate error handling
function BadStockWidget({ symbol }: { symbol: string }) {
  const [error, setError] = useState(null)
  // ... custom error handling
}
```

## Data Flow Patterns

### 1. Component Hierarchy

```typescript
// ✅ Do: Share data through store
function ParentComponent() {
  const symbols = ['AAPL', 'MSFT']
  return (
    <>
      <PriceDisplay symbols={symbols} />
      <VolumeDisplay symbols={symbols} />
    </>
  )
}

// Both components use the same store data
function PriceDisplay({ symbols }: { symbols: string[] }) {
  const { data } = useMarketData(symbols)
  return // ... render prices
}

function VolumeDisplay({ symbols }: { symbols: string[] }) {
  const { data } = useMarketData(symbols)
  return // ... render volumes
}

// ❌ Don't: Pass data through props
function BadParentComponent() {
  const [data, setData] = useState(null)
  return (
    <>
      <PriceDisplay data={data} />
      <VolumeDisplay data={data} />
    </>
  )
}
```

### 2. Data Synchronization

```typescript
// ✅ Do: Let the store handle sync
function SynchronizedDisplays() {
  const symbols = ['AAPL', 'MSFT']
  const { data } = useMarketData(symbols)
  
  return (
    <div>
      <Chart data={data} />
      <Table data={data} />
    </div>
  )
}

// ❌ Don't: Sync manually
function BadSynchronizedDisplays() {
  const [chartData, setChartData] = useState(null)
  const [tableData, setTableData] = useState(null)
  // ... manual sync logic
}
```

## Testing Patterns

### 1. Mocking Store Data

```typescript
// ✅ Do: Use store's mock capabilities
import { mockMarketData } from '@/lib/hooks/use-market-data'

describe('StockDisplay', () => {
  beforeEach(() => {
    mockMarketData({
      AAPL: { price: 150.00, volume: 1000000 }
    })
  })
  
  it('displays stock price', () => {
    render(<StockDisplay symbol="AAPL" />)
    expect(screen.getByText('$150.00')).toBeInTheDocument()
  })
})

// ❌ Don't: Mock fetch/WebSocket directly
jest.mock('next/fetch', () => ({
  fetch: jest.fn()
}))
```

### 2. Testing Updates

```typescript
// ✅ Do: Test through store
test('updates price on WebSocket message', async () => {
  const { updateData } = useMarketData()
  render(<StockDisplay symbol="AAPL" />)
  
  act(() => {
    updateData('AAPL', { price: 151.00 })
  })
  
  expect(screen.getByText('$151.00')).toBeInTheDocument()
})

// ❌ Don't: Test WebSocket directly
test('bad update test', () => {
  const ws = new WebSocket('wss://...')
  ws.send(JSON.stringify({ price: 151.00 }))
})
```

## Migration Patterns

### 1. Gradual Migration

```typescript
// Step 1: Add store alongside existing code
function MigratingComponent() {
  // Old code
  const [localData, setLocalData] = useState(null)
  
  // New code
  const { data } = useMarketData('AAPL')
  
  // Use new data, fallback to old
  const displayData = data?.AAPL || localData
}

// Step 2: Remove old code
function MigratedComponent() {
  const { data } = useMarketData('AAPL')
  return <Display data={data.AAPL} />
}
```

### 2. Feature Flags

```typescript
// ✅ Do: Use feature flags for migration
function FeatureFlaggedComponent() {
  if (USE_MARKET_DATA_STORE) {
    return <NewImplementation />
  }
  return <OldImplementation />
}

// Step 1: Test in development
const USE_MARKET_DATA_STORE = process.env.NODE_ENV === 'development'

// Step 2: Gradual rollout
const USE_MARKET_DATA_STORE = Math.random() < 0.1 // 10% of users

// Step 3: Full migration
const USE_MARKET_DATA_STORE = true
```

Remember: These patterns should be used in conjunction with the existing architecture and integration guides to maintain consistency across the application.
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  webpack: (config) => {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
      net: false,
      tls: false,
    };
    return config;
  },
}
module.exports = nextConfig
</file>

<file path="next.config.mjs">
let userConfig = undefined
try {
  userConfig = await import('./v0-user-next.config')
} catch (e) {
  // ignore error
}

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  images: {
    unoptimized: true,
  },
  experimental: {
    webpackBuildWorker: true,
    parallelServerBuildTraces: true,
    parallelServerCompiles: true,
  },
}

mergeConfig(nextConfig, userConfig)

function mergeConfig(nextConfig, userConfig) {
  if (!userConfig) {
    return
  }

  for (const key in userConfig) {
    if (
      typeof nextConfig[key] === 'object' &&
      !Array.isArray(nextConfig[key])
    ) {
      nextConfig[key] = {
        ...nextConfig[key],
        ...userConfig[key],
      }
    } else {
      nextConfig[key] = userConfig[key]
    }
  }
}

export default nextConfig
</file>

<file path="package.json">
{
  "name": "trading-dashboard",
  "version": "1.0.0",
  "description": "A real-time trading dashboard with advanced visualization and analytics",
  "main": "index.js",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "axios": "^1.6.0",
    "class-variance-authority": "^0.7.0",
    "date-fns": "^2.30.0",
    "eventemitter3": "^5.0.0",
    "ioredis": "^5.3.0",
    "jose": "^5.1.0",
    "limiter": "^2.1.0",
    "nanoid": "^5.0.0",
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "recharts": "^2.10.0",
    "winston": "^3.11.0",
    "zod": "^3.22.0",
    "zustand": "^4.4.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.1.0",
    "@testing-library/react": "^14.1.0",
    "@testing-library/user-event": "^14.5.0",
    "@types/jest": "^29.5.0",
    "@types/testing-library__jest-dom": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.11.0",
    "@typescript-eslint/parser": "^6.11.0",
    "eslint": "^8.53.0",
    "eslint-config-next": "^14.0.0",
    "eslint-plugin-jest": "^27.6.0",
    "eslint-plugin-react": "^7.33.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.2.0",
    "cursor-tools": "latest"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "license": "MIT"
}
</file>

<file path="POLYGON_INTEGRATION.md">
# Polygon.io Integration Guide

## Overview
This guide details how to integrate Polygon.io's REST and WebSocket APIs with our trading dashboard's centralized market data store.

## Architecture
All Polygon.io data flows through our centralized market data store:

```
[Polygon REST API] ─┐
                    ├─> [Market Data Store] ─> [UI Components]
[Polygon WebSocket] ┘
```

## Data Flow
1. Components request data via `useMarketData` hook
2. Store checks for fresh data
3. If stale/missing, fetches from Polygon
4. Real-time updates flow through WebSocket to store

## Implementation

### 1. REST API Integration

```typescript
// In lib/hooks/use-market-data.ts
const fetchPolygonData = async (symbol: string): Promise<MarketData> => {
  const response = await fetch(`/api/polygon/v2/aggs/ticker/${symbol}/prev`)
  if (!response.ok) throw new Error('Failed to fetch from Polygon')
  return response.json()
}

// Usage in components via the store
const { data, isLoading } = useMarketData('AAPL')
```

### 2. WebSocket Integration

```typescript
// In lib/hooks/use-stock-websocket.ts
export const useStockWebSocket = (config: WebSocketConfig) => {
  const { updateData } = useMarketData()
  
  useEffect(() => {
    const ws = new WebSocket('wss://socket.polygon.io/stocks')
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      updateData(data.symbol, data)
    }
    
    return () => ws.close()
  }, [])
}
```

### 3. Error Handling

```typescript
// In lib/hooks/use-market-data.ts
const { data, error, isLoading } = useMarketData('AAPL')

if (error?.includes('POLYGON_API_KEY')) {
  // Handle authentication errors
}

if (error?.includes('RATE_LIMIT')) {
  // Handle rate limiting
}
```

## API Reference

### REST Endpoints
All REST endpoints are accessed through the market data store:

```typescript
// ✅ Do: Use the store
const { data } = useMarketData('AAPL')

// ❌ Don't: Call Polygon directly
const response = await fetch('/api/polygon/...')
```

### WebSocket Channels
WebSocket subscriptions are managed through the store:

```typescript
// ✅ Do: Use the store's WebSocket integration
const { data } = useMarketData(['AAPL', 'MSFT'])
useStockWebSocket({ symbols: ['AAPL', 'MSFT'] })

// ❌ Don't: Manage WebSocket connections separately
const ws = new WebSocket('wss://socket.polygon.io/stocks')
```

## Rate Limiting
The market data store handles rate limiting automatically:
- Batches requests when possible
- Implements exponential backoff
- Caches responses appropriately

## Authentication
API keys are managed securely through environment variables:
```env
POLYGON_API_KEY=your_api_key_here
```

Never expose API keys in client-side code. All requests should go through the market data store.

## Testing
Test components using the market data store's mock capabilities:

```typescript
// In your test file
import { mockMarketData } from '@/lib/hooks/use-market-data'

beforeEach(() => {
  mockMarketData({
    AAPL: { price: 150.00, volume: 1000000 }
  })
})
```

## Troubleshooting

### Common Issues

1. Stale Data
```typescript
// Solution: Force a refresh
const { fetchData } = useMarketDataFetcher('AAPL')
await fetchData()
```

2. WebSocket Disconnects
```typescript
// Solution: The store handles reconnection automatically
const { data } = useMarketData('AAPL')
useStockWebSocket({ symbols: ['AAPL'] })
```

3. Rate Limiting
```typescript
// Solution: Use batch updates
const { updateBatchData } = useMarketData()
updateBatchData({
  AAPL: newData,
  MSFT: newData
})
```

## Best Practices

1. Always use the market data store
2. Implement proper error handling
3. Use batch operations when possible
4. Monitor data freshness
5. Test with mock data

## Migration Guide

### Migrating from Direct API Calls

Before:
```typescript
const [data, setData] = useState(null)
useEffect(() => {
  fetch('/api/polygon/...').then(setData)
}, [])
```

After:
```typescript
const { data, isLoading } = useMarketData('AAPL')
```

### Migrating WebSocket Usage

Before:
```typescript
const ws = new WebSocket('wss://socket.polygon.io/stocks')
ws.onmessage = (event) => {
  // Handle updates
}
```

After:
```typescript
const { data } = useMarketData(['AAPL', 'MSFT'])
useStockWebSocket({
  symbols: ['AAPL', 'MSFT']
})
```
</file>

<file path="polygonStock.md">
Stocks API Documentation

The Polygon.io Stocks API provides REST endpoints that let you query the latest market data from all US stock exchanges. You can also find data on company financials, stock market holidays, corporate actions, and more.
Documentation
Authentication
Pass your API key in the query string like follows:
https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2023-01-09/2023-01-09?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy
Alternatively, you can add an Authorization header to the request with your API Key as the token in the following form:
Authorization: Bearer p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy
Usage
Many of Polygon.io's REST endpoints allow you to extend query parameters with inequalities like date.lt=2023-01-01 (less than) and date.gte=2023-01-01 (greater than or equal to) to search ranges of values. You can also use the field name without any extension to query for exact equality. Fields that support extensions will have an "Additional filter parameters" dropdown beneath them in the docs that detail the supported extensions for that parameter.
Response Types
By default, all endpoints return a JSON response. Users with Stocks Starter plan and above can request a CSV response by including 'Accept': 'text/csv' as a request parameter.
Your Plan
Stocks Starter

Unlimited API Calls

15-minute Delayed Data

5 Years Historical Data
Manage Subscription
Client Libraries
Python Logo
Python
client-python
Go Logo
Go
client-go
Javascript Logo
Javascript
client-js
PHP Logo
PHP
client-php
Kotlin Logo
Kotlin
client-jvm
Aggregates (Bars)
GET
/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
Get aggregate bars for a stock over a given date range in custom time window sizes.

For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

multiplier
*

The size of the timespan multiplier.

timespan
*

day

The size of the time window.

from
*

The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.

to
*

The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

sort

asc

Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).

limit

Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on Aggregate Data API Improvements.

https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2023-01-09/2023-02-10?adjusted=true&sort=asc&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
ticker*string
The exchange symbol that this item is traded under.
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
next_urlstring
If present, this value can be used to fetch the next page of data.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "next_url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/1578114000000/2020-01-10?cursor=bGltaXQ9MiZzb3J0PWFzYw",
  "queryCount": 2,
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "c": 75.0875,
      "h": 75.15,
      "l": 73.7975,
      "n": 1,
      "o": 74.06,
      "t": 1577941200000,
      "v": 135647456,
      "vw": 74.6099
    },
    {
      "c": 74.3575,
      "h": 75.145,
      "l": 74.125,
      "n": 1,
      "o": 74.2875,
      "t": 1578027600000,
      "v": 146535512,
      "vw": 74.7026
    }
  ],
  "resultsCount": 2,
  "status": "OK",
  "ticker": "AAPL"
}
Grouped Daily (Bars)
GET
/v2/aggs/grouped/locale/us/market/stocks/{date}
Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
date
*

The beginning date for the aggregate window.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/aggs/grouped/locale/us/market/stocks/2023-01-09?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
T*string
The exchange symbol that this item is traded under.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the end of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "queryCount": 3,
  "results": [
    {
      "T": "KIMpL",
      "c": 25.9102,
      "h": 26.25,
      "l": 25.91,
      "n": 74,
      "o": 26.07,
      "t": 1602705600000,
      "v": 4369,
      "vw": 26.0407
    },
    {
      "T": "TANH",
      "c": 23.4,
      "h": 24.763,
      "l": 22.65,
      "n": 1096,
      "o": 24.5,
      "t": 1602705600000,
      "v": 25933.6,
      "vw": 23.493
    },
    {
      "T": "VSAT",
      "c": 34.24,
      "h": 35.47,
      "l": 34.21,
      "n": 4966,
      "o": 34.9,
      "t": 1602705600000,
      "v": 312583,
      "vw": 34.4736
    }
  ],
  "resultsCount": 3,
  "status": "OK"
}
Daily Open/Close
GET
/v1/open-close/{stocksTicker}/{date}
Get the open, close and afterhours prices of a stock symbol on a certain date.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

date
*


The date of the requested open/close in the format YYYY-MM-DD.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

https://api.polygon.io/v1/open-close/AAPL/2023-01-09?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
afterHoursnumber
The close price of the ticker symbol in after hours trading.
close*number
The close price for the symbol in the given time period.
from*string
The requested date.
high*number
The highest price for the symbol in the given time period.
low*number
The lowest price for the symbol in the given time period.
open*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
preMarketinteger
The open price of the ticker symbol in pre-market trading.
status*string
The status of this request's response.
symbol*string
The exchange symbol that this item is traded under.
volume*number
The trading volume of the symbol in the given time period.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "afterHours": 322.1,
  "close": 325.12,
  "from": "2023-01-09",
  "high": 326.2,
  "low": 322.3,
  "open": 324.66,
  "preMarket": 324.5,
  "status": "OK",
  "symbol": "AAPL",
  "volume": 26122646
}
Previous Close
GET
/v2/aggs/ticker/{stocksTicker}/prev
Get the previous day's open, high, low, and close (OHLC) for the specified stock ticker.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

https://api.polygon.io/v2/aggs/ticker/AAPL/prev?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
ticker*string
The exchange symbol that this item is traded under.
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "queryCount": 1,
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "T": "AAPL",
      "c": 115.97,
      "h": 117.59,
      "l": 114.13,
      "o": 115.55,
      "t": 1605042000000,
      "v": 131704427,
      "vw": 116.3058
    }
  ],
  "resultsCount": 1,
  "status": "OK",
  "ticker": "AAPL"
}
Trades
GET
/v3/trades/{stockTicker}
Get trades for a ticker symbol in a given time range.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
stockTicker
*

The ticker symbol to get trades for.

timestamp

Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 1000 and max is 50000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/trades/AAPL?limit=1000&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
resultsarray
conditionsarray [integer]
A list of condition codes.
correctioninteger
The trade correction indicator.
exchange*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
id*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
participant_timestamp*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
price*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
sequence_number*integer
The sequence number represents the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
sip_timestamp*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
size*number
The size of a trade (also known as volume).
tapeinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
trf_idinteger
The ID for the Trade Reporting Facility where the trade took place.
trf_timestampinteger
The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/trades/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": [
    {
      "conditions": [
        12,
        41
      ],
      "exchange": 11,
      "id": "1",
      "participant_timestamp": 1517562000015577000,
      "price": 171.55,
      "sequence_number": 1063,
      "sip_timestamp": 1517562000016036600,
      "size": 100,
      "tape": 3
    },
    {
      "conditions": [
        12,
        41
      ],
      "exchange": 11,
      "id": "2",
      "participant_timestamp": 1517562000015577600,
      "price": 171.55,
      "sequence_number": 1064,
      "sip_timestamp": 1517562000016038100,
      "size": 100,
      "tape": 3
    }
  ],
  "status": "OK"
}
Last Trade
GET
/v2/last/trade/{stocksTicker}
Get the most recent trade for a given stock.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
stocksTicker
*

The ticker symbol of the stock/equity.

https://api.polygon.io/v2/last/trade/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
request_id*string
A request id assigned by the server.
resultsobject
T*string
The exchange symbol that this item is traded under.
carray [integer]
A list of condition codes.
einteger
The trade correction indicator.
finteger
The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
q*integer
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
rinteger
The ID for the Trade Reporting Facility where the trade took place.
snumber
The size of a trade (also known as volume).
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
y*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
zinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "f05562305bd26ced64b98ed68b3c5d96",
  "results": {
    "T": "AAPL",
    "c": [
      37
    ],
    "f": 1617901342969796400,
    "i": "118749",
    "p": 129.8473,
    "q": 3135876,
    "r": 202,
    "s": 25,
    "t": 1617901342969834000,
    "x": 4,
    "y": 1617901342968000000,
    "z": 3
  },
  "status": "OK"
}
Quotes (NBBO)
GET
/v3/quotes/{stockTicker}
Get NBBO quotes for a ticker symbol in a given time range.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
stockTicker
*

The ticker symbol to get quotes for.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 1000 and max is 50000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/quotes/AAPL?limit=1000&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
resultsarray
ask_exchangeinteger
The ask exchange ID
ask_pricenumber
The ask price.
ask_sizenumber
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
bid_exchangeinteger
The bid exchange ID
bid_pricenumber
The bid price.
bid_sizenumber
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
conditionsarray [integer]
A list of condition codes.
indicatorsarray [integer]
A list of indicator codes.
participant_timestamp*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
sequence_number*integer
The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
sip_timestamp*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
tapeinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
trf_timestampinteger
The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/quotes/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": [
    {
      "ask_exchange": 0,
      "ask_price": 0,
      "ask_size": 0,
      "bid_exchange": 11,
      "bid_price": 102.7,
      "bid_size": 60,
      "conditions": [
        1
      ],
      "participant_timestamp": 1517562000065321200,
      "sequence_number": 2060,
      "sip_timestamp": 1517562000065700400,
      "tape": 3
    },
    {
      "ask_exchange": 0,
      "ask_price": 0,
      "ask_size": 0,
      "bid_exchange": 11,
      "bid_price": 170,
      "bid_size": 2,
      "conditions": [
        1
      ],
      "participant_timestamp": 1517562000065408300,
      "sequence_number": 2061,
      "sip_timestamp": 1517562000065791500,
      "tape": 3
    }
  ],
  "status": "OK"
}
Last Quote
GET
/v2/last/nbbo/{stocksTicker}
Get the most recent NBBO (Quote) tick for a given stock.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
stocksTicker
*

The ticker symbol of the stock/equity.

https://api.polygon.io/v2/last/nbbo/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
request_id*string
A request id assigned by the server.
resultsobject
Pnumber
The ask price.
Sinteger
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
T*string
The exchange symbol that this item is traded under.
Xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
carray [integer]
A list of condition codes.
finteger
The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
iarray [integer]
A list of indicator codes.
pnumber
The bid price.
q*integer
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
sinteger
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
y*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
zinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "b84e24636301f19f88e0dfbf9a45ed5c",
  "results": {
    "P": 127.98,
    "S": 7,
    "T": "AAPL",
    "X": 19,
    "p": 127.96,
    "q": 83480742,
    "s": 1,
    "t": 1617827221349730300,
    "x": 11,
    "y": 1617827221349366000,
    "z": 3
  },
  "status": "OK"
}
All Tickers
GET
/v2/snapshot/locale/us/markets/stocks/tickers
Get the most up-to-date market data for all traded stock symbols.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
tickers

A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/tickers?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
status*string
The status of this request's response.
tickersarray
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "status": "OK",
  "tickers": [
    {
      "day": {
        "c": 20.506,
        "h": 20.64,
        "l": 20.506,
        "o": 20.64,
        "v": 37216,
        "vw": 20.616
      },
      "lastQuote": {
        "P": 20.6,
        "S": 22,
        "p": 20.5,
        "s": 13,
        "t": 1605192959994246100
      },
      "lastTrade": {
        "c": [
          14,
          41
        ],
        "i": "71675577320245",
        "p": 20.506,
        "s": 2416,
        "t": 1605192894630916600,
        "x": 4
      },
      "min": {
        "av": 37216,
        "c": 20.506,
        "h": 20.506,
        "l": 20.506,
        "n": 1,
        "o": 20.506,
        "t": 1684428600000,
        "v": 5000,
        "vw": 20.5105
      },
      "prevDay": {
        "c": 20.63,
        "h": 21,
        "l": 20.5,
        "o": 20.79,
        "v": 292738,
        "vw": 20.6939
      },
      "ticker": "BCAT",
      "todaysChange": -0.124,
      "todaysChangePerc": -0.601,
      "updated": 1605192894630916600
    }
  ]
}
Gainers/Losers
GET
/v2/snapshot/locale/us/markets/stocks/{direction}
Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets.

Top gainers are those tickers whose price has increased by the highest percentage since the previous day's close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day's close. This output will only include tickers with a trading volume of 10,000 or more.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
direction
*

gainers

The direction of the snapshot results to return.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/gainers?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
status*string
The status of this request's response.
tickersarray
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "status": "OK",
  "tickers": [
    {
      "day": {
        "c": 14.2284,
        "h": 15.09,
        "l": 14.2,
        "o": 14.33,
        "v": 133963,
        "vw": 14.5311
      },
      "lastQuote": {
        "P": 14.44,
        "S": 11,
        "p": 14.2,
        "s": 25,
        "t": 1605195929997325600
      },
      "lastTrade": {
        "c": [
          63
        ],
        "i": "79372124707124",
        "p": 14.2284,
        "s": 536,
        "t": 1605195848258266000,
        "x": 4
      },
      "min": {
        "av": 133963,
        "c": 14.2284,
        "h": 14.325,
        "l": 14.2,
        "n": 5,
        "o": 14.28,
        "t": 1684428600000,
        "v": 6108,
        "vw": 14.2426
      },
      "prevDay": {
        "c": 0.73,
        "h": 0.799,
        "l": 0.73,
        "o": 0.75,
        "v": 1568097,
        "vw": 0.7721
      },
      "ticker": "PDS",
      "todaysChange": 13.498,
      "todaysChangePerc": 1849.096,
      "updated": 1605195848258266000
    }
  ]
}
Ticker
GET
/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
Get the most up-to-date market data for a single traded stock ticker.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/tickers/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
status*string
The status of this request's response.
request_id*string
A request id assigned by the server.
tickerobject
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "657e430f1ae768891f018e08e03598d8",
  "status": "OK",
  "ticker": {
    "day": {
      "c": 120.4229,
      "h": 120.53,
      "l": 118.81,
      "o": 119.62,
      "v": 28727868,
      "vw": 119.725
    },
    "lastQuote": {
      "P": 120.47,
      "S": 4,
      "p": 120.46,
      "s": 8,
      "t": 1605195918507251700
    },
    "lastTrade": {
      "c": [
        14,
        41
      ],
      "i": "4046",
      "p": 120.47,
      "s": 236,
      "t": 1605195918306274000,
      "x": 10
    },
    "min": {
      "av": 28724441,
      "c": 120.4201,
      "h": 120.468,
      "l": 120.37,
      "n": 762,
      "o": 120.435,
      "t": 1684428720000,
      "v": 270796,
      "vw": 120.4129
    },
    "prevDay": {
      "c": 119.49,
      "h": 119.63,
      "l": 116.44,
      "o": 117.19,
      "v": 110597265,
      "vw": 118.4998
    },
    "ticker": "AAPL",
    "todaysChange": 0.98,
    "todaysChangePerc": 0.82,
    "updated": 1605195918306274000
  }
}
Universal Snapshot
GET
/v3/snapshot
Get snapshots for assets of all types

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker.any_of

Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.

Warning: The maximum number of characters allowed in a URL are subject to your technology stack.


Additional filter parameters

type


Query by the type of asset.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 250.

sort


Sort field used for ordering.

https://api.polygon.io/v3/snapshot?ticker.any_of=NCLH,O:SPY250321C00380000,C:EURUSD,X:BTCUSD,I:SPX&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request id assigned by the server.
resultsarray
An array of results containing the requested data.
break_even_pricenumber
The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
detailsobject
The details for this contract.
contract_type*enum [put, call, other]
The type of contract. Can be "put", "call", or in some rare cases, "other".
exercise_style*enum [american, european, bermudan]
The exercise style of this contract. See this link for more details on exercise styles.
expiration_date*string
The contract's expiration date in YYYY-MM-DD format.
shares_per_contract*number
The number of shares per contract for this contract.
strike_price*number
The strike price of the option contract.
errorstring
The error while looking for this ticker.
fmvnumber
Fair market value is only available on Business plans. It's it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
greeksobject
The greeks for this contract. There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money. See this article for more information.
delta*number
The change in the option's price per $0.01 increment in the price of the underlying asset.
gamma*number
The change in delta per $0.01 change in the price of the underlying asset.
theta*number
The change in the option's price per day.
vega*number
The change in the option's price per 1% increment in volatility.
implied_volatilitynumber
The market's forecast for the volatility of the underlying asset, based on this option's current price.
last_quoteobject
The most recent quote for this contract. This is only returned if your current plan includes quotes.
ask*number
The ask price.
ask_exchangeinteger
The ask side exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
ask_sizenumber
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
bid*number
The bid price.
bid_exchangeinteger
The bid side exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
bid_sizenumber
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
last_updated*integer
The nanosecond timestamp of when this information was updated.
midpointnumber
The average of the bid and ask price.
timeframe*enum [DELAYED, REAL-TIME]
The time relevance of the data.
last_tradeobject
The most recent quote for this contract. This is only returned if your current plan includes trades.
conditionsarray [integer]
A list of condition codes.
exchangeinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
idstring
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
last_updatedinteger
The nanosecond timestamp of when this information was updated.
participant_timestampinteger
The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
price*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
sip_timestampinteger
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
size*integer
The size of a trade (also known as volume).
timeframeenum [DELAYED, REAL-TIME]
The time relevance of the data.
market_statusstring
The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading. Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
messagestring
The error message while looking for this ticker.
namestring
The name of this contract.
open_interestnumber
The quantity of this contract held at the end of the last trading day.
sessionobject
Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
change*number
The value of the price change for the asset from the previous trading day.
change_percent*number
The percent of the price change for the asset from the previous trading day.
close*number
The closing price of the asset for the day.
early_trading_changenumber
Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
early_trading_change_percentnumber
Today's early trading change as a percentage.
high*number
The highest price of the asset for the day.
late_trading_changenumber
Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
late_trading_change_percentnumber
Today's late trading change as a percentage.
low*number
The lowest price of the asset for the day.
open*number
The open price of the asset for the day.
previous_close*number
The closing price of the asset for the previous trading day.
pricenumber
The price of the most recent trade or bid price for this asset.
regular_trading_changenumber
Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
regular_trading_change_percentnumber
Today's regular trading change as a percentage.
volumenumber
The trading volume for the asset for the day.
ticker*string
The ticker symbol for the asset.
typeenum [stocks, options, fx, crypto, indices]
The asset class for this ticker.
underlying_assetobject
Information on the underlying stock for this options contract. The market data returned depends on your current stocks plan.
change_to_break_even*number
The change in price for the contract to break even.
last_updatedinteger
The nanosecond timestamp of when this information was updated.
pricenumber
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
ticker*string
The ticker symbol for the contract's underlying asset.
timeframeenum [DELAYED, REAL-TIME]
The time relevance of the data.
valuenumber
The value of the underlying index.
valuenumber
Value of Index.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "abc123",
  "results": [
    {
      "break_even_price": 171.075,
      "details": {
        "contract_type": "call",
        "exercise_style": "american",
        "expiration_date": "2022-10-14",
        "shares_per_contract": 100,
        "strike_price": 5,
        "underlying_ticker": "NCLH"
      },
      "fmv": 0.05,
      "greeks": {
        "delta": 0.5520187372272933,
        "gamma": 0.00706756515659829,
        "theta": -0.018532772783847958,
        "vega": 0.7274811132998142
      },
      "implied_volatility": 0.3048997097864957,
      "last_quote": {
        "ask": 21.25,
        "ask_exchange": 12,
        "ask_size": 110,
        "bid": 20.9,
        "bid_exchange": 10,
        "bid_size": 172,
        "last_updated": 1636573458756383500,
        "midpoint": 21.075,
        "timeframe": "REAL-TIME"
      },
      "last_trade": {
        "conditions": [
          209
        ],
        "exchange": 316,
        "price": 0.05,
        "sip_timestamp": 1675280958783136800,
        "size": 2,
        "timeframe": "REAL-TIME"
      },
      "market_status": "closed",
      "name": "NCLH $5 Call",
      "open_interest": 8921,
      "session": {
        "change": -0.05,
        "change_percent": -1.07,
        "close": 6.65,
        "early_trading_change": -0.01,
        "early_trading_change_percent": -0.03,
        "high": 7.01,
        "late_trading_change": -0.4,
        "late_trading_change_percent": -0.02,
        "low": 5.42,
        "open": 6.7,
        "previous_close": 6.71,
        "regular_trading_change": -0.6,
        "regular_trading_change_percent": -0.5,
        "volume": 67
      },
      "ticker": "O:NCLH221014C00005000",
      "type": "options",
      "underlying_asset": {
        "change_to_break_even": 23.123999999999995,
        "last_updated": 1636573459862384600,
        "price": 147.951,
        "ticker": "AAPL",
        "timeframe": "REAL-TIME"
      }
    },
    {
      "fmv": 0.05,
      "last_minute": {
        "close": 412.05,
        "high": 412.1,
        "low": 412.05,
        "open": 412.1,
        "transactions": 26,
        "volume": 610,
        "vwap": 412.0881
      },
      "last_quote": {
        "ask": 21.25,
        "ask_exchange": 300,
        "ask_size": 110,
        "bid": 20.9,
        "bid_exchange": 323,
        "bid_size": 172,
        "last_updated": 1636573458756383500,
        "timeframe": "REAL-TIME"
      },
      "last_trade": {
        "conditions": [
          209
        ],
        "exchange": 316,
        "id": "4064",
        "last_updated": 1675280958783136800,
        "price": 0.05,
        "size": 2,
        "timeframe": "REAL-TIME"
      },
      "market_status": "closed",
      "name": "Apple Inc.",
      "session": {
        "change": -1.05,
        "change_percent": -4.67,
        "close": 21.4,
        "early_trading_change": -0.39,
        "early_trading_change_percent": -0.07,
        "high": 22.49,
        "late_trading_change": 1.2,
        "late_trading_change_percent": 3.92,
        "low": 21.35,
        "open": 22.49,
        "previous_close": 22.45,
        "volume": 37
      },
      "ticker": "AAPL",
      "type": "stocks"
    },
    {
      "error": "NOT_FOUND",
      "message": "Ticker not found.",
      "ticker": "TSLAAPL"
    }
  ],
  "status": "OK"
}
Simple Moving Average (SMA)
GET
/v1/indicators/sma/{stockTicker}
Get the simple moving average (SMA) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.

series_type

close

The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to calculate the simple moving average (SMA).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/sma/AAPL?timespan=day&adjusted=true&window=50&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/sma/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "aggregates": [
        {
          "c": 75.0875,
          "h": 75.15,
          "l": 73.7975,
          "n": 1,
          "o": 74.06,
          "t": 1577941200000,
          "v": 135647456,
          "vw": 74.6099
        },
        {
          "c": 74.3575,
          "h": 75.145,
          "l": 74.125,
          "n": 1,
          "o": 74.2875,
          "t": 1578027600000,
          "v": 146535512,
          "vw": 74.7026
        }
      ],
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 140.139
      }
    ]
  },
  "status": "OK"
}
Exponential Moving Average (EMA)
GET
/v1/indicators/ema/{stockTicker}
Get the exponential moving average (EMA) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.

series_type

close

The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to calculate the exponential moving average (EMA).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/ema/AAPL?timespan=day&adjusted=true&window=50&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/ema/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 140.139
      }
    ]
  },
  "status": "OK"
}
Moving Average Convergence/Divergence (MACD)
GET
/v1/indicators/macd/{stockTicker}
Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

short_window

The short window size used to calculate MACD data.

long_window

The long window size used to calculate MACD data.

signal_window

The window size used to calculate the MACD signal line.

series_type

close

The price in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close prices to calculate the MACD.

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/macd/AAPL?timespan=day&adjusted=true&short_window=12&long_window=26&signal_window=9&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
histogramnumber
The indicator value for this period.
signalnumber
The indicator value for this period.
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/macd/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "histogram": 38.3801666667,
        "signal": 106.9811666667,
        "timestamp": 1517562000016,
        "value": 145.3613333333
      },
      {
        "histogram": 41.098859136,
        "signal": 102.7386283473,
        "timestamp": 1517562001016,
        "value": 143.8374874833
      }
    ]
  },
  "status": "OK"
}
Relative Strength Index (RSI)
GET
/v1/indicators/rsi/{stockTicker}
Get the relative strength index (RSI) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the relative strength index (RSI).

series_type

close

The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to calculate the relative strength index (RSI).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/rsi/AAPL?timespan=day&adjusted=true&window=14&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/rsi/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 82.19
      }
    ]
  },
  "status": "OK"
}
Tickers
GET
/v3/reference/tickers
Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
Parameters
ticker

Specify a ticker symbol. Defaults to empty string which queries all tickers.


Additional filter parameters

type


Specify the type of the tickers. Find the types that we support via our Ticker Types API. Defaults to empty string which queries all types.

market


Filter by market type. By default all markets are included.

exchange

Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes at the ISO org website. Defaults to empty string which queries all exchanges.

cusip

Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes at their website. Defaults to empty string which queries all CUSIPs.

Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.

cik

Specify the CIK of the asset you want to search for. Find more information about CIK codes at their website. Defaults to empty string which queries all CIKs.

date


Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.

search

Search for terms within the ticker and/or company name.

active

true

Specify if the tickers returned should be actively traded on the queried date. Default is true.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 100 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/tickers?active=true&limit=100&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
An array of tickers that match your query.
Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
activeboolean
Whether or not the asset is actively traded. False means the asset has been delisted.
cikstring
The CIK number for this ticker. Find more information here.
composite_figistring
The composite OpenFIGI number for this ticker. Find more information here
currency_namestring
The name of the currency that this asset is traded with.
delisted_utcstring
The last date that the asset was traded.
last_updated_utcstring
The information is accurate up to this time.
locale*enum [us, global]
The locale of the asset.
market*enum [stocks, crypto, fx, otc, indices]
The market type of the asset.
name*string
The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
primary_exchangestring
The ISO code of the primary listing exchange for this asset.
share_class_figistring
The share Class OpenFIGI number for this ticker. Find more information here
ticker*string
The exchange symbol that this item is traded under.
typestring
The type of the asset. Find the types that we support via our Ticker Types API.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io/v3/reference/tickers?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "e70013d92930de90e089dc8fa098888e",
  "results": [
    {
      "active": true,
      "cik": "0001090872",
      "composite_figi": "BBG000BWQYZ5",
      "currency_name": "usd",
      "last_updated_utc": "2021-04-25T00:00:00Z",
      "locale": "us",
      "market": "stocks",
      "name": "Agilent Technologies Inc.",
      "primary_exchange": "XNYS",
      "share_class_figi": "BBG001SCTQY4",
      "ticker": "A",
      "type": "CS"
    }
  ],
  "status": "OK"
}
Ticker Details v3
GET
/v3/reference/tickers/{ticker}
Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
Parameters
ticker
*

The ticker symbol of the asset.

date


Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.

For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.

Defaults to the most recent available date.

https://api.polygon.io/v3/reference/tickers/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_idstring
A request id assigned by the server.
resultsobject
Ticker with details.
active*boolean
Whether or not the asset is actively traded. False means the asset has been delisted.
addressobject
address1string
The first line of the company's headquarters address.
address2string
The second line of the company's headquarters address, if applicable.
citystring
The city of the company's headquarters address.
postal_codestring
The postal code of the company's headquarters address.
statestring
The state of the company's headquarters address.
brandingobject
icon_urlstring
A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
logo_urlstring
A link to this ticker's company's logo. Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
cikstring
The CIK number for this ticker. Find more information here.
composite_figistring
The composite OpenFIGI number for this ticker. Find more information here
currency_name*string
The name of the currency that this asset is traded with.
delisted_utcstring
The last date that the asset was traded.
descriptionstring
A description of the company and what they do/offer.
homepage_urlstring
The URL of the company's website homepage.
list_datestring
The date that the symbol was first publicly listed in the format YYYY-MM-DD.
locale*enum [us, global]
The locale of the asset.
market*enum [stocks, crypto, fx, otc, indices]
The market type of the asset.
market_capnumber
The most recent close price of the ticker multiplied by weighted outstanding shares.
name*string
The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
phone_numberstring
The phone number for the company behind this ticker.
primary_exchangestring
The ISO code of the primary listing exchange for this asset.
round_lotnumber
Round lot size of this security.
share_class_figistring
The share Class OpenFIGI number for this ticker. Find more information here
share_class_shares_outstandingnumber
The recorded number of outstanding shares for this particular share class.
sic_codestring
The standard industrial classification code for this ticker. For a list of SIC Codes, see the SEC's SIC Code List.
sic_descriptionstring
A description of this ticker's SIC code.
ticker*string
The exchange symbol that this item is traded under.
ticker_rootstring
The root of a specified ticker. For example, the root of BRK.A is BRK.
ticker_suffixstring
The suffix of a specified ticker. For example, the suffix of BRK.A is A.
total_employeesnumber
The approximate number of employees for the company.
typestring
The type of the asset. Find the types that we support via our Ticker Types API.
weighted_shares_outstandingnumber
The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": {
    "active": true,
    "address": {
      "address1": "One Apple Park Way",
      "city": "Cupertino",
      "postal_code": "95014",
      "state": "CA"
    },
    "branding": {
      "icon_url": "https://api.polygon.io/v1/reference/company-branding/d3d3LmFwcGxlLmNvbQ/images/2022-01-10_icon.png",
      "logo_url": "https://api.polygon.io/v1/reference/company-branding/d3d3LmFwcGxlLmNvbQ/images/2022-01-10_logo.svg"
    },
    "cik": "0000320193",
    "composite_figi": "BBG000B9XRY4",
    "currency_name": "usd",
    "description": "Apple designs a wide variety of consumer electronic devices, including smartphones (iPhone), tablets (iPad), PCs (Mac), smartwatches (Apple Watch), AirPods, and TV boxes (Apple TV), among others. The iPhone makes up the majority of Apple's total revenue. In addition, Apple offers its customers a variety of services such as Apple Music, iCloud, Apple Care, Apple TV+, Apple Arcade, Apple Card, and Apple Pay, among others. Apple's products run internally developed software and semiconductors, and the firm is well known for its integration of hardware, software and services. Apple's products are distributed online as well as through company-owned stores and third-party retailers. The company generates roughly 40% of its revenue from the Americas, with the remainder earned internationally.",
    "homepage_url": "https://www.apple.com",
    "list_date": "1980-12-12",
    "locale": "us",
    "market": "stocks",
    "market_cap": 2771126040150,
    "name": "Apple Inc.",
    "phone_number": "(408) 996-1010",
    "primary_exchange": "XNAS",
    "round_lot": 100,
    "share_class_figi": "BBG001S5N8V8",
    "share_class_shares_outstanding": 16406400000,
    "sic_code": "3571",
    "sic_description": "ELECTRONIC COMPUTERS",
    "ticker": "AAPL",
    "ticker_root": "AAPL",
    "total_employees": 154000,
    "type": "CS",
    "weighted_shares_outstanding": 16334371000
  },
  "status": "OK"
}
Ticker Events
GET
/vX/reference/tickers/{id}/events
Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.

This API is experimental.
Parameters
id
*

Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the Ticker Details Endpoint

types

A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.

https://api.polygon.io/vX/reference/tickers/META/events?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
request_idstring
A request id assigned by the server.
resultsobject
eventsarray [undefined]
namestring
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": {
    "events": [
      {
        "date": "2022-06-09",
        "ticker_change": {
          "ticker": "META"
        },
        "type": "ticker_change"
      },
      {
        "date": "2012-05-18",
        "ticker_change": {
          "ticker": "FB"
        },
        "type": "ticker_change"
      }
    ],
    "name": "Meta Platforms, Inc. Class A Common Stock"
  },
  "status": "OK"
}
Ticker News
GET
/v2/reference/news
Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

published_utc

Return results published on, before, or after this date.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v2/reference/news?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
amp_urlstring
The mobile friendly Accelerated Mobile Page (AMP) URL.
article_url*string
A link to the news article.
author*string
The article's author.
descriptionstring
A description of the article.
id*string
Unique identifier for the article.
image_urlstring
The article's image URL.
insightsarray
The insights related to the article.
sentiment*enum [positive, neutral, negative]
The sentiment of the insight.
sentiment_reasoning*string
The reasoning behind the sentiment.
ticker*string
The ticker symbol associated with the insight.
keywordsarray [string]
The keywords associated with the article (which will vary depending on the publishing source).
published_utc*string
The date the article was published on.
publisher*object
favicon_urlstring
The publisher's homepage favicon URL.
homepage_url*string
The publisher's homepage URL.
logo_url*string
The publisher's logo URL.
name*string
The publisher's name.
tickers*array [string]
The ticker symbols associated with the article.
title*string
The title of the news article.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io:443/v2/reference/news?cursor=eyJsaW1pdCI6MSwic29ydCI6InB1Ymxpc2hlZF91dGMiLCJvcmRlciI6ImFzY2VuZGluZyIsInRpY2tlciI6e30sInB1Ymxpc2hlZF91dGMiOnsiZ3RlIjoiMjAyMS0wNC0yNiJ9LCJzZWFyY2hfYWZ0ZXIiOlsxNjE5NDA0Mzk3MDAwLG51bGxdfQ",
  "request_id": "831afdb0b8078549fed053476984947a",
  "results": [
    {
      "amp_url": "https://m.uk.investing.com/news/stock-market-news/markets-are-underestimating-fed-cuts-ubs-3559968?ampMode=1",
      "article_url": "https://uk.investing.com/news/stock-market-news/markets-are-underestimating-fed-cuts-ubs-3559968",
      "author": "Sam Boughedda",
      "description": "UBS analysts warn that markets are underestimating the extent of future interest rate cuts by the Federal Reserve, as the weakening economy is likely to justify more cuts than currently anticipated.",
      "id": "8ec638777ca03b553ae516761c2a22ba2fdd2f37befae3ab6fdab74e9e5193eb",
      "image_url": "https://i-invdn-com.investing.com/news/LYNXNPEC4I0AL_L.jpg",
      "insights": [
        {
          "sentiment": "positive",
          "sentiment_reasoning": "UBS analysts are providing a bullish outlook on the extent of future Federal Reserve rate cuts, suggesting that markets are underestimating the number of cuts that will occur.",
          "ticker": "UBS"
        }
      ],
      "keywords": [
        "Federal Reserve",
        "interest rates",
        "economic data"
      ],
      "published_utc": "2024-06-24T18:33:53Z",
      "publisher": {
        "favicon_url": "https://s3.polygon.io/public/assets/news/favicons/investing.ico",
        "homepage_url": "https://www.investing.com/",
        "logo_url": "https://s3.polygon.io/public/assets/news/logos/investing.png",
        "name": "Investing.com"
      },
      "tickers": [
        "UBS"
      ],
      "title": "Markets are underestimating Fed cuts: UBS By Investing.com - Investing.com UK"
    }
  ],
  "status": "OK"
}
Ticker Types
GET
/v3/reference/tickers/types
List all ticker types that Polygon.io has.
Parameters
asset_class

stocks

Filter by asset class.

locale


Filter by locale.

https://api.polygon.io/v3/reference/tickers/types?asset_class=stocks&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_id*string
A request ID assigned by the server.
resultsarray
asset_class*enum [stocks, options, crypto, fx, indices]
An identifier for a group of similar financial instruments.
code*string
A code used by Polygon.io to refer to this ticker type.
description*string
A short description of this ticker type.
locale*enum [us, global]
An identifier for a geographical location.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "asset_class": "stocks",
      "code": "CS",
      "description": "Common Stock",
      "locale": "us"
    }
  ],
  "status": "OK"
}
Market Holidays
GET
/v1/marketstatus/upcoming
Get upcoming market holidays and their open/close times.
https://api.polygon.io/v1/marketstatus/upcoming?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
responsearray
closestring
The market close time on the holiday (if it's not closed).
datestring
The date of the holiday.
exchangestring
Which market the record is for.
namestring
The name of the holiday.
openstring
The market open time on the holiday (if it's not closed).
statusstring
The status of the market on the holiday.
Was this helpful?
Help us improve


Yes


No
Response Object
[
  {
    "date": "2020-11-26",
    "exchange": "NYSE",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "date": "2020-11-26",
    "exchange": "NASDAQ",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "date": "2020-11-26",
    "exchange": "OTC",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "close": "2020-11-27T18:00:00.000Z",
    "date": "2020-11-27",
    "exchange": "NASDAQ",
    "name": "Thanksgiving",
    "open": "2020-11-27T14:30:00.000Z",
    "status": "early-close"
  },
  {
    "close": "2020-11-27T18:00:00.000Z",
    "date": "2020-11-27",
    "exchange": "NYSE",
    "name": "Thanksgiving",
    "open": "2020-11-27T14:30:00.000Z",
    "status": "early-close"
  }
]
Market Status
GET
/v1/marketstatus/now
Get the current trading status of the exchanges and overall financial markets.
https://api.polygon.io/v1/marketstatus/now?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
afterHoursboolean
Whether or not the market is in post-market hours.
currenciesobject
cryptostring
The status of the crypto market.
fxstring
The status of the forex market.
earlyHoursboolean
Whether or not the market is in pre-market hours.
exchangesobject
nasdaqstring
The status of the Nasdaq market.
nysestring
The status of the NYSE market.
otcstring
The status of the OTC market.
indicesGroupsobject
cccystring
The status of Cboe Streaming Market Indices Cryptocurrency ("CCCY") indices trading hours.
cgistring
The status of Cboe Global Indices ("CGI") trading hours.
dow_jonesstring
The status of Dow Jones indices trading hours
ftse_russellstring
The status of Financial Times Stock Exchange Group ("FTSE") Russell indices trading hours.
mscistring
The status of Morgan Stanley Capital International ("MSCI") indices trading hours.
mstarstring
The status of Morningstar ("MSTAR") indices trading hours.
mstarc
The status of Morningstar Customer ("MSTARC") indices trading hours.
nasdaqstring
The status of National Association of Securities Dealers Automated Quotations ("Nasdaq") indices trading hours.
s_and_pstring
The status of Standard & Poors's ("S&P") indices trading hours.
societe_generalestring
The status of Societe Generale indices trading hours.
marketstring
The status of the market as a whole.
serverTimestring
The current time of the server, returned as a date-time in RFC3339 format.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "afterHours": true,
  "currencies": {
    "crypto": "open",
    "fx": "open"
  },
  "earlyHours": false,
  "exchanges": {
    "nasdaq": "extended-hours",
    "nyse": "extended-hours",
    "otc": "closed"
  },
  "market": "extended-hours",
  "serverTime": "2020-11-10T17:37:37-05:00"
}
Stock Splits v3
GET
/v3/reference/splits
Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

execution_date


Query by execution date with the format YYYY-MM-DD.


Additional filter parameters

reverse_split


Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/splits?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
resultsarray
execution_date*string
The execution date of the stock split. On this date the stock split was applied.
id*string
The unique identifier for this stock split.
split_from*number
The second number in the split ratio.
For example: In a 2-for-1 split, split_from would be 1.
split_to*number
The first number in the split ratio.
For example: In a 2-for-1 split, split_to would be 2.
ticker*string
The ticker symbol of the stock split.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/splits/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "results": [
    {
      "execution_date": "2020-08-31",
      "id": "E36416cce743c3964c5da63e1ef1626c0aece30fb47302eea5a49c0055c04e8d0",
      "split_from": 1,
      "split_to": 4,
      "ticker": "AAPL"
    },
    {
      "execution_date": "2005-02-28",
      "id": "E90a77bdf742661741ed7c8fc086415f0457c2816c45899d73aaa88bdc8ff6025",
      "split_from": 1,
      "split_to": 2,
      "ticker": "AAPL"
    }
  ],
  "status": "OK"
}
Dividends v3
GET
/v3/reference/dividends
Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

ex_dividend_date


Query by ex-dividend date with the format YYYY-MM-DD.


Additional filter parameters

record_date


Query by record date with the format YYYY-MM-DD.


Additional filter parameters

declaration_date


Query by declaration date with the format YYYY-MM-DD.


Additional filter parameters

pay_date


Query by pay date with the format YYYY-MM-DD.


Additional filter parameters

frequency


Query by the number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), and 12 (monthly).

cash_amount

Query by the cash amount of the dividend.


Additional filter parameters

dividend_type


Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/dividends?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
resultsarray
cash_amount*number
The cash amount of the dividend per share owned.
currencystring
The currency in which the dividend is paid.
declaration_datestring
The date that the dividend was announced.
dividend_type*enum [CD, SC, LT, ST]
The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
ex_dividend_date*string
The date that the stock first trades without the dividend, determined by the exchange.
frequency*integer
The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), and 12 (monthly).
id*string
The unique identifier of the dividend.
pay_datestring
The date that the dividend is paid out.
record_datestring
The date that the stock must be held to receive the dividend, set by the company.
ticker*string
The ticker symbol of the dividend.
statusstring
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/reference/dividends/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "results": [
    {
      "cash_amount": 0.22,
      "declaration_date": "2021-10-28",
      "dividend_type": "CD",
      "ex_dividend_date": "2021-11-05",
      "frequency": 4,
      "id": "E8e3c4f794613e9205e2f178a36c53fcc57cdabb55e1988c87b33f9e52e221444",
      "pay_date": "2021-11-11",
      "record_date": "2021-11-08",
      "ticker": "AAPL"
    },
    {
      "cash_amount": 0.22,
      "declaration_date": "2021-07-27",
      "dividend_type": "CD",
      "ex_dividend_date": "2021-08-06",
      "frequency": 4,
      "id": "E6436c5475706773f03490acf0b63fdb90b2c72bfeed329a6eb4afc080acd80ae",
      "pay_date": "2021-08-12",
      "record_date": "2021-08-09",
      "ticker": "AAPL"
    }
  ],
  "status": "OK"
}
Stock Financials vX
GET
/vX/reference/financials
Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined here.

This API is experimental.
Parameters
ticker

Query by company ticker.

cik

Query by central index key (CIK) Number

company_name

Query by company name.


Additional filter parameters

sic

Query by standard industrial classification (SIC)

filing_date


Query by the date when the filing with financials data was filed in YYYY-MM-DD format.

Best used when querying over date ranges to find financials based on filings that happen in a time period.

Examples:

To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte=2009-01-01

To get financials based on filings that happened in the year 2009 use the query params filing_date.gte=2009-01-01&filing_date.lt=2010-01-01


Additional filter parameters

period_of_report_date


The period of report for the filing with financials data in YYYY-MM-DD format.


Additional filter parameters

timeframe


Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4

include_sources


Whether or not to include the xpath and formula attributes for each financial data point. See the xpath and formula response attributes for more info. False by default.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 100.

sort


Sort field used for ordering.

https://api.polygon.io/vX/reference/financials?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
count*integer
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request id assigned by the server.
results*array
acceptance_datetime
The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
cik*string
The CIK number for the company.
company_name*string
The company name.
end_datestring
The end date of the period that these financials cover in YYYYMMDD format.
filing_date
The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
financials*object
balance_sheetobject
Balance sheet. The keys in this object can be any of the fields listed in the Balance Sheet section of the financials API glossary of terms.
*object
An individual financial data point.
derived_fromarray [string]
The list of report IDs (or errata) which were used to derive this data point. This value is only returned for data points taken directly from XBRL when the include_sources query parameter is true and if source is SourceInterReportDerived.
formulastring
The name of the formula used to derive this data point from other financial data points. Information about the formulas can be found here. This value is only returned for data points that are not explicitly expressed within the XBRL source file when the include_sources query parameter is true and if source is SourceIntraReportImpute.
label*string
A human readable label for the financial data point.
order*integer
An indicator of what order within the statement that you would find this data point.
source
The source where this data point came from. This will be one of: SourceDirectReport, SourceIntraReportImpute or SourceInterReportDerived.
unit*string
The unit of the financial data point.
value*number
The value of the financial data point.
xpathstring
The XPath 1.0 query that identifies the fact from within the XBRL source file. This value is only returned for data points taken directly from XBRL when the include_sources query parameter is true and if source is SourceDirectReport.
cash_flow_statementobject
Cash flow statement. The keys in this object can be any of the fields listed in the Cash Flow Statement section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
comprehensive_incomeobject
Comprehensive income. The keys in this object can be any of the fields listed in the Comprehensive Income section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
income_statementobject
Income statement. The keys in this object can be any of the fields listed in the Income Statement section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
fiscal_period*string
Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
fiscal_yearstring
Fiscal year of the report according to the company.
source_filing_file_url
The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
source_filing_urlstring
The URL of the SEC filing that these financials were derived from.
start_datestring
The start date of the period that these financials cover in YYYYMMDD format.
tickersarray [string]
The list of ticker symbols for the company.
timeframe*string
The timeframe of the report (quarterly, annual or ttm).
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io/vX/reference/financials?",
  "request_id": "55eb92ed43b25568ab0cce159830ea34",
  "results": [
    {
      "cik": "0001650729",
      "company_name": "SiteOne Landscape Supply, Inc.",
      "end_date": "2022-04-03",
      "filing_date": "2022-05-04",
      "financials": {
        "balance_sheet": {
          "assets": {
            "label": "Assets",
            "order": 100,
            "unit": "USD",
            "value": 2407400000
          },
          "current_assets": {
            "label": "Current Assets",
            "order": 200,
            "unit": "USD",
            "value": 1385900000
          },
          "current_liabilities": {
            "label": "Current Liabilities",
            "order": 700,
            "unit": "USD",
            "value": 597500000
          },
          "equity": {
            "label": "Equity",
            "order": 1400,
            "unit": "USD",
            "value": 1099200000
          },
          "equity_attributable_to_noncontrolling_interest": {
            "label": "Equity Attributable To Noncontrolling Interest",
            "order": 1500,
            "unit": "USD",
            "value": 0
          },
          "equity_attributable_to_parent": {
            "label": "Equity Attributable To Parent",
            "order": 1600,
            "unit": "USD",
            "value": 1099200000
          },
          "liabilities": {
            "label": "Liabilities",
            "order": 600,
            "unit": "USD",
            "value": 1308200000
          },
          "liabilities_and_equity": {
            "label": "Liabilities And Equity",
            "order": 1900,
            "unit": "USD",
            "value": 2407400000
          },
          "noncurrent_assets": {
            "label": "Noncurrent Assets",
            "order": 300,
            "unit": "USD",
            "value": 1021500000
          },
          "noncurrent_liabilities": {
            "label": "Noncurrent Liabilities",
            "order": 800,
            "unit": "USD",
            "value": 710700000
          }
        },
        "cash_flow_statement": {
          "exchange_gains_losses": {
            "label": "Exchange Gains/Losses",
            "order": 1000,
            "unit": "USD",
            "value": 100000
          },
          "net_cash_flow": {
            "label": "Net Cash Flow",
            "order": 1100,
            "unit": "USD",
            "value": -8600000
          },
          "net_cash_flow_continuing": {
            "label": "Net Cash Flow, Continuing",
            "order": 1200,
            "unit": "USD",
            "value": -8700000
          },
          "net_cash_flow_from_financing_activities": {
            "label": "Net Cash Flow From Financing Activities",
            "order": 700,
            "unit": "USD",
            "value": 150600000
          },
          "net_cash_flow_from_financing_activities_continuing": {
            "label": "Net Cash Flow From Financing Activities, Continuing",
            "order": 800,
            "unit": "USD",
            "value": 150600000
          },
          "net_cash_flow_from_investing_activities": {
            "label": "Net Cash Flow From Investing Activities",
            "order": 400,
            "unit": "USD",
            "value": -41000000
          },
          "net_cash_flow_from_investing_activities_continuing": {
            "label": "Net Cash Flow From Investing Activities, Continuing",
            "order": 500,
            "unit": "USD",
            "value": -41000000
          },
          "net_cash_flow_from_operating_activities": {
            "label": "Net Cash Flow From Operating Activities",
            "order": 100,
            "unit": "USD",
            "value": -118300000
          },
          "net_cash_flow_from_operating_activities_continuing": {
            "label": "Net Cash Flow From Operating Activities, Continuing",
            "order": 200,
            "unit": "USD",
            "value": -118300000
          }
        },
        "comprehensive_income": {
          "comprehensive_income_loss": {
            "label": "Comprehensive Income/Loss",
            "order": 100,
            "unit": "USD",
            "value": 40500000
          },
          "comprehensive_income_loss_attributable_to_noncontrolling_interest": {
            "label": "Comprehensive Income/Loss Attributable To Noncontrolling Interest",
            "order": 200,
            "unit": "USD",
            "value": 0
          },
          "comprehensive_income_loss_attributable_to_parent": {
            "label": "Comprehensive Income/Loss Attributable To Parent",
            "order": 300,
            "unit": "USD",
            "value": 40500000
          },
          "other_comprehensive_income_loss": {
            "label": "Other Comprehensive Income/Loss",
            "order": 400,
            "unit": "USD",
            "value": 40500000
          },
          "other_comprehensive_income_loss_attributable_to_parent": {
            "label": "Other Comprehensive Income/Loss Attributable To Parent",
            "order": 600,
            "unit": "USD",
            "value": 8200000
          }
        },
        "income_statement": {
          "basic_earnings_per_share": {
            "label": "Basic Earnings Per Share",
            "order": 4200,
            "unit": "USD / shares",
            "value": 0.72
          },
          "benefits_costs_expenses": {
            "label": "Benefits Costs and Expenses",
            "order": 200,
            "unit": "USD",
            "value": 768400000
          },
          "cost_of_revenue": {
            "label": "Cost Of Revenue",
            "order": 300,
            "unit": "USD",
            "value": 536100000
          },
          "costs_and_expenses": {
            "label": "Costs And Expenses",
            "order": 600,
            "unit": "USD",
            "value": 768400000
          },
          "diluted_earnings_per_share": {
            "label": "Diluted Earnings Per Share",
            "order": 4300,
            "unit": "USD / shares",
            "value": 0.7
          },
          "gross_profit": {
            "label": "Gross Profit",
            "order": 800,
            "unit": "USD",
            "value": 269200000
          },
          "income_loss_from_continuing_operations_after_tax": {
            "label": "Income/Loss From Continuing Operations After Tax",
            "order": 1400,
            "unit": "USD",
            "value": 32300000
          },
          "income_loss_from_continuing_operations_before_tax": {
            "label": "Income/Loss From Continuing Operations Before Tax",
            "order": 1500,
            "unit": "USD",
            "value": 36900000
          },
          "income_tax_expense_benefit": {
            "label": "Income Tax Expense/Benefit",
            "order": 2200,
            "unit": "USD",
            "value": 4600000
          },
          "interest_expense_operating": {
            "label": "Interest Expense, Operating",
            "order": 2700,
            "unit": "USD",
            "value": 4300000
          },
          "net_income_loss": {
            "label": "Net Income/Loss",
            "order": 3200,
            "unit": "USD",
            "value": 32300000
          },
          "net_income_loss_attributable_to_noncontrolling_interest": {
            "label": "Net Income/Loss Attributable To Noncontrolling Interest",
            "order": 3300,
            "unit": "USD",
            "value": 0
          },
          "net_income_loss_attributable_to_parent": {
            "label": "Net Income/Loss Attributable To Parent",
            "order": 3500,
            "unit": "USD",
            "value": 32300000
          },
          "net_income_loss_available_to_common_stockholders_basic": {
            "label": "Net Income/Loss Available To Common Stockholders, Basic",
            "order": 3700,
            "unit": "USD",
            "value": 32300000
          },
          "operating_expenses": {
            "label": "Operating Expenses",
            "order": 1000,
            "unit": "USD",
            "value": 228000000
          },
          "operating_income_loss": {
            "label": "Operating Income/Loss",
            "order": 1100,
            "unit": "USD",
            "value": 41200000
          },
          "participating_securities_distributed_and_undistributed_earnings_loss_basic": {
            "label": "Participating Securities, Distributed And Undistributed Earnings/Loss, Basic",
            "order": 3800,
            "unit": "USD",
            "value": 0
          },
          "preferred_stock_dividends_and_other_adjustments": {
            "label": "Preferred Stock Dividends And Other Adjustments",
            "order": 3900,
            "unit": "USD",
            "value": 0
          },
          "revenues": {
            "label": "Revenues",
            "order": 100,
            "unit": "USD",
            "value": 805300000
          }
        }
      },
      "fiscal_period": "Q1",
      "fiscal_year": "2022",
      "source_filing_file_url": "https://api.polygon.io/v1/reference/sec/filings/0001650729-22-000010/files/site-20220403_htm.xml",
      "source_filing_url": "https://api.polygon.io/v1/reference/sec/filings/0001650729-22-000010",
      "start_date": "2022-01-03"
    }
  ],
  "status": "OK"
}
Conditions
GET
/v3/reference/conditions
List all conditions that Polygon.io uses.
Parameters
asset_class

stocks

Filter for conditions within a given asset class.

data_type


Filter by data type.

id

Filter for conditions with a given ID.

sip


Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/conditions?asset_class=stocks&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
count*integer
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request ID assigned by the server.
results*array
An array of conditions that match your query.
abbreviationstring
A commonly-used abbreviation for this condition.
asset_class*enum [stocks, options, crypto, fx]
An identifier for a group of similar financial instruments.
data_types*array [string]
Data types that this condition applies to.
descriptionstring
A short description of the semantics of this condition.
exchangeinteger
If present, mapping this condition from a Polygon.io code to a SIP symbol depends on this attribute. In other words, data with this condition attached comes exclusively from the given exchange.
id*integer
An identifier used by Polygon.io for this condition. Unique per data type.
legacyboolean
If true, this condition is from an old version of the SIPs' specs and no longer is used. Other conditions may or may not reuse the same symbol as this one.
name*string
The name of this condition.
sip_mapping*object
A mapping to a symbol for each SIP that has this condition.
CTAstring
OPRAstring
UTPstring
type*enum [sale_condition, quote_condition, sip_generated_flag, financial_status_indicator, short_sale_restriction_indicator, settlement_condition, market_condition, trade_thru_exempt]
An identifier for a collection of related conditions.
update_rulesobject
A list of aggregation rules.
consolidated*object
Describes aggregation rules on a consolidated (all exchanges) basis.
updates_high_low*boolean
Whether or not trades with this condition update the high/low.
updates_open_close*boolean
Whether or not trades with this condition update the open/close.
updates_volume*boolean
Whether or not trades with this condition update the volume.
market_center*object
Describes aggregation rules on a per-market-center basis.
updates_high_low*boolean
Whether or not trades with this condition update the high/low.
updates_open_close*boolean
Whether or not trades with this condition update the open/close.
updates_volume*boolean
Whether or not trades with this condition update the volume.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "asset_class": "stocks",
      "data_types": [
        "trade"
      ],
      "id": 2,
      "name": "Average Price Trade",
      "sip_mapping": {
        "CTA": "B",
        "UTP": "W"
      },
      "type": "condition",
      "update_rules": {
        "consolidated": {
          "updates_high_low": false,
          "updates_open_close": false,
          "updates_volume": true
        },
        "market_center": {
          "updates_high_low": false,
          "updates_open_close": false,
          "updates_volume": true
        }
      }
    }
  ],
  "status": "OK"
}
Exchanges
GET
/v3/reference/exchanges
List all exchanges that Polygon.io knows about.
Parameters
asset_class

stocks

Filter by asset class.

locale


Filter by locale.

https://api.polygon.io/v3/reference/exchanges?asset_class=stocks&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_id*string
A request ID assigned by the server.
resultsarray
acronymstring
A commonly used abbreviation for this exchange.
asset_class*enum [stocks, options, crypto, fx]
An identifier for a group of similar financial instruments.
id*integer
A unique identifier used by Polygon.io for this exchange.
locale*enum [us, global]
An identifier for a geographical location.
micstring
The Market Identifier Code of this exchange (see ISO 10383).
name*string
Name of this exchange.
operating_micstring
The MIC of the entity that operates this exchange.
participant_idstring
The ID used by SIP's to represent this exchange.
type*enum [exchange, TRF, SIP]
Represents the type of exchange.
urlstring
A link to this exchange's website, if one exists.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "acronym": "AMEX",
      "asset_class": "stocks",
      "id": 1,
      "locale": "us",
      "mic": "XASE",
      "name": "NYSE American, LLC",
      "operating_mic": "XNYS",
      "participant_id": "A",
      "type": "exchange",
      "url": "https://www.nyse.com/markets/nyse-american"
    }
  ],
  "status": "OK"
}
Related Companies
GET
/v1/related-companies/{ticker}
Get a list of tickers related to the queried ticker based on News and Returns data.
Parameters
ticker
*

The ticker symbol to search.

https://api.polygon.io/v1/related-companies/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
request_idstring
A request id assigned by the server.
resultsarray
ticker*string
A ticker related to the requested ticker.
statusstring
The status of this request's response.
tickerstring
The ticker being queried.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "ticker": "MSFT"
    },
    {
      "ticker": "GOOGL"
    },
    {
      "ticker": "AMZN"
    },
    {
      "ticker": "FB"
    },
    {
      "ticker": "TSLA"
    },
    {
      "ticker": "NVDA"
    },
    {
      "ticker": "INTC"
    },
    {
      "ticker": "ADBE"
    },
    {
      "ticker": "NFLX"
    },
    {
      "ticker": "PYPL"
    }
  ],
  "status": "OK",
  "stock_symbol": "AAPL"
}
IPOs
GET
/vX/reference/ipos
The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

us_code

Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.

isin

Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.

listing_date


Specify a listing date. This is the first trading date for the newly listed entity.


Additional filter parameters

ipo_status


Specify an IPO status.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/vX/reference/ipos?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
An array of results containing the requested data.
announced_datestring
The date when the IPO event was announced.
currency_codestring
Underlying currency of the security.
final_issue_pricenumber
The price set by the company and its underwriters before the IPO goes live.
highest_offer_pricenumber
The highest price within the IPO price range that the company might use to price the shares.
ipo_status*enum [direct_listing_process, history, new, pending, postponed, rumor, withdrawn]
The status of the IPO event. IPO events start out as status "rumor" or "pending". On listing day, the status changes to "new". After the listing day, the status changes to "history".
The status "direct_listing_process" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
isinstring
International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
issuer_name*string
Name of issuer.
last_updated*string
The date when the IPO event was last modified.
listing_datestring
First trading date for the newly listed entity.
lot_sizenumber
The minimum number of shares that can be bought or sold in a single transaction.
lowest_offer_pricenumber
The lowest price within the IPO price range that the company is willing to offer its shares to investors.
max_shares_offerednumber
The upper limit of the shares that the company is offering to investors.
min_shares_offerednumber
The lower limit of shares that the company is willing to sell in the IPO.
primary_exchangestring
Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
security_descriptionstring
Description of the security.
security_type*string
The classification of the stock. For example, "CS" stands for Common Stock.
shares_outstandingnumber
The total number of shares that the company has issued and are held by investors.
ticker*string
The ticker symbol of the IPO event.
total_offer_sizenumber
The total amount raised by the company for IPO.
us_codestring
This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/vX/reference/ipos?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "announced_date": "2024-06-01",
      "currency_code": "USD",
      "final_issue_price": 17,
      "highest_offer_price": 17,
      "ipo_status": "history",
      "isin": "US75383L1026",
      "issue_end_date": "2024-06-06",
      "issue_start_date": "2024-06-01",
      "issuer_name": "Rapport Therapeutics Inc.",
      "last_updated": "2024-06-27",
      "listing_date": "2024-06-07",
      "lot_size": 100,
      "lowest_offer_price": 17,
      "max_shares_offered": 8000000,
      "min_shares_offered": 1000000,
      "primary_exchange": "XNAS",
      "security_description": "Ordinary Shares",
      "security_type": "CS",
      "shares_outstanding": 35376457,
      "ticker": "RAPP",
      "total_offer_size": 136000000,
      "us_code": "75383L102"
    }
  ],
  "status": "OK"
}
Stocks WebSocket Documentation

The Polygon.io Stocks WebSocket API provides streaming access to the latest stock market data from all US stock exchanges. You can specify which channels you want to consume by sending instructions in the form of actions. Our WebSockets emit events to notify you when an event has occurred in a channel you've subscribed to.
Our WebSocket APIs are based on entitlements that control which WebSocket Clusters you can connect to and which kinds of data you can access. Examples in these docs include your API key, which only you can see, and are personalized based on your entitlements.
Step 1: Connect
Your current plan includes 1 connection to wss://delayed.polygon.io/stocks. If you attempt additional connections, the existing connection will be disconnected. If you need more simultaneous connections to this cluster, you can contact support.
Connecting to a cluster:
Delayed:wscat -c wss://delayed.polygon.io/stocks

Copy
On connection you will receive the following message:
[{
	"ev":"status",
	"status":"connected",
	"message": "Connected Successfully"
}]
Step 2: Authenticate
You must authenticate before you can make any other requests.
{"action":"auth","params":"p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5"}

Copy
On successful authentication you will receive the following message:
[{
	"ev":"status",
	"status":"auth_success",
	"message": "authenticated"
}]
Step 3: Subscribe
Once authenticated, you can request a stream. You can request multiple streams in the same request.
{"action":"subscribe","params":"AM.LPL"}

Copy
You can also request multiple streams from the same cluster.
{"action":"subscribe","params":"AM.LPL,AM.MSFT"}

Copy
Usage
Things happen very quickly in the world of finance, which means a Polygon.io WebSocket client must be able to handle many incoming messages per second. Due to the nature of the WebSocket protocol, if a client is slow to consume messages from the server, Polygon.io's server must buffer messages and send them only as fast as the client can consume them. To help prevent the message buffer from getting too long, Polygon.io may send more than one JSON object in a single WebSocket message. We accomplish this by wrapping all messages in a JSON array, and adding more objects to the array if the message buffer is getting longer. For example, consider a WebSocket message with a single trade event in it:
[
    {"ev":"T","sym":"MSFT","i":"50578","x":4,"p":215.9721,"s":100,"t":1611082428813,"z":3}
]
If your client is consuming a bit slow, or 2+ events happened in very short succession, you may receive a single WebSocket message with more than one event inside it, like this:
[
    {"ev":"T","sym":"MSFT","i":"50578","x":4,"p":215.9721,"s":100,"t":1611082428813,"z":3}, 
    {"ev":"T","sym":"MSFT","i":"12856","x":4,"p":215.989,"s":1,"c":[37],"t":1611082428814,"z":3}
]
Note that if a client is consuming messages too slowly for too long, Polygon.io's server-side buffer may get too large. If that happens, Polygon.io will terminate the WebSocket connection. You can check your account dashboard to see if a connection was terminated as a slow consumer. If this happens to you consistently, consider subscribing to fewer symbols or channels.
Your Plan
Stocks Starter

15-minute Delayed Data

1 Stocks Cluster Connection
Manage Subscription
Client Libraries
Python Logo
Python
client-python
Go Logo
Go
client-go
Javascript Logo
Javascript
client-js
PHP Logo
PHP
client-php
Kotlin Logo
Kotlin
client-jvm
Aggregates (Per Minute)
WS
Delayed:wss://delayed.polygon.io/stocks
Stream real-time minute aggregates for a given stock ticker symbol.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"AM.*"}

Copy
Response Attributes
evenum [AM]
The event type.
symstring
The ticker symbol for the given stock.
vinteger
The tick volume.
avinteger
Today's accumulated volume.
opnumber
Today's official opening price.
vwnumber
The tick's volume weighted average price.
onumber
The opening tick price for this aggregate window.
cnumber
The closing tick price for this aggregate window.
hnumber
The highest tick price for this aggregate window.
lnumber
The lowest tick price for this aggregate window.
anumber
Today's volume weighted average price.
zinteger
The average trade size for this aggregate window.
sinteger
The start timestamp of this aggregate window in Unix Milliseconds.
einteger
The end timestamp of this aggregate window in Unix Milliseconds.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "AM",
  "sym": "GTE",
  "v": 4110,
  "av": 9470157,
  "op": 0.4372,
  "vw": 0.4488,
  "o": 0.4488,
  "c": 0.4486,
  "h": 0.4489,
  "l": 0.4486,
  "a": 0.4352,
  "z": 685,
  "s": 1610144640000,
  "e": 1610144700000
}
Aggregates (Per Second)
WS
Delayed:wss://delayed.polygon.io/stocks
Stream real-time second aggregates for a given stock ticker symbol.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"A.*"}

Copy
Response Attributes
evenum [A]
The event type.
symstring
The ticker symbol for the given stock.
vinteger
The tick volume.
avinteger
Today's accumulated volume.
opnumber
Today's official opening price.
vwnumber
The tick's volume weighted average price.
onumber
The opening tick price for this aggregate window.
cnumber
The closing tick price for this aggregate window.
hnumber
The highest tick price for this aggregate window.
lnumber
The lowest tick price for this aggregate window.
anumber
Today's volume weighted average price.
zinteger
The average trade size for this aggregate window.
sinteger
The start timestamp of this aggregate window in Unix Milliseconds.
einteger
The end timestamp of this aggregate window in Unix Milliseconds.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "A",
  "sym": "SPCE",
  "v": 200,
  "av": 8642007,
  "op": 25.66,
  "vw": 25.3981,
  "o": 25.39,
  "c": 25.39,
  "h": 25.39,
  "l": 25.39,
  "a": 25.3714,
  "z": 50,
  "s": 1610144868000,
  "e": 1610144869000
}
Trades
WS
Delayed:wss://delayed.polygon.io/stocks
Real-Time:wss://socket.polygon.io/stocks
Stream real-time trades for a given stock ticker symbol.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"T.*"}

Copy
Response Attributes
evenum [T]
The event type.
symstring
The ticker symbol for the given stock.
xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
istring
The trade ID.
zinteger
The tape. (1 = NYSE, 2 = AMEX, 3 = Nasdaq).
pnumber
The price.
sinteger
The trade size.
carray [integer]
The trade conditions. See Conditions and Indicators for Polygon.io's trade conditions glossary.
tinteger
The SIP timestamp in Unix MS.
qinteger
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
trfiinteger
The ID for the Trade Reporting Facility where the trade took place.
trftinteger
The TRF (Trade Reporting Facility) Timestamp in Unix MS. This is the timestamp of when the trade reporting facility received this trade.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "T",
  "sym": "MSFT",
  "x": 4,
  "i": "12345",
  "z": 3,
  "p": 114.125,
  "s": 100,
  "c": [
    0,
    12
  ],
  "t": 1536036818784,
  "q": 3681328
}
Quotes
WS
Delayed:wss://delayed.polygon.io/stocks
Real-Time:wss://socket.polygon.io/stocks
Stream real-time quotes for a given stock ticker symbol.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"Q.*"}

Copy
Response Attributes
evenum [Q]
The event type.
symstring
The ticker symbol for the given stock.
bxinteger
The bid exchange ID.
bpnumber
The bid price.
bsinteger
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
axinteger
The ask exchange ID.
apnumber
The ask price.
asinteger
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
cinteger
The condition.
iarray [integer]
The indicators. For more information, see our glossary of Conditions and Indicators.
tinteger
The SIP timestamp in Unix MS.
qinteger
The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
zinteger
The tape. (1 = NYSE, 2 = AMEX, 3 = Nasdaq).
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "Q",
  "sym": "MSFT",
  "bx": 4,
  "bp": 114.125,
  "bs": 100,
  "ax": 7,
  "ap": 114.128,
  "as": 160,
  "c": 0,
  "i": [
    604
  ],
  "t": 1536036818784,
  "q": 50385480,
  "z": 3
}
Fair Market Value
WS
Business:wss://business.polygon.io/stocks
Real-time fair market value for a given stock ticker symbol.

Requires a "Stocks Enterprise" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"FMV.*"}

Copy
Response Attributes
evenum [FMV]
The event type.
fmv
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
sym
The ticker symbol for the given security.
t
The nanosecond timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "FMV",
  "fmv": 189.22,
  "sym": "AAPL",
  "t": 1678220098130
}
</file>

<file path="polygonStock2.md">
Stocks API Documentation

The Polygon.io Stocks API provides REST endpoints that let you query the latest market data from all US stock exchanges. You can also find data on company financials, stock market holidays, corporate actions, and more.
Documentation
Authentication
Pass your API key in the query string like follows:
https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2023-01-09/2023-01-09?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy
Alternatively, you can add an Authorization header to the request with your API Key as the token in the following form:
Authorization: Bearer p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy
Usage
Many of Polygon.io's REST endpoints allow you to extend query parameters with inequalities like date.lt=2023-01-01 (less than) and date.gte=2023-01-01 (greater than or equal to) to search ranges of values. You can also use the field name without any extension to query for exact equality. Fields that support extensions will have an "Additional filter parameters" dropdown beneath them in the docs that detail the supported extensions for that parameter.
Response Types
By default, all endpoints return a JSON response. Users with Stocks Starter plan and above can request a CSV response by including 'Accept': 'text/csv' as a request parameter.
Your Plan
Stocks Starter

Unlimited API Calls

15-minute Delayed Data

5 Years Historical Data
Manage Subscription
Client Libraries
Python Logo
Python
client-python
Go Logo
Go
client-go
Javascript Logo
Javascript
client-js
PHP Logo
PHP
client-php
Kotlin Logo
Kotlin
client-jvm
Aggregates (Bars)
GET
/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
Get aggregate bars for a stock over a given date range in custom time window sizes.

For example, if timespan = ‘minute’ and multiplier = ‘5’ then 5-minute bars will be returned.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

multiplier
*

The size of the timespan multiplier.

timespan
*

day

The size of the time window.

from
*

The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.

to
*

The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

sort

asc

Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).

limit

Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on Aggregate Data API Improvements.

https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2023-01-09/2023-02-10?adjusted=true&sort=asc&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
ticker*string
The exchange symbol that this item is traded under.
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
next_urlstring
If present, this value can be used to fetch the next page of data.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "next_url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/1578114000000/2020-01-10?cursor=bGltaXQ9MiZzb3J0PWFzYw",
  "queryCount": 2,
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "c": 75.0875,
      "h": 75.15,
      "l": 73.7975,
      "n": 1,
      "o": 74.06,
      "t": 1577941200000,
      "v": 135647456,
      "vw": 74.6099
    },
    {
      "c": 74.3575,
      "h": 75.145,
      "l": 74.125,
      "n": 1,
      "o": 74.2875,
      "t": 1578027600000,
      "v": 146535512,
      "vw": 74.7026
    }
  ],
  "resultsCount": 2,
  "status": "OK",
  "ticker": "AAPL"
}
Grouped Daily (Bars)
GET
/v2/aggs/grouped/locale/us/market/stocks/{date}
Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
date
*

The beginning date for the aggregate window.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/aggs/grouped/locale/us/market/stocks/2023-01-09?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
T*string
The exchange symbol that this item is traded under.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the end of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "queryCount": 3,
  "results": [
    {
      "T": "KIMpL",
      "c": 25.9102,
      "h": 26.25,
      "l": 25.91,
      "n": 74,
      "o": 26.07,
      "t": 1602705600000,
      "v": 4369,
      "vw": 26.0407
    },
    {
      "T": "TANH",
      "c": 23.4,
      "h": 24.763,
      "l": 22.65,
      "n": 1096,
      "o": 24.5,
      "t": 1602705600000,
      "v": 25933.6,
      "vw": 23.493
    },
    {
      "T": "VSAT",
      "c": 34.24,
      "h": 35.47,
      "l": 34.21,
      "n": 4966,
      "o": 34.9,
      "t": 1602705600000,
      "v": 312583,
      "vw": 34.4736
    }
  ],
  "resultsCount": 3,
  "status": "OK"
}
Daily Open/Close
GET
/v1/open-close/{stocksTicker}/{date}
Get the open, close and afterhours prices of a stock symbol on a certain date.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

date
*


The date of the requested open/close in the format YYYY-MM-DD.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

https://api.polygon.io/v1/open-close/AAPL/2023-01-09?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
afterHoursnumber
The close price of the ticker symbol in after hours trading.
close*number
The close price for the symbol in the given time period.
from*string
The requested date.
high*number
The highest price for the symbol in the given time period.
low*number
The lowest price for the symbol in the given time period.
open*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
preMarketinteger
The open price of the ticker symbol in pre-market trading.
status*string
The status of this request's response.
symbol*string
The exchange symbol that this item is traded under.
volume*number
The trading volume of the symbol in the given time period.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "afterHours": 322.1,
  "close": 325.12,
  "from": "2023-01-09",
  "high": 326.2,
  "low": 322.3,
  "open": 324.66,
  "preMarket": 324.5,
  "status": "OK",
  "symbol": "AAPL",
  "volume": 26122646
}
Previous Close
GET
/v2/aggs/ticker/{stocksTicker}/prev
Get the previous day's open, high, low, and close (OHLC) for the specified stock ticker.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

adjusted

true

Whether or not the results are adjusted for splits. By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.

https://api.polygon.io/v2/aggs/ticker/AAPL/prev?adjusted=true&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
ticker*string
The exchange symbol that this item is traded under.
adjusted*boolean
Whether or not this response was adjusted for splits.
queryCount*integer
The number of aggregates (minute or day) used to generate the response.
request_id*string
A request id assigned by the server.
resultsCount*integer
The total number of results for this request.
status*string
The status of this request's response.
resultsarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
ninteger
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vwnumber
The volume weighted average price.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "adjusted": true,
  "queryCount": 1,
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "T": "AAPL",
      "c": 115.97,
      "h": 117.59,
      "l": 114.13,
      "o": 115.55,
      "t": 1605042000000,
      "v": 131704427,
      "vw": 116.3058
    }
  ],
  "resultsCount": 1,
  "status": "OK",
  "ticker": "AAPL"
}
Trades
GET
/v3/trades/{stockTicker}
Get trades for a ticker symbol in a given time range.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
stockTicker
*

The ticker symbol to get trades for.

timestamp

Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 1000 and max is 50000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/trades/AAPL?limit=1000&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
resultsarray
conditionsarray [integer]
A list of condition codes.
correctioninteger
The trade correction indicator.
exchange*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
id*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
participant_timestamp*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the trade was actually generated at the exchange.
price*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
sequence_number*integer
The sequence number represents the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
sip_timestamp*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
size*number
The size of a trade (also known as volume).
tapeinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
trf_idinteger
The ID for the Trade Reporting Facility where the trade took place.
trf_timestampinteger
The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this trade.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/trades/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": [
    {
      "conditions": [
        12,
        41
      ],
      "exchange": 11,
      "id": "1",
      "participant_timestamp": 1517562000015577000,
      "price": 171.55,
      "sequence_number": 1063,
      "sip_timestamp": 1517562000016036600,
      "size": 100,
      "tape": 3
    },
    {
      "conditions": [
        12,
        41
      ],
      "exchange": 11,
      "id": "2",
      "participant_timestamp": 1517562000015577600,
      "price": 171.55,
      "sequence_number": 1064,
      "sip_timestamp": 1517562000016038100,
      "size": 100,
      "tape": 3
    }
  ],
  "status": "OK"
}
Last Trade
GET
/v2/last/trade/{stocksTicker}
Get the most recent trade for a given stock.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
stocksTicker
*

The ticker symbol of the stock/equity.

https://api.polygon.io/v2/last/trade/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
request_id*string
A request id assigned by the server.
resultsobject
T*string
The exchange symbol that this item is traded under.
carray [integer]
A list of condition codes.
einteger
The trade correction indicator.
finteger
The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
q*integer
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
rinteger
The ID for the Trade Reporting Facility where the trade took place.
snumber
The size of a trade (also known as volume).
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
y*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
zinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "f05562305bd26ced64b98ed68b3c5d96",
  "results": {
    "T": "AAPL",
    "c": [
      37
    ],
    "f": 1617901342969796400,
    "i": "118749",
    "p": 129.8473,
    "q": 3135876,
    "r": 202,
    "s": 25,
    "t": 1617901342969834000,
    "x": 4,
    "y": 1617901342968000000,
    "z": 3
  },
  "status": "OK"
}
Quotes (NBBO)
GET
/v3/quotes/{stockTicker}
Get NBBO quotes for a ticker symbol in a given time range.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
stockTicker
*

The ticker symbol to get quotes for.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 1000 and max is 50000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/quotes/AAPL?limit=1000&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
resultsarray
ask_exchangeinteger
The ask exchange ID
ask_pricenumber
The ask price.
ask_sizenumber
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
bid_exchangeinteger
The bid exchange ID
bid_pricenumber
The bid price.
bid_sizenumber
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
conditionsarray [integer]
A list of condition codes.
indicatorsarray [integer]
A list of indicator codes.
participant_timestamp*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
sequence_number*integer
The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
sip_timestamp*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this quote from the exchange which produced it.
tapeinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
trf_timestampinteger
The nanosecond accuracy TRF (Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this quote.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/quotes/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": [
    {
      "ask_exchange": 0,
      "ask_price": 0,
      "ask_size": 0,
      "bid_exchange": 11,
      "bid_price": 102.7,
      "bid_size": 60,
      "conditions": [
        1
      ],
      "participant_timestamp": 1517562000065321200,
      "sequence_number": 2060,
      "sip_timestamp": 1517562000065700400,
      "tape": 3
    },
    {
      "ask_exchange": 0,
      "ask_price": 0,
      "ask_size": 0,
      "bid_exchange": 11,
      "bid_price": 170,
      "bid_size": 2,
      "conditions": [
        1
      ],
      "participant_timestamp": 1517562000065408300,
      "sequence_number": 2061,
      "sip_timestamp": 1517562000065791500,
      "tape": 3
    }
  ],
  "status": "OK"
}
Last Quote
GET
/v2/last/nbbo/{stocksTicker}
Get the most recent NBBO (Quote) tick for a given stock.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
stocksTicker
*

The ticker symbol of the stock/equity.

https://api.polygon.io/v2/last/nbbo/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
request_id*string
A request id assigned by the server.
resultsobject
Pnumber
The ask price.
Sinteger
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
T*string
The exchange symbol that this item is traded under.
Xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
carray [integer]
A list of condition codes.
finteger
The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
iarray [integer]
A list of indicator codes.
pnumber
The bid price.
q*integer
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
sinteger
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
y*integer
The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
zinteger
There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 = A, 2 = B, 3 = C.
Tape A is NYSE listed securities
Tape B is NYSE ARCA / NYSE American
Tape C is NASDAQ
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "b84e24636301f19f88e0dfbf9a45ed5c",
  "results": {
    "P": 127.98,
    "S": 7,
    "T": "AAPL",
    "X": 19,
    "p": 127.96,
    "q": 83480742,
    "s": 1,
    "t": 1617827221349730300,
    "x": 11,
    "y": 1617827221349366000,
    "z": 3
  },
  "status": "OK"
}
All Tickers
GET
/v2/snapshot/locale/us/markets/stocks/tickers
Get the most up-to-date market data for all traded stock symbols.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
tickers

A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/tickers?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
status*string
The status of this request's response.
tickersarray
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "status": "OK",
  "tickers": [
    {
      "day": {
        "c": 20.506,
        "h": 20.64,
        "l": 20.506,
        "o": 20.64,
        "v": 37216,
        "vw": 20.616
      },
      "lastQuote": {
        "P": 20.6,
        "S": 22,
        "p": 20.5,
        "s": 13,
        "t": 1605192959994246100
      },
      "lastTrade": {
        "c": [
          14,
          41
        ],
        "i": "71675577320245",
        "p": 20.506,
        "s": 2416,
        "t": 1605192894630916600,
        "x": 4
      },
      "min": {
        "av": 37216,
        "c": 20.506,
        "h": 20.506,
        "l": 20.506,
        "n": 1,
        "o": 20.506,
        "t": 1684428600000,
        "v": 5000,
        "vw": 20.5105
      },
      "prevDay": {
        "c": 20.63,
        "h": 21,
        "l": 20.5,
        "o": 20.79,
        "v": 292738,
        "vw": 20.6939
      },
      "ticker": "BCAT",
      "todaysChange": -0.124,
      "todaysChangePerc": -0.601,
      "updated": 1605192894630916600
    }
  ]
}
Gainers/Losers
GET
/v2/snapshot/locale/us/markets/stocks/{direction}
Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets.

Top gainers are those tickers whose price has increased by the highest percentage since the previous day's close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day's close. This output will only include tickers with a trading volume of 10,000 or more.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
direction
*

gainers

The direction of the snapshot results to return.

include_otc


Include OTC securities in the response. Default is false (don't include OTC securities).

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/gainers?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
status*string
The status of this request's response.
tickersarray
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "status": "OK",
  "tickers": [
    {
      "day": {
        "c": 14.2284,
        "h": 15.09,
        "l": 14.2,
        "o": 14.33,
        "v": 133963,
        "vw": 14.5311
      },
      "lastQuote": {
        "P": 14.44,
        "S": 11,
        "p": 14.2,
        "s": 25,
        "t": 1605195929997325600
      },
      "lastTrade": {
        "c": [
          63
        ],
        "i": "79372124707124",
        "p": 14.2284,
        "s": 536,
        "t": 1605195848258266000,
        "x": 4
      },
      "min": {
        "av": 133963,
        "c": 14.2284,
        "h": 14.325,
        "l": 14.2,
        "n": 5,
        "o": 14.28,
        "t": 1684428600000,
        "v": 6108,
        "vw": 14.2426
      },
      "prevDay": {
        "c": 0.73,
        "h": 0.799,
        "l": 0.73,
        "o": 0.75,
        "v": 1568097,
        "vw": 0.7721
      },
      "ticker": "PDS",
      "todaysChange": 13.498,
      "todaysChangePerc": 1849.096,
      "updated": 1605195848258266000
    }
  ]
}
Ticker
GET
/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
Get the most up-to-date market data for a single traded stock ticker.

Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stocksTicker
*

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

https://api.polygon.io/v2/snapshot/locale/us/markets/stocks/tickers/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
status*string
The status of this request's response.
request_id*string
A request id assigned by the server.
tickerobject
dayobject
The most recent daily bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
fmvnumber
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
lastQuoteobject
The most recent quote for this ticker. This is only returned if your current plan includes quotes.
P*number
The ask price.
S*integer
The ask size in lots.
p*number
The bid price.
s*integer
The bid size in lots.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
lastTradeobject
The most recent trade for this ticker. This is only returned if your current plan includes trades.
c*array [integer]
The trade conditions.
i*string
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
p*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
s*integer
The size (volume) of the trade.
t*integer
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
x*integer
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
minobject
The most recent minute bar for this ticker.
av*integer
The accumulated volume.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*integer
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
prevDayobject
The previous day's bar for this ticker.
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
tickerstring
The exchange symbol that this item is traded under.
todaysChangenumber
The value of the change from the previous day.
todaysChangePercnumber
The percentage change since the previous day.
updatedinteger
The last updated timestamp.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "657e430f1ae768891f018e08e03598d8",
  "status": "OK",
  "ticker": {
    "day": {
      "c": 120.4229,
      "h": 120.53,
      "l": 118.81,
      "o": 119.62,
      "v": 28727868,
      "vw": 119.725
    },
    "lastQuote": {
      "P": 120.47,
      "S": 4,
      "p": 120.46,
      "s": 8,
      "t": 1605195918507251700
    },
    "lastTrade": {
      "c": [
        14,
        41
      ],
      "i": "4046",
      "p": 120.47,
      "s": 236,
      "t": 1605195918306274000,
      "x": 10
    },
    "min": {
      "av": 28724441,
      "c": 120.4201,
      "h": 120.468,
      "l": 120.37,
      "n": 762,
      "o": 120.435,
      "t": 1684428720000,
      "v": 270796,
      "vw": 120.4129
    },
    "prevDay": {
      "c": 119.49,
      "h": 119.63,
      "l": 116.44,
      "o": 117.19,
      "v": 110597265,
      "vw": 118.4998
    },
    "ticker": "AAPL",
    "todaysChange": 0.98,
    "todaysChangePerc": 0.82,
    "updated": 1605195918306274000
  }
}
Universal Snapshot
GET
/v3/snapshot
Get snapshots for assets of all types

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker.any_of

Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.

Warning: The maximum number of characters allowed in a URL are subject to your technology stack.


Additional filter parameters

type


Query by the type of asset.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 250.

sort


Sort field used for ordering.

https://api.polygon.io/v3/snapshot?ticker.any_of=NCLH,O:SPY250321C00380000,C:EURUSD,X:BTCUSD,I:SPX&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request id assigned by the server.
resultsarray
An array of results containing the requested data.
break_even_pricenumber
The price of the underlying asset for the contract to break even. For a call, this value is (strike price + premium paid). For a put, this value is (strike price - premium paid).
detailsobject
The details for this contract.
contract_type*enum [put, call, other]
The type of contract. Can be "put", "call", or in some rare cases, "other".
exercise_style*enum [american, european, bermudan]
The exercise style of this contract. See this link for more details on exercise styles.
expiration_date*string
The contract's expiration date in YYYY-MM-DD format.
shares_per_contract*number
The number of shares per contract for this contract.
strike_price*number
The strike price of the option contract.
errorstring
The error while looking for this ticker.
fmvnumber
Fair market value is only available on Business plans. It's it our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
greeksobject
The greeks for this contract. There are certain circumstances where greeks will not be returned, such as options contracts that are deep in the money. See this article for more information.
delta*number
The change in the option's price per $0.01 increment in the price of the underlying asset.
gamma*number
The change in delta per $0.01 change in the price of the underlying asset.
theta*number
The change in the option's price per day.
vega*number
The change in the option's price per 1% increment in volatility.
implied_volatilitynumber
The market's forecast for the volatility of the underlying asset, based on this option's current price.
last_quoteobject
The most recent quote for this contract. This is only returned if your current plan includes quotes.
ask*number
The ask price.
ask_exchangeinteger
The ask side exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
ask_sizenumber
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
bid*number
The bid price.
bid_exchangeinteger
The bid side exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
bid_sizenumber
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
last_updated*integer
The nanosecond timestamp of when this information was updated.
midpointnumber
The average of the bid and ask price.
timeframe*enum [DELAYED, REAL-TIME]
The time relevance of the data.
last_tradeobject
The most recent quote for this contract. This is only returned if your current plan includes trades.
conditionsarray [integer]
A list of condition codes.
exchangeinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
idstring
The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID.
last_updatedinteger
The nanosecond timestamp of when this information was updated.
participant_timestampinteger
The nanosecond Exchange Unix Timestamp. This is the timestamp of when the trade was generated at the exchange.
price*number
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
sip_timestampinteger
The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this trade from the exchange which produced it.
size*integer
The size of a trade (also known as volume).
timeframeenum [DELAYED, REAL-TIME]
The time relevance of the data.
market_statusstring
The market status for the market that trades this ticker. Possible values for stocks, options, crypto, and forex snapshots are open, closed, early_trading, or late_trading. Possible values for indices snapshots are regular_trading, closed, early_trading, and late_trading.
messagestring
The error message while looking for this ticker.
namestring
The name of this contract.
open_interestnumber
The quantity of this contract held at the end of the last trading day.
sessionobject
Comprehensive trading session metrics, detailing price changes, trading volume, and key price points (open, close, high, low) for the asset within the current trading day. Includes specific changes during early, regular, and late trading periods to enable detailed performance analysis and trend tracking.
change*number
The value of the price change for the asset from the previous trading day.
change_percent*number
The percent of the price change for the asset from the previous trading day.
close*number
The closing price of the asset for the day.
early_trading_changenumber
Today's early trading change amount, difference between price and previous close if in early trading hours, otherwise difference between last price during early trading and previous close.
early_trading_change_percentnumber
Today's early trading change as a percentage.
high*number
The highest price of the asset for the day.
late_trading_changenumber
Today's late trading change amount, difference between price and today's close if in late trading hours, otherwise difference between last price during late trading and today's close.
late_trading_change_percentnumber
Today's late trading change as a percentage.
low*number
The lowest price of the asset for the day.
open*number
The open price of the asset for the day.
previous_close*number
The closing price of the asset for the previous trading day.
pricenumber
The price of the most recent trade or bid price for this asset.
regular_trading_changenumber
Today's change in regular trading hours, difference between current price and previous trading day's close, otherwise difference between today's close and previous day's close.
regular_trading_change_percentnumber
Today's regular trading change as a percentage.
volumenumber
The trading volume for the asset for the day.
ticker*string
The ticker symbol for the asset.
typeenum [stocks, options, fx, crypto, indices]
The asset class for this ticker.
underlying_assetobject
Information on the underlying stock for this options contract. The market data returned depends on your current stocks plan.
change_to_break_even*number
The change in price for the contract to break even.
last_updatedinteger
The nanosecond timestamp of when this information was updated.
pricenumber
The price of the trade. This is the actual dollar value per whole share of this trade. A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
ticker*string
The ticker symbol for the contract's underlying asset.
timeframeenum [DELAYED, REAL-TIME]
The time relevance of the data.
valuenumber
The value of the underlying index.
valuenumber
Value of Index.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "abc123",
  "results": [
    {
      "break_even_price": 171.075,
      "details": {
        "contract_type": "call",
        "exercise_style": "american",
        "expiration_date": "2022-10-14",
        "shares_per_contract": 100,
        "strike_price": 5,
        "underlying_ticker": "NCLH"
      },
      "fmv": 0.05,
      "greeks": {
        "delta": 0.5520187372272933,
        "gamma": 0.00706756515659829,
        "theta": -0.018532772783847958,
        "vega": 0.7274811132998142
      },
      "implied_volatility": 0.3048997097864957,
      "last_quote": {
        "ask": 21.25,
        "ask_exchange": 12,
        "ask_size": 110,
        "bid": 20.9,
        "bid_exchange": 10,
        "bid_size": 172,
        "last_updated": 1636573458756383500,
        "midpoint": 21.075,
        "timeframe": "REAL-TIME"
      },
      "last_trade": {
        "conditions": [
          209
        ],
        "exchange": 316,
        "price": 0.05,
        "sip_timestamp": 1675280958783136800,
        "size": 2,
        "timeframe": "REAL-TIME"
      },
      "market_status": "closed",
      "name": "NCLH $5 Call",
      "open_interest": 8921,
      "session": {
        "change": -0.05,
        "change_percent": -1.07,
        "close": 6.65,
        "early_trading_change": -0.01,
        "early_trading_change_percent": -0.03,
        "high": 7.01,
        "late_trading_change": -0.4,
        "late_trading_change_percent": -0.02,
        "low": 5.42,
        "open": 6.7,
        "previous_close": 6.71,
        "regular_trading_change": -0.6,
        "regular_trading_change_percent": -0.5,
        "volume": 67
      },
      "ticker": "O:NCLH221014C00005000",
      "type": "options",
      "underlying_asset": {
        "change_to_break_even": 23.123999999999995,
        "last_updated": 1636573459862384600,
        "price": 147.951,
        "ticker": "AAPL",
        "timeframe": "REAL-TIME"
      }
    },
    {
      "fmv": 0.05,
      "last_minute": {
        "close": 412.05,
        "high": 412.1,
        "low": 412.05,
        "open": 412.1,
        "transactions": 26,
        "volume": 610,
        "vwap": 412.0881
      },
      "last_quote": {
        "ask": 21.25,
        "ask_exchange": 300,
        "ask_size": 110,
        "bid": 20.9,
        "bid_exchange": 323,
        "bid_size": 172,
        "last_updated": 1636573458756383500,
        "timeframe": "REAL-TIME"
      },
      "last_trade": {
        "conditions": [
          209
        ],
        "exchange": 316,
        "id": "4064",
        "last_updated": 1675280958783136800,
        "price": 0.05,
        "size": 2,
        "timeframe": "REAL-TIME"
      },
      "market_status": "closed",
      "name": "Apple Inc.",
      "session": {
        "change": -1.05,
        "change_percent": -4.67,
        "close": 21.4,
        "early_trading_change": -0.39,
        "early_trading_change_percent": -0.07,
        "high": 22.49,
        "late_trading_change": 1.2,
        "late_trading_change_percent": 3.92,
        "low": 21.35,
        "open": 22.49,
        "previous_close": 22.45,
        "volume": 37
      },
      "ticker": "AAPL",
      "type": "stocks"
    },
    {
      "error": "NOT_FOUND",
      "message": "Ticker not found.",
      "ticker": "TSLAAPL"
    }
  ],
  "status": "OK"
}
Simple Moving Average (SMA)
GET
/v1/indicators/sma/{stockTicker}
Get the simple moving average (SMA) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.

series_type

close

The price in the aggregate which will be used to calculate the simple moving average. i.e. 'close' will result in using close prices to calculate the simple moving average (SMA).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/sma/AAPL?timespan=day&adjusted=true&window=50&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/sma/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "aggregates": [
        {
          "c": 75.0875,
          "h": 75.15,
          "l": 73.7975,
          "n": 1,
          "o": 74.06,
          "t": 1577941200000,
          "v": 135647456,
          "vw": 74.6099
        },
        {
          "c": 74.3575,
          "h": 75.145,
          "l": 74.125,
          "n": 1,
          "o": 74.2875,
          "t": 1578027600000,
          "v": 146535512,
          "vw": 74.7026
        }
      ],
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 140.139
      }
    ]
  },
  "status": "OK"
}
Exponential Moving Average (EMA)
GET
/v1/indicators/ema/{stockTicker}
Get the exponential moving average (EMA) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average.

series_type

close

The price in the aggregate which will be used to calculate the exponential moving average. i.e. 'close' will result in using close prices to calculate the exponential moving average (EMA).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/ema/AAPL?timespan=day&adjusted=true&window=50&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/ema/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 140.139
      }
    ]
  },
  "status": "OK"
}
Moving Average Convergence/Divergence (MACD)
GET
/v1/indicators/macd/{stockTicker}
Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

short_window

The short window size used to calculate MACD data.

long_window

The long window size used to calculate MACD data.

signal_window

The window size used to calculate the MACD signal line.

series_type

close

The price in the aggregate which will be used to calculate the MACD. i.e. 'close' will result in using close prices to calculate the MACD.

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/macd/AAPL?timespan=day&adjusted=true&short_window=12&long_window=26&signal_window=9&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
histogramnumber
The indicator value for this period.
signalnumber
The indicator value for this period.
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/macd/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "histogram": 38.3801666667,
        "signal": 106.9811666667,
        "timestamp": 1517562000016,
        "value": 145.3613333333
      },
      {
        "histogram": 41.098859136,
        "signal": 102.7386283473,
        "timestamp": 1517562001016,
        "value": 143.8374874833
      }
    ]
  },
  "status": "OK"
}
Relative Strength Index (RSI)
GET
/v1/indicators/rsi/{stockTicker}
Get the relative strength index (RSI) for a ticker symbol over a given time range.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
stockTicker
*

Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.

timestamp

Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp.


Additional filter parameters

timespan

day

The size of the aggregate time window.

adjusted

true

Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits.

window

The window size used to calculate the relative strength index (RSI).

series_type

close

The price in the aggregate which will be used to calculate the relative strength index. i.e. 'close' will result in using close prices to calculate the relative strength index (RSI).

expand_underlying


Whether or not to include the aggregates used to calculate this indicator in the response.

order

desc

The order in which to return the results, ordered by timestamp.

limit

Limit the number of results returned, default is 10 and max is 5000

https://api.polygon.io/v1/indicators/rsi/AAPL?timespan=day&adjusted=true&window=14&series_type=close&order=desc&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsobject
underlyingobject
aggregatesarray
c*number
The close price for the symbol in the given time period.
h*number
The highest price for the symbol in the given time period.
l*number
The lowest price for the symbol in the given time period.
n*integer
The number of transactions in the aggregate window.
o*number
The open price for the symbol in the given time period.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
t*number
The Unix Msec timestamp for the start of the aggregate window.
v*number
The trading volume of the symbol in the given time period.
vw*number
The volume weighted average price.
urlstring
The URL which can be used to request the underlying aggregates used in this request.
valuesarray
timestampinteger
The Unix Msec timestamp from the last aggregate used in this calculation.
valuenumber
The indicator value for this period.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v1/indicators/rsi/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "a47d1beb8c11b6ae897ab76cdbbf35a3",
  "results": {
    "underlying": {
      "url": "https://api.polygon.io/v2/aggs/ticker/AAPL/range/1/day/2003-01-01/2022-07-25"
    },
    "values": [
      {
        "timestamp": 1517562000016,
        "value": 82.19
      }
    ]
  },
  "status": "OK"
}
Tickers
GET
/v3/reference/tickers
Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
Parameters
ticker

Specify a ticker symbol. Defaults to empty string which queries all tickers.


Additional filter parameters

type


Specify the type of the tickers. Find the types that we support via our Ticker Types API. Defaults to empty string which queries all types.

market


Filter by market type. By default all markets are included.

exchange

Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes at the ISO org website. Defaults to empty string which queries all exchanges.

cusip

Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes at their website. Defaults to empty string which queries all CUSIPs.

Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.

cik

Specify the CIK of the asset you want to search for. Find more information about CIK codes at their website. Defaults to empty string which queries all CIKs.

date


Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date.

search

Search for terms within the ticker and/or company name.

active

true

Specify if the tickers returned should be actively traded on the queried date. Default is true.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 100 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/tickers?active=true&limit=100&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
An array of tickers that match your query.
Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response.
activeboolean
Whether or not the asset is actively traded. False means the asset has been delisted.
cikstring
The CIK number for this ticker. Find more information here.
composite_figistring
The composite OpenFIGI number for this ticker. Find more information here
currency_namestring
The name of the currency that this asset is traded with.
delisted_utcstring
The last date that the asset was traded.
last_updated_utcstring
The information is accurate up to this time.
locale*enum [us, global]
The locale of the asset.
market*enum [stocks, crypto, fx, otc, indices]
The market type of the asset.
name*string
The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
primary_exchangestring
The ISO code of the primary listing exchange for this asset.
share_class_figistring
The share Class OpenFIGI number for this ticker. Find more information here
ticker*string
The exchange symbol that this item is traded under.
typestring
The type of the asset. Find the types that we support via our Ticker Types API.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io/v3/reference/tickers?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "e70013d92930de90e089dc8fa098888e",
  "results": [
    {
      "active": true,
      "cik": "0001090872",
      "composite_figi": "BBG000BWQYZ5",
      "currency_name": "usd",
      "last_updated_utc": "2021-04-25T00:00:00Z",
      "locale": "us",
      "market": "stocks",
      "name": "Agilent Technologies Inc.",
      "primary_exchange": "XNYS",
      "share_class_figi": "BBG001SCTQY4",
      "ticker": "A",
      "type": "CS"
    }
  ],
  "status": "OK"
}
Ticker Details v3
GET
/v3/reference/tickers/{ticker}
Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
Parameters
ticker
*

The ticker symbol of the asset.

date


Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.

For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.

Defaults to the most recent available date.

https://api.polygon.io/v3/reference/tickers/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_idstring
A request id assigned by the server.
resultsobject
Ticker with details.
active*boolean
Whether or not the asset is actively traded. False means the asset has been delisted.
addressobject
address1string
The first line of the company's headquarters address.
address2string
The second line of the company's headquarters address, if applicable.
citystring
The city of the company's headquarters address.
postal_codestring
The postal code of the company's headquarters address.
statestring
The state of the company's headquarters address.
brandingobject
icon_urlstring
A link to this ticker's company's icon. Icon's are generally smaller, square images that represent the company at a glance. Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
logo_urlstring
A link to this ticker's company's logo. Note that you must provide an API key when accessing this URL. See the "Authentication" section at the top of this page for more details.
cikstring
The CIK number for this ticker. Find more information here.
composite_figistring
The composite OpenFIGI number for this ticker. Find more information here
currency_name*string
The name of the currency that this asset is traded with.
delisted_utcstring
The last date that the asset was traded.
descriptionstring
A description of the company and what they do/offer.
homepage_urlstring
The URL of the company's website homepage.
list_datestring
The date that the symbol was first publicly listed in the format YYYY-MM-DD.
locale*enum [us, global]
The locale of the asset.
market*enum [stocks, crypto, fx, otc, indices]
The market type of the asset.
market_capnumber
The most recent close price of the ticker multiplied by weighted outstanding shares.
name*string
The name of the asset. For stocks/equities this will be the companies registered name. For crypto/fx this will be the name of the currency or coin pair.
phone_numberstring
The phone number for the company behind this ticker.
primary_exchangestring
The ISO code of the primary listing exchange for this asset.
round_lotnumber
Round lot size of this security.
share_class_figistring
The share Class OpenFIGI number for this ticker. Find more information here
share_class_shares_outstandingnumber
The recorded number of outstanding shares for this particular share class.
sic_codestring
The standard industrial classification code for this ticker. For a list of SIC Codes, see the SEC's SIC Code List.
sic_descriptionstring
A description of this ticker's SIC code.
ticker*string
The exchange symbol that this item is traded under.
ticker_rootstring
The root of a specified ticker. For example, the root of BRK.A is BRK.
ticker_suffixstring
The suffix of a specified ticker. For example, the suffix of BRK.A is A.
total_employeesnumber
The approximate number of employees for the company.
typestring
The type of the asset. Find the types that we support via our Ticker Types API.
weighted_shares_outstandingnumber
The shares outstanding calculated assuming all shares of other share classes are converted to this share class.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": {
    "active": true,
    "address": {
      "address1": "One Apple Park Way",
      "city": "Cupertino",
      "postal_code": "95014",
      "state": "CA"
    },
    "branding": {
      "icon_url": "https://api.polygon.io/v1/reference/company-branding/d3d3LmFwcGxlLmNvbQ/images/2022-01-10_icon.png",
      "logo_url": "https://api.polygon.io/v1/reference/company-branding/d3d3LmFwcGxlLmNvbQ/images/2022-01-10_logo.svg"
    },
    "cik": "0000320193",
    "composite_figi": "BBG000B9XRY4",
    "currency_name": "usd",
    "description": "Apple designs a wide variety of consumer electronic devices, including smartphones (iPhone), tablets (iPad), PCs (Mac), smartwatches (Apple Watch), AirPods, and TV boxes (Apple TV), among others. The iPhone makes up the majority of Apple's total revenue. In addition, Apple offers its customers a variety of services such as Apple Music, iCloud, Apple Care, Apple TV+, Apple Arcade, Apple Card, and Apple Pay, among others. Apple's products run internally developed software and semiconductors, and the firm is well known for its integration of hardware, software and services. Apple's products are distributed online as well as through company-owned stores and third-party retailers. The company generates roughly 40% of its revenue from the Americas, with the remainder earned internationally.",
    "homepage_url": "https://www.apple.com",
    "list_date": "1980-12-12",
    "locale": "us",
    "market": "stocks",
    "market_cap": 2771126040150,
    "name": "Apple Inc.",
    "phone_number": "(408) 996-1010",
    "primary_exchange": "XNAS",
    "round_lot": 100,
    "share_class_figi": "BBG001S5N8V8",
    "share_class_shares_outstanding": 16406400000,
    "sic_code": "3571",
    "sic_description": "ELECTRONIC COMPUTERS",
    "ticker": "AAPL",
    "ticker_root": "AAPL",
    "total_employees": 154000,
    "type": "CS",
    "weighted_shares_outstanding": 16334371000
  },
  "status": "OK"
}
Ticker Events
GET
/vX/reference/tickers/{id}/events
Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.

This API is experimental.
Parameters
id
*

Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the Ticker Details Endpoint

types

A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types.

https://api.polygon.io/vX/reference/tickers/META/events?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
request_idstring
A request id assigned by the server.
resultsobject
eventsarray [undefined]
namestring
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": {
    "events": [
      {
        "date": "2022-06-09",
        "ticker_change": {
          "ticker": "META"
        },
        "type": "ticker_change"
      },
      {
        "date": "2012-05-18",
        "ticker_change": {
          "ticker": "FB"
        },
        "type": "ticker_change"
      }
    ],
    "name": "Meta Platforms, Inc. Class A Common Stock"
  },
  "status": "OK"
}
Ticker News
GET
/v2/reference/news
Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

published_utc

Return results published on, before, or after this date.


Additional filter parameters

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v2/reference/news?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
amp_urlstring
The mobile friendly Accelerated Mobile Page (AMP) URL.
article_url*string
A link to the news article.
author*string
The article's author.
descriptionstring
A description of the article.
id*string
Unique identifier for the article.
image_urlstring
The article's image URL.
insightsarray
The insights related to the article.
sentiment*enum [positive, neutral, negative]
The sentiment of the insight.
sentiment_reasoning*string
The reasoning behind the sentiment.
ticker*string
The ticker symbol associated with the insight.
keywordsarray [string]
The keywords associated with the article (which will vary depending on the publishing source).
published_utc*string
The date the article was published on.
publisher*object
favicon_urlstring
The publisher's homepage favicon URL.
homepage_url*string
The publisher's homepage URL.
logo_url*string
The publisher's logo URL.
name*string
The publisher's name.
tickers*array [string]
The ticker symbols associated with the article.
title*string
The title of the news article.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io:443/v2/reference/news?cursor=eyJsaW1pdCI6MSwic29ydCI6InB1Ymxpc2hlZF91dGMiLCJvcmRlciI6ImFzY2VuZGluZyIsInRpY2tlciI6e30sInB1Ymxpc2hlZF91dGMiOnsiZ3RlIjoiMjAyMS0wNC0yNiJ9LCJzZWFyY2hfYWZ0ZXIiOlsxNjE5NDA0Mzk3MDAwLG51bGxdfQ",
  "request_id": "831afdb0b8078549fed053476984947a",
  "results": [
    {
      "amp_url": "https://m.uk.investing.com/news/stock-market-news/markets-are-underestimating-fed-cuts-ubs-3559968?ampMode=1",
      "article_url": "https://uk.investing.com/news/stock-market-news/markets-are-underestimating-fed-cuts-ubs-3559968",
      "author": "Sam Boughedda",
      "description": "UBS analysts warn that markets are underestimating the extent of future interest rate cuts by the Federal Reserve, as the weakening economy is likely to justify more cuts than currently anticipated.",
      "id": "8ec638777ca03b553ae516761c2a22ba2fdd2f37befae3ab6fdab74e9e5193eb",
      "image_url": "https://i-invdn-com.investing.com/news/LYNXNPEC4I0AL_L.jpg",
      "insights": [
        {
          "sentiment": "positive",
          "sentiment_reasoning": "UBS analysts are providing a bullish outlook on the extent of future Federal Reserve rate cuts, suggesting that markets are underestimating the number of cuts that will occur.",
          "ticker": "UBS"
        }
      ],
      "keywords": [
        "Federal Reserve",
        "interest rates",
        "economic data"
      ],
      "published_utc": "2024-06-24T18:33:53Z",
      "publisher": {
        "favicon_url": "https://s3.polygon.io/public/assets/news/favicons/investing.ico",
        "homepage_url": "https://www.investing.com/",
        "logo_url": "https://s3.polygon.io/public/assets/news/logos/investing.png",
        "name": "Investing.com"
      },
      "tickers": [
        "UBS"
      ],
      "title": "Markets are underestimating Fed cuts: UBS By Investing.com - Investing.com UK"
    }
  ],
  "status": "OK"
}
Ticker Types
GET
/v3/reference/tickers/types
List all ticker types that Polygon.io has.
Parameters
asset_class

stocks

Filter by asset class.

locale


Filter by locale.

https://api.polygon.io/v3/reference/tickers/types?asset_class=stocks&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_id*string
A request ID assigned by the server.
resultsarray
asset_class*enum [stocks, options, crypto, fx, indices]
An identifier for a group of similar financial instruments.
code*string
A code used by Polygon.io to refer to this ticker type.
description*string
A short description of this ticker type.
locale*enum [us, global]
An identifier for a geographical location.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "asset_class": "stocks",
      "code": "CS",
      "description": "Common Stock",
      "locale": "us"
    }
  ],
  "status": "OK"
}
Market Holidays
GET
/v1/marketstatus/upcoming
Get upcoming market holidays and their open/close times.
https://api.polygon.io/v1/marketstatus/upcoming?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
responsearray
closestring
The market close time on the holiday (if it's not closed).
datestring
The date of the holiday.
exchangestring
Which market the record is for.
namestring
The name of the holiday.
openstring
The market open time on the holiday (if it's not closed).
statusstring
The status of the market on the holiday.
Was this helpful?
Help us improve


Yes


No
Response Object
[
  {
    "date": "2020-11-26",
    "exchange": "NYSE",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "date": "2020-11-26",
    "exchange": "NASDAQ",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "date": "2020-11-26",
    "exchange": "OTC",
    "name": "Thanksgiving",
    "status": "closed"
  },
  {
    "close": "2020-11-27T18:00:00.000Z",
    "date": "2020-11-27",
    "exchange": "NASDAQ",
    "name": "Thanksgiving",
    "open": "2020-11-27T14:30:00.000Z",
    "status": "early-close"
  },
  {
    "close": "2020-11-27T18:00:00.000Z",
    "date": "2020-11-27",
    "exchange": "NYSE",
    "name": "Thanksgiving",
    "open": "2020-11-27T14:30:00.000Z",
    "status": "early-close"
  }
]
Market Status
GET
/v1/marketstatus/now
Get the current trading status of the exchanges and overall financial markets.
https://api.polygon.io/v1/marketstatus/now?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
afterHoursboolean
Whether or not the market is in post-market hours.
currenciesobject
cryptostring
The status of the crypto market.
fxstring
The status of the forex market.
earlyHoursboolean
Whether or not the market is in pre-market hours.
exchangesobject
nasdaqstring
The status of the Nasdaq market.
nysestring
The status of the NYSE market.
otcstring
The status of the OTC market.
indicesGroupsobject
cccystring
The status of Cboe Streaming Market Indices Cryptocurrency ("CCCY") indices trading hours.
cgistring
The status of Cboe Global Indices ("CGI") trading hours.
dow_jonesstring
The status of Dow Jones indices trading hours
ftse_russellstring
The status of Financial Times Stock Exchange Group ("FTSE") Russell indices trading hours.
mscistring
The status of Morgan Stanley Capital International ("MSCI") indices trading hours.
mstarstring
The status of Morningstar ("MSTAR") indices trading hours.
mstarc
The status of Morningstar Customer ("MSTARC") indices trading hours.
nasdaqstring
The status of National Association of Securities Dealers Automated Quotations ("Nasdaq") indices trading hours.
s_and_pstring
The status of Standard & Poors's ("S&P") indices trading hours.
societe_generalestring
The status of Societe Generale indices trading hours.
marketstring
The status of the market as a whole.
serverTimestring
The current time of the server, returned as a date-time in RFC3339 format.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "afterHours": true,
  "currencies": {
    "crypto": "open",
    "fx": "open"
  },
  "earlyHours": false,
  "exchanges": {
    "nasdaq": "extended-hours",
    "nyse": "extended-hours",
    "otc": "closed"
  },
  "market": "extended-hours",
  "serverTime": "2020-11-10T17:37:37-05:00"
}
Stock Splits v3
GET
/v3/reference/splits
Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

execution_date


Query by execution date with the format YYYY-MM-DD.


Additional filter parameters

reverse_split


Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/splits?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
resultsarray
execution_date*string
The execution date of the stock split. On this date the stock split was applied.
id*string
The unique identifier for this stock split.
split_from*number
The second number in the split ratio.
For example: In a 2-for-1 split, split_from would be 1.
split_to*number
The first number in the split ratio.
For example: In a 2-for-1 split, split_to would be 2.
ticker*string
The ticker symbol of the stock split.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/splits/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "results": [
    {
      "execution_date": "2020-08-31",
      "id": "E36416cce743c3964c5da63e1ef1626c0aece30fb47302eea5a49c0055c04e8d0",
      "split_from": 1,
      "split_to": 4,
      "ticker": "AAPL"
    },
    {
      "execution_date": "2005-02-28",
      "id": "E90a77bdf742661741ed7c8fc086415f0457c2816c45899d73aaa88bdc8ff6025",
      "split_from": 1,
      "split_to": 2,
      "ticker": "AAPL"
    }
  ],
  "status": "OK"
}
Dividends v3
GET
/v3/reference/dividends
Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.


Additional filter parameters

ex_dividend_date


Query by ex-dividend date with the format YYYY-MM-DD.


Additional filter parameters

record_date


Query by record date with the format YYYY-MM-DD.


Additional filter parameters

declaration_date


Query by declaration date with the format YYYY-MM-DD.


Additional filter parameters

pay_date


Query by pay date with the format YYYY-MM-DD.


Additional filter parameters

frequency


Query by the number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), and 12 (monthly).

cash_amount

Query by the cash amount of the dividend.


Additional filter parameters

dividend_type


Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/dividends?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
resultsarray
cash_amount*number
The cash amount of the dividend per share owned.
currencystring
The currency in which the dividend is paid.
declaration_datestring
The date that the dividend was announced.
dividend_type*enum [CD, SC, LT, ST]
The type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. Long-Term and Short-Term capital gain distributions are denoted as LT and ST, respectively.
ex_dividend_date*string
The date that the stock first trades without the dividend, determined by the exchange.
frequency*integer
The number of times per year the dividend is paid out. Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), and 12 (monthly).
id*string
The unique identifier of the dividend.
pay_datestring
The date that the dividend is paid out.
record_datestring
The date that the stock must be held to receive the dividend, set by the company.
ticker*string
The ticker symbol of the dividend.
statusstring
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/v3/reference/dividends/AAPL?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "results": [
    {
      "cash_amount": 0.22,
      "declaration_date": "2021-10-28",
      "dividend_type": "CD",
      "ex_dividend_date": "2021-11-05",
      "frequency": 4,
      "id": "E8e3c4f794613e9205e2f178a36c53fcc57cdabb55e1988c87b33f9e52e221444",
      "pay_date": "2021-11-11",
      "record_date": "2021-11-08",
      "ticker": "AAPL"
    },
    {
      "cash_amount": 0.22,
      "declaration_date": "2021-07-27",
      "dividend_type": "CD",
      "ex_dividend_date": "2021-08-06",
      "frequency": 4,
      "id": "E6436c5475706773f03490acf0b63fdb90b2c72bfeed329a6eb4afc080acd80ae",
      "pay_date": "2021-08-12",
      "record_date": "2021-08-09",
      "ticker": "AAPL"
    }
  ],
  "status": "OK"
}
Stock Financials vX
GET
/vX/reference/financials
Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined here.

This API is experimental.
Parameters
ticker

Query by company ticker.

cik

Query by central index key (CIK) Number

company_name

Query by company name.


Additional filter parameters

sic

Query by standard industrial classification (SIC)

filing_date


Query by the date when the filing with financials data was filed in YYYY-MM-DD format.

Best used when querying over date ranges to find financials based on filings that happen in a time period.

Examples:

To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte=2009-01-01

To get financials based on filings that happened in the year 2009 use the query params filing_date.gte=2009-01-01&filing_date.lt=2010-01-01


Additional filter parameters

period_of_report_date


The period of report for the filing with financials data in YYYY-MM-DD format.


Additional filter parameters

timeframe


Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4

include_sources


Whether or not to include the xpath and formula attributes for each financial data point. See the xpath and formula response attributes for more info. False by default.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 100.

sort


Sort field used for ordering.

https://api.polygon.io/vX/reference/financials?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
count*integer
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request id assigned by the server.
results*array
acceptance_datetime
The datetime (EST timezone) the filing was accepted by EDGAR in YYYYMMDDHHMMSS format.
cik*string
The CIK number for the company.
company_name*string
The company name.
end_datestring
The end date of the period that these financials cover in YYYYMMDD format.
filing_date
The date that the SEC filing which these financials were derived from was made available. Note that this is not necessarily the date when this information became public, as some companies may publish a press release before filing with the SEC.
financials*object
balance_sheetobject
Balance sheet. The keys in this object can be any of the fields listed in the Balance Sheet section of the financials API glossary of terms.
*object
An individual financial data point.
derived_fromarray [string]
The list of report IDs (or errata) which were used to derive this data point. This value is only returned for data points taken directly from XBRL when the include_sources query parameter is true and if source is SourceInterReportDerived.
formulastring
The name of the formula used to derive this data point from other financial data points. Information about the formulas can be found here. This value is only returned for data points that are not explicitly expressed within the XBRL source file when the include_sources query parameter is true and if source is SourceIntraReportImpute.
label*string
A human readable label for the financial data point.
order*integer
An indicator of what order within the statement that you would find this data point.
source
The source where this data point came from. This will be one of: SourceDirectReport, SourceIntraReportImpute or SourceInterReportDerived.
unit*string
The unit of the financial data point.
value*number
The value of the financial data point.
xpathstring
The XPath 1.0 query that identifies the fact from within the XBRL source file. This value is only returned for data points taken directly from XBRL when the include_sources query parameter is true and if source is SourceDirectReport.
cash_flow_statementobject
Cash flow statement. The keys in this object can be any of the fields listed in the Cash Flow Statement section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
comprehensive_incomeobject
Comprehensive income. The keys in this object can be any of the fields listed in the Comprehensive Income section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
income_statementobject
Income statement. The keys in this object can be any of the fields listed in the Income Statement section of the financials API glossary of terms. See the attributes of the objects within balance_sheet for more details.
fiscal_period*string
Fiscal period of the report according to the company (Q1, Q2, Q3, Q4, or FY).
fiscal_yearstring
Fiscal year of the report according to the company.
source_filing_file_url
The URL of the specific XBRL instance document within the SEC filing that these financials were derived from.
source_filing_urlstring
The URL of the SEC filing that these financials were derived from.
start_datestring
The start date of the period that these financials cover in YYYYMMDD format.
tickersarray [string]
The list of ticker symbols for the company.
timeframe*string
The timeframe of the report (quarterly, annual or ttm).
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "next_url": "https://api.polygon.io/vX/reference/financials?",
  "request_id": "55eb92ed43b25568ab0cce159830ea34",
  "results": [
    {
      "cik": "0001650729",
      "company_name": "SiteOne Landscape Supply, Inc.",
      "end_date": "2022-04-03",
      "filing_date": "2022-05-04",
      "financials": {
        "balance_sheet": {
          "assets": {
            "label": "Assets",
            "order": 100,
            "unit": "USD",
            "value": 2407400000
          },
          "current_assets": {
            "label": "Current Assets",
            "order": 200,
            "unit": "USD",
            "value": 1385900000
          },
          "current_liabilities": {
            "label": "Current Liabilities",
            "order": 700,
            "unit": "USD",
            "value": 597500000
          },
          "equity": {
            "label": "Equity",
            "order": 1400,
            "unit": "USD",
            "value": 1099200000
          },
          "equity_attributable_to_noncontrolling_interest": {
            "label": "Equity Attributable To Noncontrolling Interest",
            "order": 1500,
            "unit": "USD",
            "value": 0
          },
          "equity_attributable_to_parent": {
            "label": "Equity Attributable To Parent",
            "order": 1600,
            "unit": "USD",
            "value": 1099200000
          },
          "liabilities": {
            "label": "Liabilities",
            "order": 600,
            "unit": "USD",
            "value": 1308200000
          },
          "liabilities_and_equity": {
            "label": "Liabilities And Equity",
            "order": 1900,
            "unit": "USD",
            "value": 2407400000
          },
          "noncurrent_assets": {
            "label": "Noncurrent Assets",
            "order": 300,
            "unit": "USD",
            "value": 1021500000
          },
          "noncurrent_liabilities": {
            "label": "Noncurrent Liabilities",
            "order": 800,
            "unit": "USD",
            "value": 710700000
          }
        },
        "cash_flow_statement": {
          "exchange_gains_losses": {
            "label": "Exchange Gains/Losses",
            "order": 1000,
            "unit": "USD",
            "value": 100000
          },
          "net_cash_flow": {
            "label": "Net Cash Flow",
            "order": 1100,
            "unit": "USD",
            "value": -8600000
          },
          "net_cash_flow_continuing": {
            "label": "Net Cash Flow, Continuing",
            "order": 1200,
            "unit": "USD",
            "value": -8700000
          },
          "net_cash_flow_from_financing_activities": {
            "label": "Net Cash Flow From Financing Activities",
            "order": 700,
            "unit": "USD",
            "value": 150600000
          },
          "net_cash_flow_from_financing_activities_continuing": {
            "label": "Net Cash Flow From Financing Activities, Continuing",
            "order": 800,
            "unit": "USD",
            "value": 150600000
          },
          "net_cash_flow_from_investing_activities": {
            "label": "Net Cash Flow From Investing Activities",
            "order": 400,
            "unit": "USD",
            "value": -41000000
          },
          "net_cash_flow_from_investing_activities_continuing": {
            "label": "Net Cash Flow From Investing Activities, Continuing",
            "order": 500,
            "unit": "USD",
            "value": -41000000
          },
          "net_cash_flow_from_operating_activities": {
            "label": "Net Cash Flow From Operating Activities",
            "order": 100,
            "unit": "USD",
            "value": -118300000
          },
          "net_cash_flow_from_operating_activities_continuing": {
            "label": "Net Cash Flow From Operating Activities, Continuing",
            "order": 200,
            "unit": "USD",
            "value": -118300000
          }
        },
        "comprehensive_income": {
          "comprehensive_income_loss": {
            "label": "Comprehensive Income/Loss",
            "order": 100,
            "unit": "USD",
            "value": 40500000
          },
          "comprehensive_income_loss_attributable_to_noncontrolling_interest": {
            "label": "Comprehensive Income/Loss Attributable To Noncontrolling Interest",
            "order": 200,
            "unit": "USD",
            "value": 0
          },
          "comprehensive_income_loss_attributable_to_parent": {
            "label": "Comprehensive Income/Loss Attributable To Parent",
            "order": 300,
            "unit": "USD",
            "value": 40500000
          },
          "other_comprehensive_income_loss": {
            "label": "Other Comprehensive Income/Loss",
            "order": 400,
            "unit": "USD",
            "value": 40500000
          },
          "other_comprehensive_income_loss_attributable_to_parent": {
            "label": "Other Comprehensive Income/Loss Attributable To Parent",
            "order": 600,
            "unit": "USD",
            "value": 8200000
          }
        },
        "income_statement": {
          "basic_earnings_per_share": {
            "label": "Basic Earnings Per Share",
            "order": 4200,
            "unit": "USD / shares",
            "value": 0.72
          },
          "benefits_costs_expenses": {
            "label": "Benefits Costs and Expenses",
            "order": 200,
            "unit": "USD",
            "value": 768400000
          },
          "cost_of_revenue": {
            "label": "Cost Of Revenue",
            "order": 300,
            "unit": "USD",
            "value": 536100000
          },
          "costs_and_expenses": {
            "label": "Costs And Expenses",
            "order": 600,
            "unit": "USD",
            "value": 768400000
          },
          "diluted_earnings_per_share": {
            "label": "Diluted Earnings Per Share",
            "order": 4300,
            "unit": "USD / shares",
            "value": 0.7
          },
          "gross_profit": {
            "label": "Gross Profit",
            "order": 800,
            "unit": "USD",
            "value": 269200000
          },
          "income_loss_from_continuing_operations_after_tax": {
            "label": "Income/Loss From Continuing Operations After Tax",
            "order": 1400,
            "unit": "USD",
            "value": 32300000
          },
          "income_loss_from_continuing_operations_before_tax": {
            "label": "Income/Loss From Continuing Operations Before Tax",
            "order": 1500,
            "unit": "USD",
            "value": 36900000
          },
          "income_tax_expense_benefit": {
            "label": "Income Tax Expense/Benefit",
            "order": 2200,
            "unit": "USD",
            "value": 4600000
          },
          "interest_expense_operating": {
            "label": "Interest Expense, Operating",
            "order": 2700,
            "unit": "USD",
            "value": 4300000
          },
          "net_income_loss": {
            "label": "Net Income/Loss",
            "order": 3200,
            "unit": "USD",
            "value": 32300000
          },
          "net_income_loss_attributable_to_noncontrolling_interest": {
            "label": "Net Income/Loss Attributable To Noncontrolling Interest",
            "order": 3300,
            "unit": "USD",
            "value": 0
          },
          "net_income_loss_attributable_to_parent": {
            "label": "Net Income/Loss Attributable To Parent",
            "order": 3500,
            "unit": "USD",
            "value": 32300000
          },
          "net_income_loss_available_to_common_stockholders_basic": {
            "label": "Net Income/Loss Available To Common Stockholders, Basic",
            "order": 3700,
            "unit": "USD",
            "value": 32300000
          },
          "operating_expenses": {
            "label": "Operating Expenses",
            "order": 1000,
            "unit": "USD",
            "value": 228000000
          },
          "operating_income_loss": {
            "label": "Operating Income/Loss",
            "order": 1100,
            "unit": "USD",
            "value": 41200000
          },
          "participating_securities_distributed_and_undistributed_earnings_loss_basic": {
            "label": "Participating Securities, Distributed And Undistributed Earnings/Loss, Basic",
            "order": 3800,
            "unit": "USD",
            "value": 0
          },
          "preferred_stock_dividends_and_other_adjustments": {
            "label": "Preferred Stock Dividends And Other Adjustments",
            "order": 3900,
            "unit": "USD",
            "value": 0
          },
          "revenues": {
            "label": "Revenues",
            "order": 100,
            "unit": "USD",
            "value": 805300000
          }
        }
      },
      "fiscal_period": "Q1",
      "fiscal_year": "2022",
      "source_filing_file_url": "https://api.polygon.io/v1/reference/sec/filings/0001650729-22-000010/files/site-20220403_htm.xml",
      "source_filing_url": "https://api.polygon.io/v1/reference/sec/filings/0001650729-22-000010",
      "start_date": "2022-01-03"
    }
  ],
  "status": "OK"
}
Conditions
GET
/v3/reference/conditions
List all conditions that Polygon.io uses.
Parameters
asset_class

stocks

Filter for conditions within a given asset class.

data_type


Filter by data type.

id

Filter for conditions with a given ID.

sip


Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/v3/reference/conditions?asset_class=stocks&limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
count*integer
The total number of results for this request.
next_urlstring
If present, this value can be used to fetch the next page of data.
request_id*string
A request ID assigned by the server.
results*array
An array of conditions that match your query.
abbreviationstring
A commonly-used abbreviation for this condition.
asset_class*enum [stocks, options, crypto, fx]
An identifier for a group of similar financial instruments.
data_types*array [string]
Data types that this condition applies to.
descriptionstring
A short description of the semantics of this condition.
exchangeinteger
If present, mapping this condition from a Polygon.io code to a SIP symbol depends on this attribute. In other words, data with this condition attached comes exclusively from the given exchange.
id*integer
An identifier used by Polygon.io for this condition. Unique per data type.
legacyboolean
If true, this condition is from an old version of the SIPs' specs and no longer is used. Other conditions may or may not reuse the same symbol as this one.
name*string
The name of this condition.
sip_mapping*object
A mapping to a symbol for each SIP that has this condition.
CTAstring
OPRAstring
UTPstring
type*enum [sale_condition, quote_condition, sip_generated_flag, financial_status_indicator, short_sale_restriction_indicator, settlement_condition, market_condition, trade_thru_exempt]
An identifier for a collection of related conditions.
update_rulesobject
A list of aggregation rules.
consolidated*object
Describes aggregation rules on a consolidated (all exchanges) basis.
updates_high_low*boolean
Whether or not trades with this condition update the high/low.
updates_open_close*boolean
Whether or not trades with this condition update the open/close.
updates_volume*boolean
Whether or not trades with this condition update the volume.
market_center*object
Describes aggregation rules on a per-market-center basis.
updates_high_low*boolean
Whether or not trades with this condition update the high/low.
updates_open_close*boolean
Whether or not trades with this condition update the open/close.
updates_volume*boolean
Whether or not trades with this condition update the volume.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "asset_class": "stocks",
      "data_types": [
        "trade"
      ],
      "id": 2,
      "name": "Average Price Trade",
      "sip_mapping": {
        "CTA": "B",
        "UTP": "W"
      },
      "type": "condition",
      "update_rules": {
        "consolidated": {
          "updates_high_low": false,
          "updates_open_close": false,
          "updates_volume": true
        },
        "market_center": {
          "updates_high_low": false,
          "updates_open_close": false,
          "updates_volume": true
        }
      }
    }
  ],
  "status": "OK"
}
Exchanges
GET
/v3/reference/exchanges
List all exchanges that Polygon.io knows about.
Parameters
asset_class

stocks

Filter by asset class.

locale


Filter by locale.

https://api.polygon.io/v3/reference/exchanges?asset_class=stocks&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

JSON


Run Query
Response Attributes
countinteger
The total number of results for this request.
request_id*string
A request ID assigned by the server.
resultsarray
acronymstring
A commonly used abbreviation for this exchange.
asset_class*enum [stocks, options, crypto, fx]
An identifier for a group of similar financial instruments.
id*integer
A unique identifier used by Polygon.io for this exchange.
locale*enum [us, global]
An identifier for a geographical location.
micstring
The Market Identifier Code of this exchange (see ISO 10383).
name*string
Name of this exchange.
operating_micstring
The MIC of the entity that operates this exchange.
participant_idstring
The ID used by SIP's to represent this exchange.
type*enum [exchange, TRF, SIP]
Represents the type of exchange.
urlstring
A link to this exchange's website, if one exists.
status*string
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "count": 1,
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "acronym": "AMEX",
      "asset_class": "stocks",
      "id": 1,
      "locale": "us",
      "mic": "XASE",
      "name": "NYSE American, LLC",
      "operating_mic": "XNYS",
      "participant_id": "A",
      "type": "exchange",
      "url": "https://www.nyse.com/markets/nyse-american"
    }
  ],
  "status": "OK"
}
Related Companies
GET
/v1/related-companies/{ticker}
Get a list of tickers related to the queried ticker based on News and Returns data.
Parameters
ticker
*

The ticker symbol to search.

https://api.polygon.io/v1/related-companies/AAPL?apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
request_idstring
A request id assigned by the server.
resultsarray
ticker*string
A ticker related to the requested ticker.
statusstring
The status of this request's response.
tickerstring
The ticker being queried.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "request_id": "31d59dda-80e5-4721-8496-d0d32a654afe",
  "results": [
    {
      "ticker": "MSFT"
    },
    {
      "ticker": "GOOGL"
    },
    {
      "ticker": "AMZN"
    },
    {
      "ticker": "FB"
    },
    {
      "ticker": "TSLA"
    },
    {
      "ticker": "NVDA"
    },
    {
      "ticker": "INTC"
    },
    {
      "ticker": "ADBE"
    },
    {
      "ticker": "NFLX"
    },
    {
      "ticker": "PYPL"
    }
  ],
  "status": "OK",
  "stock_symbol": "AAPL"
}
IPOs
GET
/vX/reference/ipos
The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
Parameters
ticker

Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.

us_code

Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.

isin

Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world.

listing_date


Specify a listing date. This is the first trading date for the newly listed entity.


Additional filter parameters

ipo_status


Specify an IPO status.

order


Order results based on the sort field.

limit

Limit the number of results returned, default is 10 and max is 1000.

sort


Sort field used for ordering.

https://api.polygon.io/vX/reference/ipos?limit=10&apiKey=p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5

Copy

Run Query
Response Attributes
next_urlstring
If present, this value can be used to fetch the next page of data.
request_idstring
A request id assigned by the server.
resultsarray
An array of results containing the requested data.
announced_datestring
The date when the IPO event was announced.
currency_codestring
Underlying currency of the security.
final_issue_pricenumber
The price set by the company and its underwriters before the IPO goes live.
highest_offer_pricenumber
The highest price within the IPO price range that the company might use to price the shares.
ipo_status*enum [direct_listing_process, history, new, pending, postponed, rumor, withdrawn]
The status of the IPO event. IPO events start out as status "rumor" or "pending". On listing day, the status changes to "new". After the listing day, the status changes to "history".
The status "direct_listing_process" corresponds to a type of offering where, instead of going through all the IPO processes, the company decides to list its shares directly on an exchange, without using an investment bank or other intermediaries. This is called a direct listing, direct placement, or direct public offering (DPO).
isinstring
International Securities Identification Number. This is a unique twelve-digit code that is assigned to every security issuance in the world.
issuer_name*string
Name of issuer.
last_updated*string
The date when the IPO event was last modified.
listing_datestring
First trading date for the newly listed entity.
lot_sizenumber
The minimum number of shares that can be bought or sold in a single transaction.
lowest_offer_pricenumber
The lowest price within the IPO price range that the company is willing to offer its shares to investors.
max_shares_offerednumber
The upper limit of the shares that the company is offering to investors.
min_shares_offerednumber
The lower limit of shares that the company is willing to sell in the IPO.
primary_exchangestring
Market Identifier Code (MIC) of the primary exchange where the security is listed. The Market Identifier Code (MIC) (ISO 10383) is a unique identification code used to identify securities trading exchanges, regulated and non-regulated trading markets.
security_descriptionstring
Description of the security.
security_type*string
The classification of the stock. For example, "CS" stands for Common Stock.
shares_outstandingnumber
The total number of shares that the company has issued and are held by investors.
ticker*string
The ticker symbol of the IPO event.
total_offer_sizenumber
The total amount raised by the company for IPO.
us_codestring
This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades.
statusstring
The status of this request's response.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "next_url": "https://api.polygon.io/vX/reference/ipos?cursor=YWN0aXZlPXRydWUmZGF0ZT0yMDIxLTA0LTI1JmxpbWl0PTEmb3JkZXI9YXNjJnBhZ2VfbWFya2VyPUElN0M5YWRjMjY0ZTgyM2E1ZjBiOGUyNDc5YmZiOGE1YmYwNDVkYzU0YjgwMDcyMWE2YmI1ZjBjMjQwMjU4MjFmNGZiJnNvcnQ9dGlja2Vy",
  "request_id": "6a7e466379af0a71039d60cc78e72282",
  "results": [
    {
      "announced_date": "2024-06-01",
      "currency_code": "USD",
      "final_issue_price": 17,
      "highest_offer_price": 17,
      "ipo_status": "history",
      "isin": "US75383L1026",
      "issue_end_date": "2024-06-06",
      "issue_start_date": "2024-06-01",
      "issuer_name": "Rapport Therapeutics Inc.",
      "last_updated": "2024-06-27",
      "listing_date": "2024-06-07",
      "lot_size": 100,
      "lowest_offer_price": 17,
      "max_shares_offered": 8000000,
      "min_shares_offered": 1000000,
      "primary_exchange": "XNAS",
      "security_description": "Ordinary Shares",
      "security_type": "CS",
      "shares_outstanding": 35376457,
      "ticker": "RAPP",
      "total_offer_size": 136000000,
      "us_code": "75383L102"
    }
  ],
  "status": "OK"
}
Stocks WebSocket Documentation

The Polygon.io Stocks WebSocket API provides streaming access to the latest stock market data from all US stock exchanges. You can specify which channels you want to consume by sending instructions in the form of actions. Our WebSockets emit events to notify you when an event has occurred in a channel you've subscribed to.
Our WebSocket APIs are based on entitlements that control which WebSocket Clusters you can connect to and which kinds of data you can access. Examples in these docs include your API key, which only you can see, and are personalized based on your entitlements.
Step 1: Connect
Your current plan includes 1 connection to wss://delayed.polygon.io/stocks. If you attempt additional connections, the existing connection will be disconnected. If you need more simultaneous connections to this cluster, you can contact support.
Connecting to a cluster:
Delayed:wscat -c wss://delayed.polygon.io/stocks

Copy
On connection you will receive the following message:
[{
	"ev":"status",
	"status":"connected",
	"message": "Connected Successfully"
}]
Step 2: Authenticate
You must authenticate before you can make any other requests.
{"action":"auth","params":"p5uw0M64vyHqG_Xp3TNcQxC0EO09Q9c5"}

Copy
On successful authentication you will receive the following message:
[{
	"ev":"status",
	"status":"auth_success",
	"message": "authenticated"
}]
Step 3: Subscribe
Once authenticated, you can request a stream. You can request multiple streams in the same request.
{"action":"subscribe","params":"AM.LPL"}

Copy
You can also request multiple streams from the same cluster.
{"action":"subscribe","params":"AM.LPL,AM.MSFT"}

Copy
Usage
Things happen very quickly in the world of finance, which means a Polygon.io WebSocket client must be able to handle many incoming messages per second. Due to the nature of the WebSocket protocol, if a client is slow to consume messages from the server, Polygon.io's server must buffer messages and send them only as fast as the client can consume them. To help prevent the message buffer from getting too long, Polygon.io may send more than one JSON object in a single WebSocket message. We accomplish this by wrapping all messages in a JSON array, and adding more objects to the array if the message buffer is getting longer. For example, consider a WebSocket message with a single trade event in it:
[
    {"ev":"T","sym":"MSFT","i":"50578","x":4,"p":215.9721,"s":100,"t":1611082428813,"z":3}
]
If your client is consuming a bit slow, or 2+ events happened in very short succession, you may receive a single WebSocket message with more than one event inside it, like this:
[
    {"ev":"T","sym":"MSFT","i":"50578","x":4,"p":215.9721,"s":100,"t":1611082428813,"z":3}, 
    {"ev":"T","sym":"MSFT","i":"12856","x":4,"p":215.989,"s":1,"c":[37],"t":1611082428814,"z":3}
]
Note that if a client is consuming messages too slowly for too long, Polygon.io's server-side buffer may get too large. If that happens, Polygon.io will terminate the WebSocket connection. You can check your account dashboard to see if a connection was terminated as a slow consumer. If this happens to you consistently, consider subscribing to fewer symbols or channels.
Your Plan
Stocks Starter

15-minute Delayed Data

1 Stocks Cluster Connection
Manage Subscription
Client Libraries
Python Logo
Python
client-python
Go Logo
Go
client-go
Javascript Logo
Javascript
client-js
PHP Logo
PHP
client-php
Kotlin Logo
Kotlin
client-jvm
Aggregates (Per Minute)
WS
Delayed:wss://delayed.polygon.io/stocks
Stream real-time minute aggregates for a given stock ticker symbol.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"AM.*"}

Copy
Response Attributes
evenum [AM]
The event type.
symstring
The ticker symbol for the given stock.
vinteger
The tick volume.
avinteger
Today's accumulated volume.
opnumber
Today's official opening price.
vwnumber
The tick's volume weighted average price.
onumber
The opening tick price for this aggregate window.
cnumber
The closing tick price for this aggregate window.
hnumber
The highest tick price for this aggregate window.
lnumber
The lowest tick price for this aggregate window.
anumber
Today's volume weighted average price.
zinteger
The average trade size for this aggregate window.
sinteger
The start timestamp of this aggregate window in Unix Milliseconds.
einteger
The end timestamp of this aggregate window in Unix Milliseconds.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "AM",
  "sym": "GTE",
  "v": 4110,
  "av": 9470157,
  "op": 0.4372,
  "vw": 0.4488,
  "o": 0.4488,
  "c": 0.4486,
  "h": 0.4489,
  "l": 0.4486,
  "a": 0.4352,
  "z": 685,
  "s": 1610144640000,
  "e": 1610144700000
}
Aggregates (Per Second)
WS
Delayed:wss://delayed.polygon.io/stocks
Stream real-time second aggregates for a given stock ticker symbol.

Data is 15-minutes delayed, upgrade to access real-time data.
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"A.*"}

Copy
Response Attributes
evenum [A]
The event type.
symstring
The ticker symbol for the given stock.
vinteger
The tick volume.
avinteger
Today's accumulated volume.
opnumber
Today's official opening price.
vwnumber
The tick's volume weighted average price.
onumber
The opening tick price for this aggregate window.
cnumber
The closing tick price for this aggregate window.
hnumber
The highest tick price for this aggregate window.
lnumber
The lowest tick price for this aggregate window.
anumber
Today's volume weighted average price.
zinteger
The average trade size for this aggregate window.
sinteger
The start timestamp of this aggregate window in Unix Milliseconds.
einteger
The end timestamp of this aggregate window in Unix Milliseconds.
otcboolean
Whether or not this aggregate is for an OTC ticker. This field will be left off if false.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "A",
  "sym": "SPCE",
  "v": 200,
  "av": 8642007,
  "op": 25.66,
  "vw": 25.3981,
  "o": 25.39,
  "c": 25.39,
  "h": 25.39,
  "l": 25.39,
  "a": 25.3714,
  "z": 50,
  "s": 1610144868000,
  "e": 1610144869000
}
Trades
WS
Delayed:wss://delayed.polygon.io/stocks
Real-Time:wss://socket.polygon.io/stocks
Stream real-time trades for a given stock ticker symbol.

Requires a "Stocks Developer" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"T.*"}

Copy
Response Attributes
evenum [T]
The event type.
symstring
The ticker symbol for the given stock.
xinteger
The exchange ID. See Exchanges for Polygon.io's mapping of exchange IDs.
istring
The trade ID.
zinteger
The tape. (1 = NYSE, 2 = AMEX, 3 = Nasdaq).
pnumber
The price.
sinteger
The trade size.
carray [integer]
The trade conditions. See Conditions and Indicators for Polygon.io's trade conditions glossary.
tinteger
The SIP timestamp in Unix MS.
qinteger
The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11).
trfiinteger
The ID for the Trade Reporting Facility where the trade took place.
trftinteger
The TRF (Trade Reporting Facility) Timestamp in Unix MS. This is the timestamp of when the trade reporting facility received this trade.
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "T",
  "sym": "MSFT",
  "x": 4,
  "i": "12345",
  "z": 3,
  "p": 114.125,
  "s": 100,
  "c": [
    0,
    12
  ],
  "t": 1536036818784,
  "q": 3681328
}
Quotes
WS
Delayed:wss://delayed.polygon.io/stocks
Real-Time:wss://socket.polygon.io/stocks
Stream real-time quotes for a given stock ticker symbol.

Requires a "Stocks Advanced" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"Q.*"}

Copy
Response Attributes
evenum [Q]
The event type.
symstring
The ticker symbol for the given stock.
bxinteger
The bid exchange ID.
bpnumber
The bid price.
bsinteger
The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
axinteger
The ask exchange ID.
apnumber
The ask price.
asinteger
The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
cinteger
The condition.
iarray [integer]
The indicators. For more information, see our glossary of Conditions and Indicators.
tinteger
The SIP timestamp in Unix MS.
qinteger
The sequence number represents the sequence in which quote events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). Values reset after each trading session/day.
zinteger
The tape. (1 = NYSE, 2 = AMEX, 3 = Nasdaq).
Was this helpful?
Help us improve


Yes


No
Response Object
{
  "ev": "Q",
  "sym": "MSFT",
  "bx": 4,
  "bp": 114.125,
  "bs": 100,
  "ax": 7,
  "ap": 114.128,
  "as": 160,
  "c": 0,
  "i": [
    604
  ],
  "t": 1536036818784,
  "q": 50385480,
  "z": 3
}
Fair Market Value
WS
Business:wss://business.polygon.io/stocks
Real-time fair market value for a given stock ticker symbol.

Requires a "Stocks Enterprise" subscription
Upgrade
Parameters
ticker
*

Specify a stock ticker or use * to subscribe to all stock tickers. You can also use a comma separated list to subscribe to multiple stock tickers. You can retrieve available stock tickers from our Stock Tickers API.

{"action":"subscribe", "params":"FMV.*"}

Copy
Response Attributes
evenum [FMV]
The event type.
fmv
Fair market value is only available on Business plans. It is our proprietary algorithm to generate a real-time, accurate, fair market value of a tradable security. For more information, contact us.
sym
The ticker symbol for the given security.
t
The nanosecond timestamp.
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="README.md">
# Trading Dashboard

A real-time trading dashboard with advanced visualization and analytics capabilities. Built with Next.js, TypeScript, and WebSocket for real-time market data updates.

## Features

- Real-time market data updates
- Advanced technical analysis
- Interactive charts and visualizations
- Customizable dashboard layout
- Role-based access control
- Rate limiting and caching
- Dark/light theme support

## Tech Stack

- **Frontend**: Next.js, React, TypeScript
- **State Management**: Zustand
- **Data Visualization**: Recharts
- **Real-time Updates**: WebSocket
- **Caching**: Redis
- **Authentication**: JWT
- **API Integration**: Polygon.io
- **Containerization**: Docker
- **CI/CD**: GitHub Actions

## Prerequisites

- Node.js >= 18
- Docker and Docker Compose
- Redis
- Polygon.io API key

## Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/trading-dashboard.git
   cd trading-dashboard
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Create environment file:
   ```bash
   cp .env.example .env.local
   ```

4. Update environment variables in `.env.local`:
   ```
   POLYGON_API_KEY=your-polygon-api-key
   JWT_SECRET=your-jwt-secret
   REDIS_URL=redis://localhost:6379
   ```

5. Start development server:
   ```bash
   npm run dev
   ```

## Docker Deployment

1. Build and start containers:
   ```bash
   docker-compose up -d
   ```

2. Check application status:
   ```bash
   docker-compose ps
   ```

3. View logs:
   ```bash
   docker-compose logs -f
   ```

## Testing

Run tests:
```bash
# Unit tests
npm test

# Test coverage
npm run test:coverage
```

## Production Deployment

1. Build the application:
   ```bash
   npm run build
   ```

2. Start production server:
   ```bash
   npm start
   ```

## Environment Variables

Required environment variables:

- `POLYGON_API_KEY`: Your Polygon.io API key
- `JWT_SECRET`: Secret key for JWT tokens
- `REDIS_URL`: Redis connection URL
- `NODE_ENV`: Environment (development/production)
- `PORT`: Application port (default: 3000)

See `.env.example` for all available options.

## Project Structure

```
├── app/                  # Next.js app directory
├── components/          # React components
├── lib/                # Core libraries
│   ├── api/           # API clients
│   ├── services/      # Business logic
│   ├── hooks/         # React hooks
│   └── utils/         # Utilities
├── public/            # Static files
├── tests/             # Test files
└── types/             # TypeScript types
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- [Polygon.io](https://polygon.io/) for market data
- [Next.js](https://nextjs.org/) for the framework
- [Recharts](https://recharts.org/) for charts
- [Redis](https://redis.io/) for caching
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";
const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "*.{js,ts,jsx,tsx,mdx}"
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "target": "ES6",
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="tsconfig.test.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "module": "commonjs",
    "target": "es2019",
    "types": ["jest", "node", "@testing-library/jest-dom"],
    "esModuleInterop": true,
    "isolatedModules": true
  },
  "include": [
    "tests/**/*.ts",
    "tests/**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="vercel.json">
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "outputDirectory": ".next"
}
</file>

<file path="vercel.prod.json">
{
  "version": 2,
  "buildCommand": "npm run build",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["iad1"],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "SAMEORIGIN"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        }
      ]
    }
  ],
  "github": {
    "enabled": true,
    "silent": true,
    "autoAlias": true
  },
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next",
      "config": {
        "skipBuildCache": true,
        "nodeVersion": "18.x"
      }
    }
  ],
  "build": {
    "env": {
      "NODE_OPTIONS": "--max-old-space-size=4096"
    }
  }
}
</file>

</files>
